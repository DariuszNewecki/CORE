# Generated by CORE AccumulativeTestService
# Source: src/api/cli_user.py
# Symbols: 1

import asyncio
import sys
from unittest.mock import AsyncMock, Mock, patch

import pytest
import typer
from click.testing import CliRunner

from api.cli_user import main


@pytest.fixture
def mock_ctx():
    ctx = Mock(spec=typer.Context)
    ctx.invoked_subcommand = None
    return ctx

@pytest.fixture
def mock_logger():
    with patch('api.cli_user.logger') as mock_logger:
        yield mock_logger

def test_main_with_message(mock_ctx, mock_logger):
    """Test main function with a valid message."""
    test_message = "analyze the CoreContext class"

    with patch('api.cli_user.asyncio.run') as mock_asyncio_run:
        mock_asyncio_run.return_value = None

        # Call main with message
        main(mock_ctx, test_message)

        # Verify logger was called with user message
        mock_logger.info.assert_any_call("User message: %s", test_message)

        # Verify asyncio.run was called with handle_message
        mock_asyncio_run.assert_called_once()
        call_args = mock_asyncio_run.call_args[0][0]
        assert call_args.__name__ == 'handle_message_wrapper' or 'handle_message' in str(call_args)

def test_main_without_message(mock_ctx, mock_logger):
    """Test main function when no message is provided."""
    mock_ctx.invoked_subcommand = None

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, None)

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call('Usage: core <message>')
    mock_logger.info.assert_any_call('Example: core "what does ContextBuilder do?"')

def test_main_with_subcommand(mock_ctx, mock_logger):
    """Test main function when a subcommand is invoked."""
    mock_ctx.invoked_subcommand = "some_subcommand"

    # Should return early without processing
    result = main(mock_ctx, "some message")
    assert result is None

    # Logger should not have been called with user message
    assert not any("User message" in str(call) for call in mock_logger.info.call_args_list)

def test_main_keyboard_interrupt(mock_ctx, mock_logger):
    """Test main function when KeyboardInterrupt occurs."""
    test_message = "test message"

    with patch('api.cli_user.asyncio.run') as mock_asyncio_run:
        mock_asyncio_run.side_effect = KeyboardInterrupt()

        with pytest.raises(typer.Exit) as exc_info:
            main(mock_ctx, test_message)

        assert exc_info.value.exit_code == 130
        mock_logger.info.assert_any_call("\n\n⚠️  Interrupted by user")

def test_main_general_exception(mock_ctx, mock_logger):
    """Test main function when a general exception occurs."""
    test_message = "test message"
    test_exception = Exception("Test error")

    with patch('api.cli_user.asyncio.run') as mock_asyncio_run:
        mock_asyncio_run.side_effect = test_exception

        with pytest.raises(typer.Exit) as exc_info:
            main(mock_ctx, test_message)

        assert exc_info.value.exit_code == 1
        mock_logger.error.assert_called_once_with(
            "Failed to process message: %s", test_exception, exc_info=True
        )
        mock_logger.info.assert_any_call("\n❌ Error: %s", test_exception)

def test_main_empty_string_message(mock_ctx, mock_logger):
    """Test main function with empty string message."""
    mock_ctx.invoked_subcommand = None

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, "")

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call('Usage: core <message>')
    mock_logger.info.assert_any_call('Example: core "what does ContextBuilder do?"')

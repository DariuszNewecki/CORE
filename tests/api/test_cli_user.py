# Generated by CORE AccumulativeTestService
# Source: src/api/cli_user.py
# Symbols: 1

import asyncio
import sys
from unittest.mock import AsyncMock, Mock, patch

import pytest
import typer

from api.cli_user import main


@pytest.fixture
def mock_ctx():
    ctx = Mock()
    ctx.invoked_subcommand = None
    return ctx

@pytest.fixture
def mock_logger():
    with patch('api.cli_user.logger') as mock_logger:
        yield mock_logger

@pytest.fixture
def mock_handle_message():
    with patch('api.cli_user.handle_message') as mock_handle:
        yield mock_handle

def test_main_with_message(mock_ctx, mock_logger, mock_handle_message):
    """Test main function with a valid message."""
    message = "test message"

    main(mock_ctx, message)

    mock_logger.info.assert_any_call("User message: %s", message)
    mock_handle_message.assert_called_once_with(message)

def test_main_without_message(mock_ctx, mock_logger):
    """Test main function without a message."""
    mock_ctx.invoked_subcommand = None

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, None)

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call("Usage: core <message>")
    mock_logger.info.assert_any_call('Example: core "what does ContextBuilder do?"')

def test_main_with_subcommand(mock_ctx, mock_logger, mock_handle_message):
    """Test main function when a subcommand is invoked."""
    mock_ctx.invoked_subcommand = "some_subcommand"

    main(mock_ctx, "test message")

    mock_logger.info.assert_not_called()
    mock_handle_message.assert_not_called()

def test_main_keyboard_interrupt(mock_ctx, mock_logger, mock_handle_message):
    """Test main function handling KeyboardInterrupt."""
    message = "test message"
    mock_handle_message.side_effect = KeyboardInterrupt()

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, message)

    assert exc_info.value.exit_code == 130
    mock_logger.info.assert_any_call("\n\n⚠️  Interrupted by user")

def test_main_general_exception(mock_ctx, mock_logger, mock_handle_message):
    """Test main function handling general exceptions."""
    message = "test message"
    test_exception = Exception("Test error")
    mock_handle_message.side_effect = test_exception

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, message)

    assert exc_info.value.exit_code == 1
    mock_logger.error.assert_called_once_with(
        "Failed to process message: %s", test_exception, exc_info=True
    )
    mock_logger.info.assert_any_call("\n❌ Error: %s", test_exception)

def test_main_empty_string_message(mock_ctx, mock_logger):
    """Test main function with empty string message."""
    mock_ctx.invoked_subcommand = None

    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, "")

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call("Usage: core <message>")

@patch('asyncio.run')
def test_main_async_execution(mock_asyncio_run, mock_ctx, mock_logger):
    """Test that asyncio.run is called correctly."""
    message = "test message"

    main(mock_ctx, message)

    mock_asyncio_run.assert_called_once()
    mock_logger.info.assert_any_call("User message: %s", message)

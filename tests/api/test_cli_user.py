# Generated by CORE AccumulativeTestService
# Source: src/api/cli_user.py
# Symbols: 1

import asyncio
import sys
from unittest.mock import AsyncMock, Mock, patch

import pytest
import typer

from api.cli_user import main


@pytest.fixture
def mock_ctx():
    """Mock typer.Context object."""
    ctx = Mock(spec=typer.Context)
    ctx.invoked_subcommand = None
    return ctx


@pytest.fixture
def mock_logger():
    """Mock the logger module."""
    with patch('api.cli_user.logger') as mock_logger:
        yield mock_logger


@pytest.fixture
def mock_handle_message():
    """Mock the async handle_message function."""
    with patch('api.cli_user.handle_message') as mock_handle:
        yield mock_handle


def test_main_with_message(mock_ctx, mock_logger, mock_handle_message):
    """Test main function with a valid message."""
    # Arrange
    message = "test message"
    mock_handle_message.return_value = None

    # Act
    main(mock_ctx, message)

    # Assert
    mock_logger.info.assert_any_call("User message: %s", message)
    mock_handle_message.assert_called_once_with(message)


def test_main_without_message(mock_ctx, mock_logger):
    """Test main function without a message."""
    # Arrange
    mock_ctx.invoked_subcommand = None

    # Act & Assert
    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, None)

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call("Usage: core <message>")
    mock_logger.info.assert_any_call('Example: core "what does ContextBuilder do?"')


def test_main_with_subcommand(mock_ctx, mock_logger, mock_handle_message):
    """Test main function when a subcommand is invoked."""
    # Arrange
    mock_ctx.invoked_subcommand = "subcommand"

    # Act
    result = main(mock_ctx, "some message")

    # Assert
    assert result is None
    mock_logger.info.assert_not_called()
    mock_handle_message.assert_not_called()


def test_main_keyboard_interrupt(mock_ctx, mock_logger, mock_handle_message):
    """Test main function handling KeyboardInterrupt."""
    # Arrange
    message = "test message"
    mock_handle_message.side_effect = KeyboardInterrupt()

    # Act & Assert
    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, message)

    assert exc_info.value.exit_code == 130
    mock_logger.info.assert_any_call("\n\n⚠️  Interrupted by user")


def test_main_general_exception(mock_ctx, mock_logger, mock_handle_message):
    """Test main function handling general exceptions."""
    # Arrange
    message = "test message"
    test_exception = Exception("Test error")
    mock_handle_message.side_effect = test_exception

    # Act & Assert
    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, message)

    assert exc_info.value.exit_code == 1
    mock_logger.error.assert_called_once_with(
        "Failed to process message: %s", test_exception, exc_info=True
    )
    mock_logger.info.assert_any_call("\n❌ Error: %s", test_exception)


def test_main_empty_string_message(mock_ctx, mock_logger):
    """Test main function with empty string message."""
    # Arrange
    mock_ctx.invoked_subcommand = None

    # Act & Assert
    with pytest.raises(typer.Exit) as exc_info:
        main(mock_ctx, "")

    assert exc_info.value.exit_code == 1
    mock_logger.info.assert_any_call("Usage: core <message>")


def test_main_async_handler_success(mock_ctx, mock_logger, mock_handle_message):
    """Test main function successfully runs async handler."""
    # Arrange
    message = "analyze the CoreContext class"
    mock_handle_message.return_value = None

    # Act
    main(mock_ctx, message)

    # Assert
    mock_handle_message.assert_called_once_with(message)
    mock_logger.info.assert_any_call("User message: %s", message)

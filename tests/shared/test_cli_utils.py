# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 5

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import confirm_action


@pytest.fixture
def mock_console():
    with patch("shared.cli_utils.console") as mock_console:
        yield mock_console


@pytest.fixture
def mock_confirm():
    with patch("shared.cli_utils.Confirm") as mock_confirm:
        mock_confirm_instance = Mock()
        mock_confirm.ask.return_value = mock_confirm_instance
        yield mock_confirm


def test_confirm_action_confirmed(mock_console, mock_confirm):
    """Test when user confirms the action."""
    mock_confirm.ask.return_value = True

    result = confirm_action("Are you sure?", abort_message="Operation cancelled.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Are you sure?")
    mock_console.print.assert_any_call()
    assert result is True


def test_confirm_action_not_confirmed(mock_console, mock_confirm):
    """Test when user does not confirm the action."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Delete everything?", abort_message="Cancelled deletion.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Delete everything?")
    mock_console.print.assert_any_call("[yellow]Cancelled deletion.[/yellow]")
    mock_console.print.assert_any_call()
    assert result is False


def test_confirm_action_default_abort_message(mock_console, mock_confirm):
    """Test with default abort message."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Proceed?")

    mock_console.print.assert_any_call("[yellow]Aborted.[/yellow]")
    assert result is False


def test_confirm_action_empty_message(mock_console, mock_confirm):
    """Test with empty message string."""
    mock_confirm.ask.return_value = True

    result = confirm_action("")

    mock_confirm.ask.assert_called_once_with("")
    assert result is True


def test_confirm_action_special_characters_message(mock_console, mock_confirm):
    """Test with message containing special characters."""
    mock_confirm.ask.return_value = False
    message = "Delete file: /tmp/test_file.txt? [Y/n]"

    result = confirm_action(message, abort_message="File not deleted.")

    mock_confirm.ask.assert_called_once_with(message)
    mock_console.print.assert_any_call("[yellow]File not deleted.[/yellow]")
    assert result is False

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test that display_error prints formatted error message to console."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console import in the module where display_error is defined
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "Test error message"
        display_error(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        formatted_msg = call_args[0][0]
        assert isinstance(formatted_msg, str)
        assert test_message in formatted_msg
        assert "[bold red]" in formatted_msg
        assert "[/bold red]" in formatted_msg

        # Reset mock for edge case tests
        mock_console.reset_mock()

        # Test with empty string
        display_error("")
        mock_console.print.assert_called_once_with("[bold red][/bold red]")

        # Reset mock
        mock_console.reset_mock()

        # Test with special characters
        special_msg = "Error: 100% & <test>"
        display_error(special_msg)
        mock_console.print.assert_called_once_with(f"[bold red]{special_msg}[/bold red]")

        # Reset mock
        mock_console.reset_mock()

        # Test with multiline string
        multiline_msg = "Line 1\nLine 2\nLine 3"
        display_error(multiline_msg)
        mock_console.print.assert_called_once_with(f"[bold red]{multiline_msg}[/bold red]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_success


def test_display_success():
    """Test that display_success prints formatted message to console."""
    # Arrange
    test_msg = "Operation completed successfully"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_msg}[/bold green]")


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    test_msg = ""
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with("[bold green][/bold green]")


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    test_msg = "Success! 100% done âœ…"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_msg}[/bold green]")


def test_display_success_multiline():
    """Test display_success with multiline message."""
    # Arrange
    test_msg = "Line 1\nLine 2\nLine 3"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_msg}[/bold green]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_info


def test_display_info():
    """Test that display_info correctly prints formatted messages to console."""
    # Mock the console object
    mock_console = Mock()

    # Test basic functionality
    with patch('shared.cli_utils.console', mock_console):
        # Test with normal message
        test_message = "Test info message"
        display_info(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args[0]
        actual_output = call_args[0]

        # Verify the output contains the message with cyan formatting
        assert actual_output == f"[cyan]{test_message}[/cyan]"

        # Reset mock for next test
        mock_console.reset_mock()

        # Test with empty string
        display_info("")
        mock_console.print.assert_called_once_with("[cyan][/cyan]")

        mock_console.reset_mock()

        # Test with special characters
        special_message = "Message with $pecial chars & symbols!"
        display_info(special_message)
        mock_console.print.assert_called_once_with(f"[cyan]{special_message}[/cyan]")

        mock_console.reset_mock()

        # Test with multiline message
        multiline_message = "Line 1\nLine 2\nLine 3"
        display_info(multiline_message)
        mock_console.print.assert_called_once_with(f"[cyan]{multiline_message}[/cyan]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_warning


def test_display_warning():
    """Test display_warning function prints formatted warning message."""
    # Mock console.print to capture calls
    with patch('shared.cli_utils.console.print') as mock_print:
        # Test basic functionality
        test_message = "This is a warning"
        display_warning(test_message)

        # Verify console.print was called exactly once
        mock_print.assert_called_once()

        # Verify the call arguments
        call_args = mock_print.call_args
        assert call_args is not None

        # Extract the actual string passed to console.print
        actual_output = call_args[0][0]

        # Verify the message contains the expected formatting and content
        assert "[yellow]" in actual_output
        assert test_message in actual_output
        assert "[/yellow]" in actual_output
        assert actual_output == f"[yellow]{test_message}[/yellow]"


def test_display_warning_empty_string():
    """Test display_warning with empty string."""
    with patch('shared.cli_utils.console.print') as mock_print:
        display_warning("")
        mock_print.assert_called_once_with("[yellow][/yellow]")


def test_display_warning_special_characters():
    """Test display_warning with special characters."""
    with patch('shared.cli_utils.console.print') as mock_print:
        test_message = "Warning: 100% complete! #important"
        display_warning(test_message)
        mock_print.assert_called_once_with(f"[yellow]{test_message}[/yellow]")


def test_display_warning_multiline():
    """Test display_warning with multiline string."""
    with patch('shared.cli_utils.console.print') as mock_print:
        test_message = "Line 1\nLine 2\nLine 3"
        display_warning(test_message)
        mock_print.assert_called_once_with(f"[yellow]{test_message}[/yellow]")

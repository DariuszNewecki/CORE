# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 5

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test display_error function prints formatted error message."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console in the module where it's imported
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "Test error message"
        display_error(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        formatted_message = call_args[0][0]
        assert test_message in formatted_message
        assert "[bold red]" in formatted_message
        assert "[/bold red]" in formatted_message

        # Reset mock for edge case tests
        mock_console.reset_mock()

        # Test with empty string
        display_error("")
        mock_console.print.assert_called_once_with("[bold red][/bold red]")

        # Reset mock again
        mock_console.reset_mock()

        # Test with special characters
        special_message = "Error: <tag> & 'quotes'"
        display_error(special_message)
        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args
        assert special_message in call_args[0][0]

        # Reset mock again
        mock_console.reset_mock()

        # Test with very long message
        long_message = "A" * 1000
        display_error(long_message)
        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args
        assert long_message in call_args[0][0]

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_success


def test_display_success():
    """Test display_success function prints formatted message to console."""
    # Arrange
    mock_console = Mock()
    test_message = "Operation completed successfully"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success("")

    # Assert
    mock_console.print.assert_called_once_with("[bold green][/bold green]")


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    mock_console = Mock()
    test_message = "Success! 100% done. Line1\nLine2\tTab"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_unicode():
    """Test display_success with unicode characters."""
    # Arrange
    mock_console = Mock()
    test_message = "âœ… Success! CafÃ© rÃ©sumÃ© ðŸŽ‰"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_info


def test_display_info():
    """Test display_info function prints formatted message to console."""
    # Arrange
    test_message = "Test info message"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_info(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[cyan]{test_message}[/cyan]")


def test_display_info_empty_string():
    """Test display_info with empty string."""
    # Arrange
    test_message = ""
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_info(test_message)

    # Assert
    mock_console.print.assert_called_once_with("[cyan][/cyan]")


def test_display_info_special_characters():
    """Test display_info with special characters in message."""
    # Arrange
    test_message = "Line 1\nLine 2\tTabbed"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_info(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[cyan]{test_message}[/cyan]")


def test_display_info_unicode():
    """Test display_info with unicode characters."""
    # Arrange
    test_message = "Unicode: ðŸš€ âœ… Â©"
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_info(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[cyan]{test_message}[/cyan]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_warning


def test_display_warning():
    """Test display_warning prints formatted message to console."""
    # Mock the console object
    mock_console = Mock()

    # Patch console in the module where it's imported
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "This is a warning"
        display_warning(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains our message with yellow formatting
        assert len(call_args[0]) == 1
        formatted_message = call_args[0][0]
        assert test_message in formatted_message
        assert "[yellow]" in formatted_message
        assert "[/yellow]" in formatted_message

        # Reset mock for edge case tests
        mock_console.reset_mock()

        # Test with empty string
        display_warning("")
        mock_console.print.assert_called_once_with("[yellow][/yellow]")

        # Reset mock
        mock_console.reset_mock()

        # Test with special characters
        special_msg = "Warning: 100% complete & <tag>"
        display_warning(special_msg)
        mock_console.print.assert_called_once_with(f"[yellow]{special_msg}[/yellow]")

import asyncio
from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import async_command


def test_async_command():
    """Test the async_command decorator functionality and edge cases."""

    # Test 1: Basic functionality - decorator runs async function correctly
    @async_command
    async def sample_async_func(x: int, y: int) -> int:
        await asyncio.sleep(0.001)  # Simulate async work
        return x + y

    result = sample_async_func(3, 4)
    assert result == 7

    # Test 2: Decorator preserves function metadata
    assert sample_async_func.__name__ == "sample_async_func"

    # Test 3: Async function with no arguments
    @async_command
    async def no_args_func() -> str:
        await asyncio.sleep(0.001)
        return "success"

    assert no_args_func() == "success"

    # Test 4: Async function with keyword arguments
    @async_command
    async def kwargs_func(**kwargs) -> dict:
        await asyncio.sleep(0.001)
        return kwargs

    result = kwargs_func(a=1, b=2, c=3)
    assert result == {"a": 1, "b": 2, "c": 3}

    # Test 5: Async function that raises an exception
    @async_command
    async def failing_func() -> None:
        await asyncio.sleep(0.001)
        raise ValueError("Test error")

    with pytest.raises(ValueError, match="Test error"):
        failing_func()

    # Test 6: Cannot be called from within a running event loop
    @async_command
    async def inner_func() -> str:
        return "inner"

    async def run_in_loop():
        with pytest.raises(
            RuntimeError,
            match="async_command cannot run inside an already-running event loop"
        ):
            inner_func()

    # Create and run a loop to test the restriction
    loop = asyncio.new_event_loop()
    try:
        loop.run_until_complete(run_in_loop())
    finally:
        loop.close()

    # Test 7: Works when no loop is running (already tested in basic cases)
    # This is covered by all the successful calls above

    # Test 8: Decorator works with functions that return None
    @async_command
    async def none_return_func() -> None:
        await asyncio.sleep(0.001)

    assert none_return_func() is None

    # Test 9: Complex return type
    @async_command
    async def complex_return_func() -> list:
        await asyncio.sleep(0.001)
        return [1, 2, 3]

    assert complex_return_func() == [1, 2, 3]

    # Test 10: Verify asyncio.run is called with correct arguments
    with patch("asyncio.run") as mock_run:
        mock_run.return_value = "mocked_result"

        @async_command
        async def mocked_func(arg1, arg2):
            return arg1 + arg2

        result = mocked_func(10, 20)

        # Verify asyncio.run was called once
        assert mock_run.call_count == 1

        # Get the coroutine that was passed to asyncio.run
        call_args = mock_run.call_args
        coro = call_args[0][0]

        # Execute the coroutine to verify it's the right function
        # (This is a bit hacky but verifies the right function was wrapped)
        async def execute_coro():
            return await coro

        # Create a new loop to test the coroutine
        test_loop = asyncio.new_event_loop()
        try:
            coro_result = test_loop.run_until_complete(execute_coro())
            assert coro_result == 30  # 10 + 20
        finally:
            test_loop.close()

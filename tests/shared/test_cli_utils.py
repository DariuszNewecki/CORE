# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 6

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import confirm_action


@pytest.fixture
def mock_console():
    with patch("shared.cli_utils.console") as mock_console:
        yield mock_console


@pytest.fixture
def mock_confirm():
    with patch("shared.cli_utils.Confirm") as mock_confirm:
        mock_confirm_instance = Mock()
        mock_confirm.ask.return_value = mock_confirm_instance
        yield mock_confirm


def test_confirm_action_confirmed(mock_console, mock_confirm):
    """Test when user confirms the action."""
    mock_confirm.ask.return_value = True

    result = confirm_action("Are you sure?", abort_message="Cancelled.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Are you sure?")
    mock_console.print.assert_any_call()
    assert result is True


def test_confirm_action_not_confirmed(mock_console, mock_confirm):
    """Test when user does not confirm the action."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Delete everything?", abort_message="Operation cancelled.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Delete everything?")
    mock_console.print.assert_any_call("[yellow]Operation cancelled.[/yellow]")
    mock_console.print.assert_any_call()
    assert result is False


def test_confirm_action_default_abort_message(mock_console, mock_confirm):
    """Test with default abort message."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Proceed?")

    mock_console.print.assert_any_call("[yellow]Aborted.[/yellow]")
    assert result is False


def test_confirm_action_empty_message(mock_console, mock_confirm):
    """Test with empty message string."""
    mock_confirm.ask.return_value = True

    result = confirm_action("", abort_message="Stopped.")

    mock_confirm.ask.assert_called_once_with("")
    assert result is True


def test_confirm_action_special_characters(mock_console, mock_confirm):
    """Test with message containing special characters."""
    mock_confirm.ask.return_value = False
    message = "Delete file: /tmp/test.txt? [Y/n]"
    abort_msg = "‚ùå Action stopped!"

    result = confirm_action(message, abort_message=abort_msg)

    mock_confirm.ask.assert_called_once_with(message)
    mock_console.print.assert_any_call(f"[yellow]{abort_msg}[/yellow]")
    assert result is False

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test display_error prints formatted error message to console."""
    # Mock the console object
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_msg = "Test error message"
        display_error(test_msg)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        formatted_msg = call_args[0][0]
        assert test_msg in formatted_msg
        assert "[bold red]" in formatted_msg
        assert "[/bold red]" in formatted_msg

        # Test with empty string
        mock_console.reset_mock()
        display_error("")
        mock_console.print.assert_called_once_with("[bold red][/bold red]")

        # Test with special characters
        mock_console.reset_mock()
        special_msg = "Error: 123 & !@#$%^&*()"
        display_error(special_msg)
        mock_console.print.assert_called_once_with(f"[bold red]{special_msg}[/bold red]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_success


def test_display_success():
    """Test display_success function prints formatted message to console."""
    # Arrange
    mock_console = Mock()
    test_message = "Operation completed successfully"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once()

    # Check the call arguments
    call_args = mock_console.print.call_args[0][0]

    # Verify the message contains the expected formatting and content
    assert "[bold green]" in call_args
    assert test_message in call_args
    assert "[/bold green]" in call_args
    assert call_args == f"[bold green]{test_message}[/bold green]"


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success("")

    # Assert
    mock_console.print.assert_called_once_with("[bold green][/bold green]")


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    mock_console = Mock()
    test_message = "Success! 100% ‚úì üéâ"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_multiline():
    """Test display_success with multiline message."""
    # Arrange
    mock_console = Mock()
    test_message = "Line 1\nLine 2\nLine 3"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_info


def test_display_info():
    """Test display_info prints formatted message to console."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console in shared.cli_utils module
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "Test info message"
        display_info(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains our message with cyan formatting
        assert len(call_args[0]) == 1
        formatted_msg = call_args[0][0]
        assert test_message in formatted_msg
        assert "[cyan]" in formatted_msg
        assert "[/cyan]" in formatted_msg

        # Test edge case: empty string
        mock_console.reset_mock()
        display_info("")
        mock_console.print.assert_called_once_with("[cyan][/cyan]")

        # Test edge case: string with special characters
        mock_console.reset_mock()
        special_msg = "Line1\nLine2\tTab"
        display_info(special_msg)
        mock_console.print.assert_called_once_with(f"[cyan]{special_msg}[/cyan]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_warning


def test_display_warning():
    """Test that display_warning prints formatted warning messages."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console in the module where it's imported
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_msg = "This is a warning"
        display_warning(test_msg)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args[0]

        # Verify the message contains the expected formatting
        assert len(call_args) == 1
        formatted_msg = call_args[0]
        assert f"[yellow]{test_msg}[/yellow]" == formatted_msg

def test_display_warning_empty_string():
    """Test display_warning with empty string."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        display_warning("")

        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert len(call_args) == 1
        assert "[yellow][/yellow]" == call_args[0]

def test_display_warning_special_characters():
    """Test display_warning with special characters."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        test_msg = "Warning: 100% complete! Use <caution>."
        display_warning(test_msg)

        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert len(call_args) == 1
        assert f"[yellow]{test_msg}[/yellow]" == call_args[0]

def test_display_warning_multiline():
    """Test display_warning with multiline message."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        test_msg = "Line 1\nLine 2\nLine 3"
        display_warning(test_msg)

        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert len(call_args) == 1
        assert f"[yellow]{test_msg}[/yellow]" == call_args[0]

import asyncio
from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import async_command


def test_async_command():
    """Test the async_command decorator functionality and edge cases."""

    # Test 1: Basic functionality - decorator runs async function successfully
    @async_command
    async def sample_async_func(x: int, y: int) -> int:
        await asyncio.sleep(0.001)  # Simulate async work
        return x + y

    result = sample_async_func(3, 4)
    assert result == 7

    # Test 2: Decorator preserves function metadata
    assert sample_async_func.__name__ == "sample_async_func"

    # Test 3: Function with no arguments works correctly
    @async_command
    async def no_args_func() -> str:
        await asyncio.sleep(0.001)
        return "success"

    assert no_args_func() == "success"

    # Test 4: Function with keyword arguments works correctly
    @async_command
    async def kwargs_func(a: int, b: int = 10) -> int:
        await asyncio.sleep(0.001)
        return a * b

    assert kwargs_func(5) == 50
    assert kwargs_func(5, b=2) == 10

    # Test 5: Async function that raises exception - exception should propagate
    @async_command
    async def failing_func() -> None:
        await asyncio.sleep(0.001)
        raise ValueError("Test error")

    with pytest.raises(ValueError, match="Test error"):
        failing_func()

    # Test 6: When called from within a running event loop - should raise RuntimeError
    @async_command
    async def inner_func() -> str:
        return "should not run"

    async def test_running_loop():
        with pytest.raises(RuntimeError, match="async_command cannot run inside an already-running event loop"):
            inner_func()

    # Create and run a loop to test the running loop detection
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        loop.run_until_complete(test_running_loop())
    finally:
        loop.close()
        asyncio.set_event_loop(None)

    # Test 7: When no loop is running but loop exists (not running) - should work
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        # Loop exists but is not running
        @async_command
        async def check_loop_func() -> bool:
            return asyncio.get_running_loop() is not None

        result = check_loop_func()
        assert result is True  # Should have created and run a new loop
    finally:
        loop.close()
        asyncio.set_event_loop(None)

    # Test 8: Complex return type (dict)
    @async_command
    async def dict_return_func() -> dict:
        await asyncio.sleep(0.001)
        return {"status": "ok", "value": 42}

    result = dict_return_func()
    assert result == {"status": "ok", "value": 42}

    # Test 9: Function with *args and **kwargs
    @async_command
    async def var_args_func(*args, **kwargs) -> tuple:
        await asyncio.sleep(0.001)
        return (args, kwargs)

    result = var_args_func(1, 2, 3, a=4, b=5)
    assert result == ((1, 2, 3), {"a": 4, "b": 5})

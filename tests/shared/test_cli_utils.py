# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 5

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test that display_error prints formatted error message to console."""
    # Arrange
    mock_console = Mock()
    test_message = "Test error message"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_error(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold red]{test_message}[/bold red]")


def test_display_error_empty_string():
    """Test that display_error handles empty string input."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_error("")

    # Assert
    mock_console.print.assert_called_once_with("[bold red][/bold red]")


def test_display_error_with_special_characters():
    """Test that display_error handles strings with special characters."""
    # Arrange
    mock_console = Mock()
    test_message = "Error: 100% complete\nLine break\tTab"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_error(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold red]{test_message}[/bold red]")


def test_display_error_called_exactly_once():
    """Test that display_error calls console.print exactly once."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_error("Test")

    # Assert
    assert mock_console.print.call_count == 1


def test_display_error_returns_none():
    """Test that display_error returns None."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        result = display_error("Test")

    # Assert
    assert result is None

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_success


def test_display_success():
    """Test display_success function prints formatted message to console."""
    # Arrange
    test_msg = "Operation completed successfully"
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    test_msg = ""
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    test_msg = "Success! âœ… (code: 123-456)"
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_multiline():
    """Test display_success with multiline message."""
    # Arrange
    test_msg = "Success!\nDetails: All operations completed.\nStatus: OK"
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_info


def test_display_info():
    """Test display_info prints formatted message to console."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console import inside cli_utils
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "Test info message"
        display_info(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1, "console.print should be called with exactly one argument"
        formatted_msg = call_args[0][0]

        # Check that the message contains our test message wrapped in cyan tags
        assert test_message in formatted_msg
        assert "[cyan]" in formatted_msg
        assert "[/cyan]" in formatted_msg

        # Test with empty string
        mock_console.reset_mock()
        display_info("")
        mock_console.print.assert_called_once_with("[cyan][/cyan]")

        # Test with special characters
        mock_console.reset_mock()
        special_msg = "Message with \n newline and \t tab"
        display_info(special_msg)
        mock_console.print.assert_called_once_with(f"[cyan]{special_msg}[/cyan]")

        # Test with very long message
        mock_console.reset_mock()
        long_msg = "x" * 1000
        display_info(long_msg)
        mock_console.print.assert_called_once_with(f"[cyan]{long_msg}[/cyan]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_warning


def test_display_warning():
    """Test display_warning function prints formatted warning message."""
    # Mock the console object
    mock_console = Mock()

    # Patch console.print to use our mock
    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "This is a warning"
        display_warning(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args[0]

        # Verify the argument contains the formatted message
        assert len(call_args) == 1
        assert call_args[0] == f"[yellow]{test_message}[/yellow]"

        # Reset mock for edge case tests
        mock_console.reset_mock()

        # Test with empty string
        display_warning("")
        mock_console.print.assert_called_once_with("[yellow][/yellow]")

        # Reset mock again
        mock_console.reset_mock()

        # Test with special characters
        special_msg = "Warning: 100% complete & <important>!"
        display_warning(special_msg)
        mock_console.print.assert_called_once_with(f"[yellow]{special_msg}[/yellow]")

import asyncio
from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import async_command


def test_async_command():
    """Test the async_command decorator for legacy async commands."""

    # Test 1: Basic functionality - decorator runs async function correctly
    @async_command
    async def sample_async_func(x: int, y: int) -> int:
        await asyncio.sleep(0.001)  # Simulate async work
        return x + y

    result = sample_async_func(3, 4)
    assert result == 7

    # Test 2: Decorator preserves function metadata
    assert sample_async_func.__name__ == "sample_async_func"

    # Test 3: Works with keyword arguments
    @async_command
    async def kwarg_func(a: int, b: int = 10) -> int:
        await asyncio.sleep(0.001)
        return a * b

    assert kwarg_func(3) == 30
    assert kwarg_func(3, b=5) == 15

    # Test 4: Raises RuntimeError when called from within running event loop
    @async_command
    async def inner_func() -> str:
        await asyncio.sleep(0.001)
        return "test"

    async def run_in_loop():
        with pytest.raises(RuntimeError) as exc_info:
            inner_func()
        assert "async_command cannot run inside an already-running event loop" in str(exc_info.value)

    asyncio.run(run_in_loop())

    # Test 5: Works with no running loop (normal synchronous context)
    # This is already tested by test 1, but let's explicitly test with mocked get_running_loop
    with patch('asyncio.get_running_loop', side_effect=RuntimeError):
        @async_command
        async def no_loop_func() -> str:
            await asyncio.sleep(0.001)
            return "success"

        result = no_loop_func()
        assert result == "success"

    # Test 6: Exception propagation - exceptions from async function are raised properly
    @async_command
    async def failing_func() -> None:
        await asyncio.sleep(0.001)
        raise ValueError("Test error")

    with pytest.raises(ValueError, match="Test error"):
        failing_func()

    # Test 7: Works with complex return types
    @async_command
    async def dict_func() -> dict:
        await asyncio.sleep(0.001)
        return {"key": "value", "number": 42}

    result = dict_func()
    assert result == {"key": "value", "number": 42}

    # Test 8: Verify wrapper doesn't break when loop exists but isn't running
    mock_loop = Mock()
    mock_loop.is_running.return_value = False

    with patch('asyncio.get_running_loop', return_value=mock_loop):
        @async_command
        async def mock_loop_func() -> int:
            await asyncio.sleep(0.001)
            return 100

        result = mock_loop_func()
        assert result == 100
        mock_loop.is_running.assert_called_once()

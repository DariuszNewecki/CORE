# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 6

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import confirm_action


@pytest.fixture
def mock_console():
    with patch("shared.cli_utils.console") as mock_console:
        yield mock_console


@pytest.fixture
def mock_confirm():
    with patch("shared.cli_utils.Confirm") as mock_confirm:
        mock_confirm_instance = Mock()
        mock_confirm.ask.return_value = mock_confirm_instance
        yield mock_confirm


def test_confirm_action_confirmed(mock_console, mock_confirm):
    """Test when user confirms the action."""
    mock_confirm.ask.return_value = True

    result = confirm_action("Are you sure?", abort_message="Cancelled.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Are you sure?")
    mock_console.print.assert_any_call()
    assert result is True
    assert mock_console.print.call_count == 2


def test_confirm_action_not_confirmed(mock_console, mock_confirm):
    """Test when user does not confirm the action."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Delete everything?", abort_message="Operation cancelled.")

    mock_console.print.assert_any_call()
    mock_confirm.ask.assert_called_once_with("Delete everything?")
    mock_console.print.assert_any_call("[yellow]Operation cancelled.[/yellow]")
    mock_console.print.assert_any_call()
    assert result is False
    assert mock_console.print.call_count == 3


def test_confirm_action_default_abort_message(mock_console, mock_confirm):
    """Test with default abort message."""
    mock_confirm.ask.return_value = False

    result = confirm_action("Proceed?")

    mock_console.print.assert_any_call("[yellow]Aborted.[/yellow]")
    assert result is False


def test_confirm_action_empty_message(mock_console, mock_confirm):
    """Test with empty message string."""
    mock_confirm.ask.return_value = True

    result = confirm_action("")

    mock_confirm.ask.assert_called_once_with("")
    assert result is True

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test display_error function prints formatted error message."""
    # Mock console object
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_msg = "Test error message"
        display_error(test_msg)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        formatted_msg = call_args[0][0]
        assert test_msg in formatted_msg
        assert "[bold red]" in formatted_msg
        assert "[/bold red]" in formatted_msg

        # Reset mock for edge case tests
        mock_console.reset_mock()

        # Test with empty string
        display_error("")
        mock_console.print.assert_called_once_with("[bold red][/bold red]")

        # Reset mock again
        mock_console.reset_mock()

        # Test with special characters
        special_msg = "Error: 100% & <test>"
        display_error(special_msg)
        mock_console.print.assert_called_once_with(f"[bold red]{special_msg}[/bold red]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_success


def test_display_success():
    """Test display_success function prints formatted message to console."""
    # Arrange
    mock_console = Mock()
    test_message = "Operation completed successfully"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    mock_console = Mock()

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success("")

    # Assert
    mock_console.print.assert_called_once_with("[bold green][/bold green]")


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    mock_console = Mock()
    test_message = "Success! 100% done. Line1\nLine2\tTab"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_unicode():
    """Test display_success with unicode characters."""
    # Arrange
    mock_console = Mock()
    test_message = "✅ Success! Café résumé 你好"

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")


def test_display_success_very_long_message():
    """Test display_success with a very long message."""
    # Arrange
    mock_console = Mock()
    test_message = "A" * 1000  # Very long message

    # Act
    with patch('shared.cli_utils.console', mock_console):
        display_success(test_message)

    # Assert
    mock_console.print.assert_called_once_with(f"[bold green]{test_message}[/bold green]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_info


def test_display_info():
    """Test display_info prints formatted message to console."""
    # Mock the console object
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_message = "Test info message"
        display_info(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains our message with cyan formatting
        assert len(call_args[0]) == 1, "console.print should be called with exactly one argument"
        formatted_message = call_args[0][0]

        # Check the formatting and message content
        assert formatted_message.startswith("[cyan]"), "Message should start with cyan formatting"
        assert formatted_message.endswith("[/cyan]"), "Message should end with cyan formatting"
        assert test_message in formatted_message, "Original message should be in formatted output"

        # Verify the exact format
        assert formatted_message == f"[cyan]{test_message}[/cyan]"

        # Test with empty string
        mock_console.reset_mock()
        display_info("")
        mock_console.print.assert_called_once_with("[cyan][/cyan]")

        # Test with special characters
        mock_console.reset_mock()
        special_msg = "Message with \n newline and \t tab"
        display_info(special_msg)
        mock_console.print.assert_called_once_with(f"[cyan]{special_msg}[/cyan]")

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_warning


def test_display_warning():
    """Test display_warning function prints formatted warning message."""
    # Mock the console object
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        # Test basic functionality
        test_msg = "This is a warning"
        display_warning(test_msg)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args[0]

        # Verify the argument contains the message with yellow formatting
        assert len(call_args) == 1
        assert test_msg in call_args[0]
        assert "[yellow]" in call_args[0]
        assert "[/yellow]" in call_args[0]
        assert call_args[0] == f"[yellow]{test_msg}[/yellow]"

def test_display_warning_empty_string():
    """Test display_warning with empty string."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        display_warning("")

        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert call_args[0] == "[yellow][/yellow]"

def test_display_warning_special_characters():
    """Test display_warning with special characters."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        test_msg = "Warning: 100% complete! Line 1\nLine 2\tTab"
        display_warning(test_msg)

        mock_console.print.assert_called_once()
        call_args = mock_console.print.call_args[0]
        assert call_args[0] == f"[yellow]{test_msg}[/yellow]"

def test_display_warning_multiple_calls():
    """Test display_warning called multiple times."""
    mock_console = Mock()

    with patch('shared.cli_utils.console', mock_console):
        # First call
        display_warning("First warning")

        # Second call
        display_warning("Second warning")

        # Verify console.print was called twice
        assert mock_console.print.call_count == 2

        # Get all calls
        calls = mock_console.print.call_args_list

        # Verify first call
        assert calls[0][0][0] == "[yellow]First warning[/yellow]"

        # Verify second call
        assert calls[1][0][0] == "[yellow]Second warning[/yellow]"

import asyncio
from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import async_command


def test_async_command():
    """Test the async_command decorator functionality and edge cases."""

    # Test 1: Basic functionality - decorator runs async function correctly
    @async_command
    async def sample_async_func(x: int, y: int) -> int:
        await asyncio.sleep(0.001)  # Simulate async work
        return x + y

    result = sample_async_func(3, 4)
    assert result == 7

    # Test 2: Decorator preserves function metadata
    assert sample_async_func.__name__ == "sample_async_func"

    # Test 3: Function with no arguments
    @async_command
    async def no_args_func() -> str:
        await asyncio.sleep(0.001)
        return "success"

    assert no_args_func() == "success"

    # Test 4: Function with keyword arguments
    @async_command
    async def kwargs_func(a: int, b: int = 10) -> int:
        await asyncio.sleep(0.001)
        return a * b

    assert kwargs_func(5) == 50
    assert kwargs_func(5, b=2) == 10

    # Test 5: Function that raises exception
    @async_command
    async def failing_func() -> None:
        await asyncio.sleep(0.001)
        raise ValueError("Test error")

    with pytest.raises(ValueError, match="Test error"):
        failing_func()

    # Test 6: Nested decorator usage (should raise RuntimeError when called from running loop)
    @async_command
    async def nested_test() -> str:
        await asyncio.sleep(0.001)
        return "nested"

    # Create a running event loop
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    async def run_in_loop():
        with pytest.raises(RuntimeError, match="async_command cannot run inside an already-running event loop"):
            # This should fail because we're inside a running loop
            nested_test()

    loop.run_until_complete(run_in_loop())
    loop.close()

    # Clean up event loop
    asyncio.set_event_loop(None)

    # Test 7: Verify wrapper doesn't accept nested decorator calls
    # by checking it raises RuntimeError when loop is running
    @async_command
    async def simple_func() -> int:
        return 42

    # Mock asyncio.get_running_loop to simulate running loop
    mock_loop = Mock()
    mock_loop.is_running.return_value = True

    with patch('asyncio.get_running_loop', return_value=mock_loop):
        with pytest.raises(RuntimeError, match="async_command cannot run inside an already-running event loop"):
            simple_func()

    # Test 8: When no loop is running, asyncio.run should be called
    with patch('asyncio.run') as mock_run:
        mock_run.return_value = "mocked_result"

        @async_command
        async def mocked_func() -> str:
            return "actual"

        result = mocked_func()
        assert result == "mocked_result"
        assert mock_run.called

    # Test 9: Decorator works with functions returning various types
    @async_command
    async def dict_func() -> dict:
        await asyncio.sleep(0.001)
        return {"key": "value"}

    @async_command
    async def list_func() -> list:
        await asyncio.sleep(0.001)
        return [1, 2, 3]

    assert dict_func() == {"key": "value"}
    assert list_func() == [1, 2, 3]

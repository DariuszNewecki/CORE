# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_utils.py
# Symbols: 5

from unittest.mock import Mock, patch

import pytest

from shared.cli_utils import display_error


def test_display_error():
    """Test that display_error prints formatted error message to console."""
    # Create a mock console object
    mock_console = Mock()

    # Patch the console in the shared.cli_utils module
    with patch("shared.cli_utils.console", mock_console):
        # Test basic functionality
        test_message = "Test error message"
        display_error(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        formatted_message = call_args[0][0]
        assert test_message in formatted_message
        assert "[bold red]" in formatted_message
        assert "[/bold red]" in formatted_message

        # Test with empty string
        mock_console.reset_mock()
        display_error("")
        mock_console.print.assert_called_once_with("[bold red][/bold red]")

        # Test with special characters
        mock_console.reset_mock()
        special_message = "Error: 123 !@#$%^&*()"
        display_error(special_message)
        mock_console.print.assert_called_once_with(
            f"[bold red]{special_message}[/bold red]"
        )

        # Test with multiline string
        mock_console.reset_mock()
        multiline_message = "Line 1\nLine 2\nLine 3"
        display_error(multiline_message)
        mock_console.print.assert_called_once_with(
            f"[bold red]{multiline_message}[/bold red]"
        )


from shared.cli_utils import display_success


def test_display_success():
    """Test display_success function prints formatted message to console."""
    # Arrange
    test_msg = "Operation completed successfully"
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch("shared.cli_utils.console", mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_empty_string():
    """Test display_success with empty message."""
    # Arrange
    test_msg = ""
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch("shared.cli_utils.console", mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_special_characters():
    """Test display_success with special characters in message."""
    # Arrange
    test_msg = "Success! ðŸŽ‰ Data processed: 100% (âœ“)"
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch("shared.cli_utils.console", mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


def test_display_success_long_message():
    """Test display_success with a long message."""
    # Arrange
    test_msg = (
        "This is a very long success message that contains multiple sentences. "
        "It should still be formatted correctly with the green bold styling. "
        "The function should handle messages of any length without issues."
    )
    expected_formatted_msg = f"[bold green]{test_msg}[/bold green]"

    mock_console = Mock()

    # Act
    with patch("shared.cli_utils.console", mock_console):
        display_success(test_msg)

    # Assert
    mock_console.print.assert_called_once_with(expected_formatted_msg)


from shared.cli_utils import display_info


def test_display_info():
    """Test that display_info prints formatted message to console."""
    # Create a mock console object
    mock_console = Mock()

    # Patch the console object in the module where it's imported
    with patch("shared.cli_utils.console", mock_console):
        # Test basic functionality
        test_message = "Test info message"
        display_info(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument that was passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1  # Single positional argument
        formatted_msg = call_args[0][0]

        # Check that the message contains our test message
        assert test_message in formatted_msg

        # Check that the message contains cyan formatting tags
        assert "[cyan]" in formatted_msg
        assert "[/cyan]" in formatted_msg

        # Test with empty string
        mock_console.reset_mock()
        display_info("")
        mock_console.print.assert_called_once_with("[cyan][/cyan]")

        # Test with special characters
        mock_console.reset_mock()
        special_msg = "Message with \n newline and \t tab"
        display_info(special_msg)
        mock_console.print.assert_called_once_with(f"[cyan]{special_msg}[/cyan]")


from shared.cli_utils import display_warning


def test_display_warning():
    """Test that display_warning prints formatted warning message."""
    # Mock the console object
    mock_console = Mock()

    # Patch the console import inside cli_utils module
    with patch("shared.cli_utils.console", mock_console):
        # Test basic functionality
        test_message = "This is a warning"
        display_warning(test_message)

        # Verify console.print was called exactly once
        mock_console.print.assert_called_once()

        # Get the actual argument passed to console.print
        call_args = mock_console.print.call_args

        # Verify the argument contains the formatted message
        assert len(call_args[0]) == 1
        assert call_args[0][0] == f"[yellow]{test_message}[/yellow]"

        # Verify no keyword arguments were passed
        assert call_args[1] == {}


def test_display_warning_empty_string():
    """Test display_warning with empty string."""
    mock_console = Mock()

    with patch("shared.cli_utils.console", mock_console):
        display_warning("")
        mock_console.print.assert_called_once_with("[yellow][/yellow]")


def test_display_warning_special_characters():
    """Test display_warning with special characters."""
    mock_console = Mock()

    with patch("shared.cli_utils.console", mock_console):
        test_message = "Warning: 100% complete! #important"
        display_warning(test_message)
        mock_console.print.assert_called_once_with(f"[yellow]{test_message}[/yellow]")


def test_display_warning_multiline():
    """Test display_warning with multiline string."""
    mock_console = Mock()

    with patch("shared.cli_utils.console", mock_console):
        test_message = "Line 1\nLine 2\nLine 3"
        display_warning(test_message)
        mock_console.print.assert_called_once_with(f"[yellow]{test_message}[/yellow]")


import asyncio

from shared.cli_utils import async_command


def test_async_command():
    """Test the async_command decorator functionality."""

    # Test 1: Basic async function execution
    @async_command
    async def basic_async_func(x: int, y: int) -> int:
        await asyncio.sleep(0.001)  # Simulate async work
        return x + y

    result = basic_async_func(3, 4)
    assert result == 7

    # Test 2: Async function with keyword arguments
    @async_command
    async def kwarg_async_func(name: str, greeting: str = "Hello") -> str:
        await asyncio.sleep(0.001)
        return f"{greeting}, {name}!"

    result = kwarg_async_func("Alice", greeting="Hi")
    assert result == "Hi, Alice!"

    # Test 3: Async function with no arguments
    @async_command
    async def no_arg_async_func() -> str:
        await asyncio.sleep(0.001)
        return "success"

    result = no_arg_async_func()
    assert result == "success"

    # Test 4: Async function that raises an exception
    @async_command
    async def failing_async_func() -> None:
        await asyncio.sleep(0.001)
        raise ValueError("Test error")

    with pytest.raises(ValueError, match="Test error"):
        failing_async_func()

    # Test 5: Decorator preserves function metadata
    @async_command
    async def documented_func() -> int:
        """A documented async function."""
        return 42

    assert documented_func.__name__ == "documented_func"
    assert documented_func.__doc__ == "A documented async function."

    # Test 6: Cannot nest inside already running event loop
    @async_command
    async def nested_async_func() -> str:
        return "nested"

    async def run_in_loop():
        with pytest.raises(
            RuntimeError,
            match="async_command cannot run inside an already-running event loop",
        ):
            nested_async_func()

    # Create and run a loop to test the nesting restriction
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    try:
        loop.run_until_complete(run_in_loop())
    finally:
        loop.close()
        asyncio.set_event_loop(None)

    # Test 7: Works when no loop is running (re-run basic test to ensure)
    result = basic_async_func(10, 20)
    assert result == 30

    # Test 8: Async function with complex return type
    @async_command
    async def complex_async_func() -> dict:
        await asyncio.sleep(0.001)
        return {"status": "ok", "data": [1, 2, 3]}

    result = complex_async_func()
    assert result == {"status": "ok", "data": [1, 2, 3]}

    # Test 9: Verify wrapper doesn't break sync function (though decorator is for async)
    # This should work since asyncio.run will handle it
    @async_command
    async def mixed_func(sync_arg: bool = False) -> str:
        if sync_arg:
            return "sync_path"  # No await
        await asyncio.sleep(0.001)
        return "async_path"

    result1 = mixed_func(sync_arg=True)
    assert result1 == "sync_path"

    result2 = mixed_func(sync_arg=False)
    assert result2 == "async_path"

# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_types.py
# Symbols: 2

from datetime import datetime
from unittest.mock import Mock, patch

import pytest

from shared.cli_types import CommandResult


def test_CommandResult():
    """Test basic functionality, edge cases, and correctness of CommandResult."""

    # Test basic initialization with required fields
    result = CommandResult(
        name="test.command",
        ok=True,
        data={"count": 5, "items": ["a", "b"]},
        duration_sec=1.5,
        logs=["Starting", "Processing", "Complete"]
    )

    assert result.name == "test.command"
    assert result.ok is True
    assert result.data == {"count": 5, "items": ["a", "b"]}
    assert result.duration_sec == 1.5
    assert result.logs == ["Starting", "Processing", "Complete"]

    # Test initialization with minimal required fields
    result = CommandResult(
        name="minimal.command",
        ok=False,
        data={}
    )

    assert result.name == "minimal.command"
    assert result.ok is False
    assert result.data == {}
    assert result.duration_sec == 0.0
    assert result.logs == []

    # Test default values
    result = CommandResult(
        name="default.command",
        ok=True,
        data={"key": "value"}
    )

    assert result.duration_sec == 0.0
    assert result.logs == []

    # Test validation: empty name should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name="", ok=True, data={})

    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name="", ok=False, data={"x": 1})

    # Test validation: non-string name should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name=123, ok=True, data={})

    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name=None, ok=True, data={})

    # Test validation: non-dict data should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data="not a dict")

    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data=["list", "not", "dict"])

    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data=None)

    # Test with complex data structures
    complex_data = {
        "nested": {"level1": {"level2": "value"}},
        "list_of_dicts": [{"id": 1}, {"id": 2}],
        "numbers": [1, 2, 3],
        "boolean": True,
        "none": None
    }

    result = CommandResult(
        name="complex.command",
        ok=True,
        data=complex_data
    )

    assert result.data == complex_data

    # Test with empty dict data
    result = CommandResult(
        name="empty.data",
        ok=True,
        data={}
    )

    assert result.data == {}

    # Test with various boolean values for ok
    result = CommandResult(name="true.ok", ok=True, data={})
    assert result.ok is True

    result = CommandResult(name="false.ok", ok=False, data={})
    assert result.ok is False

    # Test with float duration
    result = CommandResult(
        name="float.duration",
        ok=True,
        data={},
        duration_sec=0.001
    )

    assert result.duration_sec == 0.001

    # Test with negative duration (edge case)
    result = CommandResult(
        name="negative.duration",
        ok=True,
        data={},
        duration_sec=-1.0
    )

    assert result.duration_sec == -1.0

    # Test logs are properly initialized as list
    result = CommandResult(
        name="with.logs",
        ok=True,
        data={},
        logs=["log1", "log2", "log3"]
    )

    assert isinstance(result.logs, list)
    assert len(result.logs) == 3

    # Test logs default_factory creates empty list
    result = CommandResult(
        name="no.logs",
        ok=True,
        data={}
    )

    assert result.logs == []
    assert isinstance(result.logs, list)

    # Test that logs can be modified after creation
    result = CommandResult(
        name="mutable.logs",
        ok=True,
        data={}
    )

    result.logs.append("new log")
    assert result.logs == ["new log"]

    # Test with very long name
    long_name = "a" * 1000
    result = CommandResult(
        name=long_name,
        ok=True,
        data={}
    )

    assert result.name == long_name

from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from shared.cli_types import CommandResult, WorkflowRun


class TestCommandResult:
    """Mock CommandResult class for testing"""
    def __init__(self, ok=True, duration_sec=1.0):
        self.ok = ok
        self.duration_sec = duration_sec


def test_WorkflowRun():
    """Test WorkflowRun class functionality"""
    # Test initialization
    workflow = WorkflowRun(workflow_name="test.workflow")
    assert workflow.workflow_name == "test.workflow"
    assert workflow.results == []

    # Test ok property with no results
    assert workflow.ok is True

    # Test ok property with all successful results
    result1 = TestCommandResult(ok=True, duration_sec=2.5)
    result2 = TestCommandResult(ok=True, duration_sec=1.5)
    workflow.add(result1)
    workflow.add(result2)
    assert workflow.ok is True

    # Test ok property with mixed results
    result3 = TestCommandResult(ok=False, duration_sec=0.5)
    workflow.add(result3)
    assert workflow.ok is False

    # Test ok property with all failed results
    workflow2 = WorkflowRun(workflow_name="failed.workflow")
    workflow2.add(TestCommandResult(ok=False, duration_sec=1.0))
    workflow2.add(TestCommandResult(ok=False, duration_sec=2.0))
    assert workflow2.ok is False

    # Test total_duration property
    assert workflow.total_duration == pytest.approx(4.5)  # 2.5 + 1.5 + 0.5

    # Test total_duration with zero duration results
    workflow3 = WorkflowRun(workflow_name="zero.duration")
    workflow3.add(TestCommandResult(ok=True, duration_sec=0.0))
    workflow3.add(TestCommandResult(ok=True, duration_sec=0.0))
    assert workflow3.total_duration == 0.0

    # Test total_duration with negative duration (edge case)
    workflow4 = WorkflowRun(workflow_name="negative.duration")
    workflow4.add(TestCommandResult(ok=True, duration_sec=-1.0))
    workflow4.add(TestCommandResult(ok=True, duration_sec=2.0))
    assert workflow4.total_duration == 1.0

    # Test add method with None (edge case)
    workflow5 = WorkflowRun(workflow_name="empty.workflow")
    # This would normally fail with actual CommandResult, but we're testing the add method
    # would accept any object with the expected interface
    mock_result = Mock(spec=['ok', 'duration_sec'])
    mock_result.ok = True
    mock_result.duration_sec = 3.0
    workflow5.add(mock_result)
    assert len(workflow5.results) == 1
    assert workflow5.results[0] == mock_result

    # Test workflow with many results
    workflow6 = WorkflowRun(workflow_name="large.workflow")
    for i in range(100):
        workflow6.add(TestCommandResult(ok=True, duration_sec=0.1))
    assert workflow6.ok is True
    assert workflow6.total_duration == pytest.approx(10.0)

    # Test that results maintain order
    workflow7 = WorkflowRun(workflow_name="ordered.workflow")
    results_in_order = []
    for i in range(5):
        result = TestCommandResult(ok=True, duration_sec=i)
        results_in_order.append(result)
        workflow7.add(result)

    assert workflow7.results == results_in_order
    assert workflow7.results[0].duration_sec == 0
    assert workflow7.results[4].duration_sec == 4

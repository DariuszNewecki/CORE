# Generated by CORE AccumulativeTestService
# Source: src/shared/cli_types.py
# Symbols: 2

from datetime import datetime
from unittest.mock import Mock, patch

import pytest

from shared.cli_types import CommandResult


def test_CommandResult():
    """Test basic functionality, edge cases, and correctness of CommandResult."""

    # Test basic instantiation with required fields
    result = CommandResult(
        name="test.command",
        ok=True,
        data={"count": 5, "items": ["a", "b"]},
        duration_sec=1.5,
        logs=["Starting", "Finished"]
    )

    assert result.name == "test.command"
    assert result.ok is True
    assert result.data == {"count": 5, "items": ["a", "b"]}
    assert result.duration_sec == 1.5
    assert result.logs == ["Starting", "Finished"]

    # Test with minimal required fields
    minimal_result = CommandResult(
        name="minimal.command",
        ok=False,
        data={}
    )

    assert minimal_result.name == "minimal.command"
    assert minimal_result.ok is False
    assert minimal_result.data == {}
    assert minimal_result.duration_sec == 0.0
    assert minimal_result.logs == []

    # Test with default values explicitly
    result_with_defaults = CommandResult(
        name="default.command",
        ok=True,
        data={"key": "value"},
        duration_sec=0.0,
        logs=[]
    )

    assert result_with_defaults.name == "default.command"
    assert result_with_defaults.ok is True
    assert result_with_defaults.data == {"key": "value"}
    assert result_with_defaults.duration_sec == 0.0
    assert result_with_defaults.logs == []

    # Test validation: empty name should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name="", ok=True, data={})

    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name="", ok=False, data={"error": "message"})

    # Test validation: non-string name should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name=123, ok=True, data={})

    with pytest.raises(ValueError, match="CommandResult.name must be non-empty string"):
        CommandResult(name=None, ok=True, data={})

    # Test validation: non-dict data should raise ValueError
    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data="not a dict")

    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data=["list", "not", "dict"])

    with pytest.raises(ValueError, match="CommandResult.data must be a dict"):
        CommandResult(name="test.command", ok=True, data=None)

    # Test with complex nested data
    complex_data = {
        "nested": {"level1": {"level2": "value"}},
        "list_of_dicts": [{"id": 1}, {"id": 2}],
        "boolean": True,
        "number": 42,
        "none_value": None
    }

    complex_result = CommandResult(
        name="complex.command",
        ok=True,
        data=complex_data
    )

    assert complex_result.data == complex_data
    assert complex_result.data["nested"]["level1"]["level2"] == "value"
    assert len(complex_result.data["list_of_dicts"]) == 2

    # Test logs can be modified after creation
    result = CommandResult(name="mutable.command", ok=True, data={})
    result.logs.append("New log message")
    assert result.logs == ["New log message"]

    # Test with float duration
    float_duration_result = CommandResult(
        name="duration.command",
        ok=True,
        data={},
        duration_sec=3.14159
    )

    assert float_duration_result.duration_sec == pytest.approx(3.14159)

    # Test with negative duration (edge case, but allowed by type)
    negative_duration_result = CommandResult(
        name="negative.duration",
        ok=True,
        data={},
        duration_sec=-1.0
    )

    assert negative_duration_result.duration_sec == -1.0

    # Test with very large duration
    large_duration_result = CommandResult(
        name="large.duration",
        ok=True,
        data={},
        duration_sec=999999.999
    )

    assert large_duration_result.duration_sec == 999999.999

    # Test that logs default_factory creates new list each time
    result1 = CommandResult(name="test1", ok=True, data={})
    result2 = CommandResult(name="test2", ok=True, data={})

    result1.logs.append("log for result1")
    assert result2.logs == []  # Should not be affected

    # Test with empty dict data
    empty_dict_result = CommandResult(
        name="empty.dict",
        ok=True,
        data={}
    )

    assert empty_dict_result.data == {}

    # Test with data containing special types (should be allowed)
    special_data_result = CommandResult(
        name="special.data",
        ok=True,
        data={
            "datetime": datetime(2023, 1, 1),
            "exception": ValueError("test"),
            "function": lambda x: x * 2
        }
    )

    assert isinstance(special_data_result.data["datetime"], datetime)
    assert isinstance(special_data_result.data["exception"], ValueError)
    assert callable(special_data_result.data["function"])

from datetime import datetime, timedelta
from unittest.mock import Mock, patch

import pytest

from shared.cli_types import CommandResult, WorkflowRun


class TestCommandResult:
    """Mock CommandResult class for testing"""
    def __init__(self, ok=True, duration_sec=1.0):
        self.ok = ok
        self.duration_sec = duration_sec


def test_WorkflowRun():
    """Test WorkflowRun class functionality"""
    # Test initialization
    workflow = WorkflowRun(workflow_name="test.workflow")
    assert workflow.workflow_name == "test.workflow"
    assert workflow.results == []

    # Test adding results
    result1 = TestCommandResult(ok=True, duration_sec=2.5)
    result2 = TestCommandResult(ok=True, duration_sec=1.5)

    workflow.add(result1)
    assert len(workflow.results) == 1
    assert workflow.results[0] == result1

    workflow.add(result2)
    assert len(workflow.results) == 2
    assert workflow.results[1] == result2

    # Test ok property with all successful results
    assert workflow.ok is True

    # Test ok property with one failed result
    result3 = TestCommandResult(ok=False, duration_sec=0.5)
    workflow.add(result3)
    assert workflow.ok is False

    # Test total_duration property
    assert workflow.total_duration == 4.5  # 2.5 + 1.5 + 0.5

    # Test with empty results
    empty_workflow = WorkflowRun(workflow_name="empty.workflow")
    assert empty_workflow.ok is True  # All of nothing is True
    assert empty_workflow.total_duration == 0.0

    # Test with zero duration results
    zero_duration_result = TestCommandResult(ok=True, duration_sec=0.0)
    zero_workflow = WorkflowRun(workflow_name="zero.workflow")
    zero_workflow.add(zero_duration_result)
    assert zero_workflow.total_duration == 0.0

    # Test with negative duration (edge case)
    negative_result = TestCommandResult(ok=True, duration_sec=-1.0)
    negative_workflow = WorkflowRun(workflow_name="negative.workflow")
    negative_workflow.add(negative_result)
    assert negative_workflow.total_duration == -1.0

    # Test adding multiple results and checking order preservation
    ordered_workflow = WorkflowRun(workflow_name="ordered.workflow")
    results = [TestCommandResult(ok=True, duration_sec=i) for i in range(5)]
    for result in results:
        ordered_workflow.add(result)

    for i, result in enumerate(ordered_workflow.results):
        assert result.duration_sec == i

    # Test workflow with mixed success/failure
    mixed_workflow = WorkflowRun(workflow_name="mixed.workflow")
    mixed_workflow.add(TestCommandResult(ok=True, duration_sec=1.0))
    mixed_workflow.add(TestCommandResult(ok=False, duration_sec=2.0))
    mixed_workflow.add(TestCommandResult(ok=True, duration_sec=3.0))
    assert mixed_workflow.ok is False
    assert mixed_workflow.total_duration == 6.0

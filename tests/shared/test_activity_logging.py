# Generated by CORE AccumulativeTestService
# Source: src/shared/activity_logging.py
# Symbols: 2

import uuid
from unittest.mock import Mock, patch

import pytest

from shared.activity_logging import new_activity_run


def test_new_activity_run():
    """Test that new_activity_run creates an ActivityRun with correct workflow_id and generated run_id."""
    # Test basic functionality
    test_workflow_id = "test_workflow_123"

    # Mock uuid4 to return a predictable value
    mock_uuid = uuid.UUID('12345678-1234-5678-1234-567812345678')
    with patch('uuid.uuid4', return_value=mock_uuid):
        result = new_activity_run(test_workflow_id)

    # Verify the ActivityRun was created with correct parameters
    assert result.workflow_id == test_workflow_id
    assert result.run_id == str(mock_uuid)

    # Test that run_id is actually a UUID string
    try:
        uuid.UUID(result.run_id)
    except ValueError:
        pytest.fail(f"run_id {result.run_id} is not a valid UUID")

    # Test with different workflow IDs
    workflow_ids = ["", "short", "very_long_workflow_id_with_special_chars_123!@#"]
    for wf_id in workflow_ids:
        with patch('uuid.uuid4', return_value=mock_uuid):
            result = new_activity_run(wf_id)
        assert result.workflow_id == wf_id
        assert result.run_id == str(mock_uuid)

    # Verify uuid.uuid4 is called exactly once per invocation
    with patch('uuid.uuid4') as mock_uuid_func:
        mock_uuid_func.return_value = mock_uuid
        new_activity_run(test_workflow_id)
        mock_uuid_func.assert_called_once()

import time
from contextlib import contextmanager
from unittest.mock import ANY, Mock, call, patch

import pytest

from shared.activity_logging import activity_run


def test_activity_run():
    """Test the activity_run context manager for normal and exceptional flows."""

    # Mock dependencies
    with patch("shared.activity_logging.new_activity_run") as mock_new_activity_run, \
         patch("shared.activity_logging.log_activity") as mock_log_activity, \
         patch("shared.activity_logging._current_run_id") as mock_current_run_id, \
         patch("shared.activity_logging.time.time") as mock_time:

        # Setup mocks
        mock_run = Mock()
        mock_run.run_id = "test-run-id-123"
        mock_new_activity_run.return_value = mock_run

        mock_token = Mock()
        mock_current_run_id.set.return_value = mock_token

        # Simulate time progression
        mock_time.side_effect = [1000.0, 1005.5]  # start, end

        # Test 1: Normal successful execution
        workflow_id = "test.workflow"
        test_details = {"param1": "value1", "param2": 42}

        with activity_run(workflow_id, details=test_details) as run:
            # Verify the yielded run object
            assert run is mock_run

            # Verify context var was set
            mock_current_run_id.set.assert_called_once_with("test-run-id-123")

            # Verify start was logged
            mock_log_activity.assert_called_once_with(
                mock_run,
                event="workflow_start",
                status="start",
                message=f"Workflow {workflow_id} started",
                details=test_details,
            )

            # Simulate some activity inside the context
            mock_log_activity.reset_mock()

        # Verify completion was logged
        assert mock_log_activity.call_count == 1
        mock_log_activity.assert_called_with(
            mock_run,
            event="workflow_complete",
            status="ok",
            message=f"Workflow {workflow_id} completed successfully",
            details={"duration_sec": 5.5},
        )

        # Verify context var was reset
        mock_current_run_id.reset.assert_called_once_with(mock_token)

        # Reset mocks for next test
        mock_new_activity_run.reset_mock()
        mock_log_activity.reset_mock()
        mock_current_run_id.reset_mock()
        mock_time.reset_mock()
        mock_current_run_id.set.reset_mock()
        mock_current_run_id.reset.reset_mock()

        # Test 2: Exception during execution
        mock_time.side_effect = [2000.0, 2002.25]  # start, error time
        mock_token2 = Mock()
        mock_current_run_id.set.return_value = mock_token2

        mock_run2 = Mock()
        mock_run2.run_id = "test-run-id-456"
        mock_new_activity_run.return_value = mock_run2

        workflow_id2 = "failing.workflow"
        exception_msg = "Something went wrong"

        with pytest.raises(RuntimeError, match=exception_msg):
            with activity_run(workflow_id2) as run2:
                assert run2 is mock_run2
                mock_current_run_id.set.assert_called_once_with("test-run-id-456")

                # Verify start logging
                mock_log_activity.assert_called_once_with(
                    mock_run2,
                    event="workflow_start",
                    status="start",
                    message=f"Workflow {workflow_id2} started",
                    details=None,
                )

                # Raise an exception inside the context
                raise RuntimeError(exception_msg)

        # Verify error was logged
        assert mock_log_activity.call_count == 2  # start + error

        # Check error log call
        error_call = mock_log_activity.call_args_list[1]
        assert error_call[0][0] is mock_run2
        assert error_call[1]["event"] == "workflow_error"
        assert error_call[1]["status"] == "error"
        assert f"Workflow {workflow_id2} failed: {exception_msg}" in error_call[1]["message"]
        assert error_call[1]["details"] == {"duration_sec": 2.25}

        # Verify context var was reset even after exception
        mock_current_run_id.reset.assert_called_once_with(mock_token2)

        # Reset mocks for next test
        mock_new_activity_run.reset_mock()
        mock_log_activity.reset_mock()
        mock_current_run_id.reset_mock()
        mock_time.reset_mock()
        mock_current_run_id.set.reset_mock()
        mock_current_run_id.reset.reset_mock()

        # Test 3: No details provided
        mock_time.side_effect = [3000.0, 3001.0]
        mock_token3 = Mock()
        mock_current_run_id.set.return_value = mock_token3

        mock_run3 = Mock()
        mock_run3.run_id = "test-run-id-789"
        mock_new_activity_run.return_value = mock_run3

        workflow_id3 = "simple.workflow"

        with activity_run(workflow_id3) as run3:
            assert run3 is mock_run3
            mock_current_run_id.set.assert_called_once_with("test-run-id-789")

            # Verify start logging with None details
            mock_log_activity.assert_called_once_with(
                mock_run3,
                event="workflow_start",
                status="start",
                message=f"Workflow {workflow_id3} started",
                details=None,
            )

        # Verify completion logging
        assert mock_log_activity.call_count == 2
        completion_call = mock_log_activity.call_args_list[1]
        assert completion_call[1]["event"] == "workflow_complete"
        assert completion_call[1]["details"] == {"duration_sec": 1.0}

        # Verify context var reset
        mock_current_run_id.reset.assert_called_once_with(mock_token3)

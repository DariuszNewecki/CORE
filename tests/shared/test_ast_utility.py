# Generated by CORE AccumulativeTestService
# Source: src/shared/ast_utility.py
# Symbols: 3

import ast
from unittest.mock import Mock

from shared.ast_utility import find_definition_line


def test_find_definition_line():
    """Test find_definition_line function with various scenarios."""

    # Test 1: Function without decorators
    source_lines = ["def my_function():", "    pass"]
    node = ast.FunctionDef(name="my_function", lineno=1, decorator_list=[])
    assert find_definition_line(node, source_lines) == 1

    # Test 2: Class without decorators
    source_lines = ["class MyClass:", "    pass"]
    node = ast.ClassDef(name="MyClass", lineno=1, decorator_list=[])
    assert find_definition_line(node, source_lines) == 1

    # Test 3: Function with single decorator
    source_lines = ["@decorator", "def my_function():", "    pass"]
    decorator_node = Mock(lineno=1, end_lineno=1)
    node = ast.FunctionDef(
        name="my_function", lineno=2, decorator_list=[decorator_node]
    )
    assert find_definition_line(node, source_lines) == 2

    # Test 4: Function with multiple decorators
    source_lines = ["@decorator1", "@decorator2", "def my_function():", "    pass"]
    decorator1 = Mock(lineno=1, end_lineno=1)
    decorator2 = Mock(lineno=2, end_lineno=2)
    node = ast.FunctionDef(
        name="my_function", lineno=3, decorator_list=[decorator1, decorator2]
    )
    assert find_definition_line(node, source_lines) == 3

    # Test 5: Async function with decorators
    source_lines = ["@decorator", "async def my_async_function():", "    pass"]
    decorator_node = Mock(lineno=1, end_lineno=1)
    node = ast.AsyncFunctionDef(
        name="my_async_function", lineno=2, decorator_list=[decorator_node]
    )
    assert find_definition_line(node, source_lines) == 2

    # Test 6: Class with decorators
    source_lines = ["@dataclass", "class MyClass:", "    field: int"]
    decorator_node = Mock(lineno=1, end_lineno=1)
    node = ast.ClassDef(name="MyClass", lineno=2, decorator_list=[decorator_node])
    assert find_definition_line(node, source_lines) == 2

    # Test 7: Decorator with end_lineno (multi-line decorator)
    source_lines = [
        "@decorator(",
        "    arg1, arg2",
        ")",
        "def my_function():",
        "    pass",
    ]
    decorator_node = Mock(lineno=1, end_lineno=3)
    node = ast.FunctionDef(
        name="my_function", lineno=4, decorator_list=[decorator_node]
    )
    assert find_definition_line(node, source_lines) == 4

    # Test 8: Function with decorator but definition not found (fallback)
    source_lines = [
        "@decorator",
        "# Some comment",
        "# Another comment",
        "def other_function():",
        "    pass",
    ]
    decorator_node = Mock(lineno=1, end_lineno=1)
    node = ast.FunctionDef(
        name="my_function",
        lineno=5,  # Wrong line number
        decorator_list=[decorator_node],
    )
    # Should fall back to node.lineno since "def my_function" not found
    assert find_definition_line(node, source_lines) == 5

    # Test 9: Function with decorator and whitespace variations
    source_lines = ["    @decorator", "", "    def my_function():", "        pass"]
    decorator_node = Mock(lineno=1, end_lineno=1)
    node = ast.FunctionDef(
        name="my_function", lineno=3, decorator_list=[decorator_node]
    )
    assert find_definition_line(node, source_lines) == 3

    # Test 10: Multiple decorators with end_lineno None (uses lineno)
    source_lines = ["@decorator1", "@decorator2", "def my_function():", "    pass"]
    decorator1 = Mock(lineno=1, end_lineno=None)
    decorator2 = Mock(lineno=2, end_lineno=None)
    node = ast.FunctionDef(
        name="my_function", lineno=3, decorator_list=[decorator1, decorator2]
    )
    # Should use lineno when end_lineno is None
    assert find_definition_line(node, source_lines) == 3

    # Test 11: Empty source lines
    source_lines = []
    node = ast.FunctionDef(name="my_function", lineno=1, decorator_list=[])
    assert find_definition_line(node, source_lines) == 1

    # Test 12: Decorator list empty but node has decorators (shouldn't happen but test anyway)
    source_lines = ["@decorator", "def my_function():", "    pass"]
    node = ast.FunctionDef(name="my_function", lineno=2, decorator_list=[])
    assert find_definition_line(node, source_lines) == 2


from shared.ast_utility import extract_base_classes


def test_extract_base_classes():
    """Test extract_base_classes with various AST class definitions."""

    # Test 1: Simple class with no base classes
    node1 = ast.ClassDef(
        name="MyClass", bases=[], keywords=[], body=[], decorator_list=[]
    )
    assert extract_base_classes(node1) == []

    # Test 2: Single simple base class
    node2 = ast.ClassDef(
        name="MyClass",
        bases=[ast.Name(id="BaseClass", ctx=ast.Load())],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node2) == ["BaseClass"]

    # Test 3: Multiple simple base classes
    node3 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Name(id="BaseClass1", ctx=ast.Load()),
            ast.Name(id="BaseClass2", ctx=ast.Load()),
            ast.Name(id="BaseClass3", ctx=ast.Load()),
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node3) == ["BaseClass1", "BaseClass2", "BaseClass3"]

    # Test 4: Dotted attribute base (module.Class)
    node4 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Attribute(
                value=ast.Name(id="module", ctx=ast.Load()),
                attr="BaseClass",
                ctx=ast.Load(),
            )
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node4) == ["module.BaseClass"]

    # Test 5: Nested dotted attribute (module.submodule.Class)
    node5 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Attribute(
                value=ast.Attribute(
                    value=ast.Name(id="module", ctx=ast.Load()),
                    attr="submodule",
                    ctx=ast.Load(),
                ),
                attr="BaseClass",
                ctx=ast.Load(),
            )
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node5) == ["submodule.BaseClass"]

    # Test 6: Mixed base types
    node6 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Name(id="BaseClass1", ctx=ast.Load()),
            ast.Attribute(
                value=ast.Name(id="external", ctx=ast.Load()),
                attr="BaseClass2",
                ctx=ast.Load(),
            ),
            ast.Name(id="BaseClass3", ctx=ast.Load()),
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node6) == [
        "BaseClass1",
        "external.BaseClass2",
        "BaseClass3",
    ]

    # Test 7: Deeply nested attribute (more than 2 levels)
    node7 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Attribute(
                value=ast.Attribute(
                    value=ast.Attribute(
                        value=ast.Name(id="a", ctx=ast.Load()), attr="b", ctx=ast.Load()
                    ),
                    attr="c",
                    ctx=ast.Load(),
                ),
                attr="BaseClass",
                ctx=ast.Load(),
            )
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node7) == ["c.BaseClass"]

    # Test 8: Empty class with empty bases list
    node8 = ast.ClassDef(
        name="EmptyClass", bases=[], keywords=[], body=[], decorator_list=[]
    )
    assert extract_base_classes(node8) == []

    # Test 9: Class with only attribute base (no Name in value)
    node9 = ast.ClassDef(
        name="MyClass",
        bases=[
            ast.Attribute(
                value=ast.Attribute(
                    value=ast.Attribute(
                        value=ast.Name(id="x", ctx=ast.Load()), attr="y", ctx=ast.Load()
                    ),
                    attr="z",
                    ctx=ast.Load(),
                ),
                attr="BaseClass",
                ctx=ast.Load(),
            )
        ],
        keywords=[],
        body=[],
        decorator_list=[],
    )
    assert extract_base_classes(node9) == ["z.BaseClass"]


from shared.ast_utility import extract_parameters


def test_extract_parameters():
    """Test extract_parameters with various AST function nodes."""

    # Test basic function with parameters
    func_code = "def my_func(x, y, z): pass"
    func_node = ast.parse(func_code).body[0]
    assert extract_parameters(func_node) == ["x", "y", "z"]

    # Test async function with parameters
    async_func_code = "async def async_func(a, b): pass"
    async_func_node = ast.parse(async_func_code).body[0]
    assert extract_parameters(async_func_node) == ["a", "b"]

    # Test function with no parameters
    no_params_code = "def empty_func(): pass"
    no_params_node = ast.parse(no_params_code).body[0]
    assert extract_parameters(no_params_node) == []

    # Test function with only *args
    args_code = "def args_func(*args): pass"
    args_node = ast.parse(args_code).body[0]
    # Note: *args is represented as 'vararg' not in 'args' list
    assert extract_parameters(args_node) == []

    # Test function with only **kwargs
    kwargs_code = "def kwargs_func(**kwargs): pass"
    kwargs_node = ast.parse(kwargs_code).body[0]
    # Note: **kwargs is represented as 'kwarg' not in 'args' list
    assert extract_parameters(kwargs_node) == []

    # Test function with default arguments
    default_code = "def default_func(x=1, y=2): pass"
    default_node = ast.parse(default_code).body[0]
    assert extract_parameters(default_node) == ["x", "y"]

    # Test function with type annotations
    typed_code = "def typed_func(x: int, y: str) -> bool: pass"
    typed_node = ast.parse(typed_code).body[0]
    assert extract_parameters(typed_node) == ["x", "y"]

    # Test edge case: node without args attribute
    class MockNodeWithoutArgs:
        pass

    mock_node = MockNodeWithoutArgs()
    assert extract_parameters(mock_node) == []

    # Test edge case: node with args set to None
    class MockNodeWithNoneArgs:
        args = None

    mock_none_node = MockNodeWithNoneArgs()
    assert extract_parameters(mock_none_node) == []

    # Test edge case: node with args but no args attribute inside
    class MockNodeWithEmptyArgs:
        args = type("EmptyArgs", (), {})()

    mock_empty_args_node = MockNodeWithEmptyArgs()
    assert extract_parameters(mock_empty_args_node) == []

    # Test edge case: node with args.args as empty list
    class MockNodeWithArgsAttr:
        args = type("Args", (), {"args": []})()

    mock_args_node = MockNodeWithArgsAttr()
    assert extract_parameters(mock_args_node) == []

    # Test with actual args structure
    class MockArg:
        def __init__(self, name):
            self.arg = name

    class MockArgs:
        def __init__(self, arg_names):
            self.args = [MockArg(name) for name in arg_names]

    class MockFunctionNode:
        def __init__(self, arg_names):
            self.args = MockArgs(arg_names)

    mock_func = MockFunctionNode(["param1", "param2", "param3"])
    assert extract_parameters(mock_func) == ["param1", "param2", "param3"]

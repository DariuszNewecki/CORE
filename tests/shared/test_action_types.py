# Generated by CORE AccumulativeTestService
# Source: src/shared/action_types.py
# Symbols: 1

import json
import sys
from dataclasses import field
from typing import Any
from unittest.mock import Mock, patch

import pytest

from shared.action_types import ActionResult


def test_ActionResult():
    """Test the ActionResult dataclass for basic functionality, edge cases, and correctness."""

    # Test 1: Basic successful action result
    result = ActionResult(
        action_id="check.imports",
        ok=True,
        data={"violations_count": 0, "files_scanned": 10},
        duration_sec=1.5,
        warnings=["Using fallback parser"],
        suggestions=["Run 'fix.imports' to auto-fix any future violations"]
    )

    assert result.action_id == "check.imports"
    assert result.ok is True
    assert result.data == {"violations_count": 0, "files_scanned": 10}
    assert result.duration_sec == 1.5
    assert result.warnings == ["Using fallback parser"]
    assert result.suggestions == ["Run 'fix.imports' to auto-fix any future violations"]
    assert result.logs == []  # Default value
    assert result.impact is None  # Default value

    # Test 2: Backwards compatibility - name property
    assert result.name == "check.imports"

    # Test 3: Failed action result
    result2 = ActionResult(
        action_id="fix.ids",
        ok=False,
        data={"items_fixed": 3, "items_failed": 2, "dry_run": False},
        warnings=["Failed to fix item #5 due to syntax error"],
        suggestions=["Check syntax at line 42", "Run validation first"]
    )

    assert result2.action_id == "fix.ids"
    assert result2.ok is False
    assert result2.data["items_failed"] == 2

    # Test 4: Validation - empty action_id raises ValueError
    with pytest.raises(ValueError, match="action_id must be non-empty string"):
        ActionResult(action_id="", ok=True, data={})

    # Test 5: Validation - non-string action_id raises ValueError
    with pytest.raises(ValueError, match="action_id must be non-empty string"):
        ActionResult(action_id=123, ok=True, data={})

    # Test 6: Validation - non-dict data raises ValueError
    with pytest.raises(ValueError, match="data must be a dict"):
        ActionResult(action_id="test.action", ok=True, data="not a dict")

    # Test 7: Validation - non-boolean ok raises ValueError
    with pytest.raises(ValueError, match="ok must be a boolean"):
        ActionResult(action_id="test.action", ok="yes", data={})

    # Test 8: Data size limit enforcement
    # Create data that exceeds 5MB limit when serialized
    large_data = {"large_list": ["x" * 1000] * 6000}  # ~6MB when serialized

    with pytest.raises(ValueError, match="ActionResult.data exceeds size limit"):
        ActionResult(action_id="test.action", ok=True, data=large_data)

    # Test 9: Data with non-serializable content (should not crash)
    class NonSerializable:
        pass

    # This should not raise an error due to the try-except in __post_init__
    result3 = ActionResult(
        action_id="test.action",
        ok=True,
        data={"obj": NonSerializable(), "normal": "value"}
    )

    assert result3.action_id == "test.action"
    assert result3.ok is True

    # Test 10: Default values work correctly
    result4 = ActionResult(
        action_id="generate.docs",
        ok=True,
        data={"files_created": ["README.md"]}
    )

    assert result4.duration_sec == 0.0
    assert result4.logs == []
    assert result4.warnings == []
    assert result4.suggestions == []
    assert result4.impact is None

    # Test 11: Field default_factory creates new lists
    result5 = ActionResult(
        action_id="test.action",
        ok=True,
        data={}
    )

    result6 = ActionResult(
        action_id="test.action2",
        ok=True,
        data={}
    )

    # Verify they have separate list instances
    result5.warnings.append("warning1")
    result6.warnings.append("warning2")

    assert result5.warnings == ["warning1"]
    assert result6.warnings == ["warning2"]

    # Test 12: Valid data within size limit
    small_data = {"count": 1000, "items": list(range(1000))}
    result7 = ActionResult(
        action_id="sync.data",
        ok=True,
        data=small_data
    )

    assert result7.action_id == "sync.data"
    assert result7.data == small_data

    # Test 13: Action with impact field
    # Note: We don't test the actual ActionImpact enum since it's not provided
    # but we can test that the field accepts None
    result8 = ActionResult(
        action_id="check.security",
        ok=True,
        data={"scanned": 50},
        impact=None
    )

    assert result8.impact is None

    # Test 14: Complex nested data structure
    complex_data = {
        "violations": [
            {"file": "src/main.py", "line": 42, "rule": "E501"},
            {"file": "src/utils.py", "line": 15, "rule": "F401"}
        ],
        "summary": {
            "total": 2,
            "by_rule": {"E501": 1, "F401": 1}
        }
    }

    result9 = ActionResult(
        action_id="check.lint",
        ok=False,
        data=complex_data
    )

    assert result9.action_id == "check.lint"
    assert result9.ok is False
    assert len(result9.data["violations"]) == 2
    assert result9.data["summary"]["total"] == 2

# tests/body/cli/logic/test_logic_cli_utils.py
# Auto-generated tests for src/body/cli/logic/cli_utils.py
# Generated by CORE SimpleTestGenerator
# Coverage: 3 symbols

from __future__ import annotations

from unittest.mock import MagicMock, patch

import pytest


# --------------------------------------------------------------------------- #
# EXPLICIT + SAFE IMPORT
# --------------------------------------------------------------------------- #
try:
    from body.cli.logic.cli_utils import (
        archive_rollback_plan,
        load_private_key,
        should_fail,
    )

    _CLI_UTILS_AVAILABLE = True
except ImportError:  # pragma: no cover
    archive_rollback_plan = load_private_key = should_fail = None
    _CLI_UTILS_AVAILABLE = False


# --------------------------------------------------------------------------- #
# All tests are skipped when the module cannot be imported
# --------------------------------------------------------------------------- #
@pytest.mark.skipif(not _CLI_UTILS_AVAILABLE, reason="cli_utils module not available")
def test_load_private_key():
    """Test that load_private_key reads a PEM file and deserialises it."""
    if not _CLI_UTILS_AVAILABLE:
        pytest.skip("cli_utils module not available")

    with (
        patch("body.cli.logic.cli_utils.settings") as mock_settings,
        patch("body.cli.logic.cli_utils.serialization") as mock_serialization,
    ):
        mock_key_path = MagicMock()
        mock_key_path.exists.return_value = True
        mock_key_path.read_bytes.return_value = b"fake_key_data"
        mock_settings.KEY_STORAGE_DIR.__truediv__.return_value = mock_key_path

        mock_private_key = MagicMock()
        mock_serialization.load_pem_private_key.return_value = mock_private_key

        result = load_private_key()

        assert result == mock_private_key


@pytest.mark.skipif(not _CLI_UTILS_AVAILABLE, reason="cli_utils module not available")
def test_archive_rollback_plan():
    """Test that archive_rollback_plan creates the directory and writes JSON."""
    if not _CLI_UTILS_AVAILABLE:
        pytest.skip("cli_utils module not available")

    with (
        patch("body.cli.logic.cli_utils.settings") as mock_settings,
        patch("body.cli.logic.cli_utils.json.dumps") as mock_dumps,
        patch("body.cli.logic.cli_utils.datetime") as mock_datetime,
    ):
        # Directory creation chain
        mock_mind = mock_settings.MIND
        mock_mind.__truediv__.return_value.__truediv__.return_value.mkdir.return_value = (
            None
        )
        mock_mind.__truediv__.return_value.__truediv__.return_value.__truediv__.return_value.write_text.return_value = (
            None
        )

        mock_datetime.utcnow.return_value.strftime.return_value = "20231201120000"
        mock_dumps.return_value = '{"test": "data"}'

        proposal = {
            "rollback_plan": {"steps": ["undo"]},
            "target_path": "/some/path",
            "justification": "test reason",
        }

        archive_rollback_plan("test_proposal", proposal)

        # Verify directory was created
        assert mock_mind.__truediv__.return_value.__truediv__.return_value.mkdir.called


@pytest.mark.skipif(not _CLI_UTILS_AVAILABLE, reason="cli_utils module not available")
def test_should_fail():
    """Test the should_fail helper for various failure conditions."""
    if not _CLI_UTILS_AVAILABLE:
        pytest.skip("cli_utils module not available")

    # missing_in_code
    assert should_fail({"missing_in_code": ["table1"]}, "missing") is True

    # undeclared_in_manifest
    assert should_fail({"undeclared_in_manifest": ["table2"]}, "undeclared") is True

    # no issues
    assert should_fail({}, "any") is False

    # mismatched_mappings
    assert should_fail({"mismatched_mappings": ["table3"]}, "any") is True

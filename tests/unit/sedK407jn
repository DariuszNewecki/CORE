# tests/unit/test_file_handler.py
"""
Tests for the FileHandler - CORE's safe file I/O layer.
"""

import pytest
from pathlib import Path
import json

from core.file_handler import FileHandler


@pytest.fixture
def temp_repo(tmp_path):
    """Create a temporary repository directory."""
    repo = tmp_path / "test_repo"
    repo.mkdir()
    return repo


@pytest.fixture
def file_handler(temp_repo):
    """Create a FileHandler instance."""
    return FileHandler(str(temp_repo))


def test_file_handler_initialization(temp_repo):
    """Tests that FileHandler initializes correctly."""
    handler = FileHandler(str(temp_repo))

    assert handler.repo_path == temp_repo
    assert handler.log_dir == temp_repo / "logs"
    assert handler.pending_dir == temp_repo / "pending_writes"
    assert handler.log_dir.exists()
    assert handler.pending_dir.exists()


def test_file_handler_rejects_invalid_path():
    """Tests that FileHandler raises error for invalid repo path."""
    with pytest.raises(ValueError, match="Invalid repository path"):
        FileHandler("/nonexistent/path/to/repo")


def test_add_pending_write_creates_entry(file_handler, temp_repo):
    """Tests that add_pending_write stages a write operation."""
    pending_id = file_handler.add_pending_write(
        prompt="Test write",
        suggested_path="test.py",
        code="print('hello')"
    )

    # Verify ID was returned
    assert pending_id is not None
    assert isinstance(pending_id, str)

    # Verify in-memory storage
    assert pending_id in file_handler.pending_writes
    entry = file_handler.pending_writes[pending_id]
    assert entry["prompt"] == "Test write"
    assert entry["path"] == "test.py"
    assert entry["code"] == "print('hello')"

    # Verify file was created
    pending_file = file_handler.pending_dir / f"{pending_id}.json"
    assert pending_file.exists()

    # Verify file content
    file_data = json.loads(pending_file.read_text())
    assert file_data["prompt"] == "Test write"
    assert file_data["path"] == "test.py"


def test_confirm_write_creates_file(file_handler, temp_repo):
    """Tests that confirm_write creates the actual file."""
    # Stage a write
    pending_id = file_handler.add_pending_write(
        prompt="Create test file",
        suggested_path="src/test.py",
        code="def test():\n    pass"
    )

    # Confirm the write
    result = file_handler.confirm_write(pending_id)

    # Verify success
    assert result["status"] == "success"
    assert "test.py" in result["message"]

    # Verify file was created
    target_file = temp_repo / "src" / "test.py"
    assert target_file.exists()
    assert target_file.read_text() == "def test():\n    pass"

    # Verify pending write was removed
    assert pending_id not in file_handler.pending_writes
    pending_file = file_handler.pending_dir / f"{pending_id}.json"
    assert not pending_file.exists()


def test_confirm_write_creates_parent_directories(file_handler, temp_repo):
    """Tests that confirm_write creates parent directories if needed."""
    pending_id = file_handler.add_pending_write(
        prompt="Create nested file",
        suggested_path="deep/nested/path/file.py",
        code="# test"
    )

    result = file_handler.confirm_write(pending_id)

    assert result["status"] == "success"
    target_file = temp_repo / "deep" / "nested" / "path" / "file.py"
    assert target_file.exists()
    assert target_file.parent.exists()


def test_confirm_write_fails_for_nonexistent_id(file_handler):
    """Tests that confirm_write fails gracefully for invalid ID."""
    result = file_handler.confirm_write("nonexistent-id")

    assert result["status"] == "error"
    assert "not found" in result["message"]


def test_confirm_write_prevents_path_traversal(file_handler, temp_repo):
    """Tests that confirm_write blocks path traversal attacks."""
    pending_id = file_handler.add_pending_write(
        prompt="Malicious write",
        suggested_path="../../etc/passwd",
        code="malicious"
    )

    result = file_handler.confirm_write(pending_id)

    assert result["status"] == "error"
    assert "outside of repository" in result["message"]




def test_multiple_pending_writes(file_handler):
    """Tests that multiple pending writes can be staged simultaneously."""
    id1 = file_handler.add_pending_write("Write 1", "file1.py", "code1")
    id2 = file_handler.add_pending_write("Write 2", "file2.py", "code2")
    id3 = file_handler.add_pending_write("Write 3", "file3.py", "code3")

    assert len(file_handler.pending_writes) == 3
    assert id1 in file_handler.pending_writes
    assert id2 in file_handler.pending_writes
    assert id3 in file_handler.pending_writes


def test_pending_write_includes_timestamp(file_handler):
    """Tests that pending writes include ISO timestamps."""
    pending_id = file_handler.add_pending_write(
        "Test", "test.py", "code"
    )

    entry = file_handler.pending_writes[pending_id]
    assert "timestamp" in entry
    # Verify it's ISO format (will raise if not)
    from datetime import datetime
    datetime.fromisoformat(entry["timestamp"])


def test_pending_write_normalizes_paths(file_handler):
    """Tests that pending writes normalize path separators."""
    pending_id = file_handler.add_pending_write(
        "Test",
        "path\\to\\file.py",  # Windows-style path
        "code"
    )

    entry = file_handler.pending_writes[pending_id]
    # Should be normalized to POSIX style
    assert entry["path"] == "path/to/file.py"


def test_confirm_write_with_existing_file(file_handler, temp_repo):
    """Tests that confirm_write overwrites existing files."""
    # Create an existing file
    target = temp_repo / "existing.py"
    target.write_text("old content")

    # Stage and confirm a write
    pending_id = file_handler.add_pending_write(
        "Overwrite", "existing.py", "new content"
    )
    result = file_handler.confirm_write(pending_id)

    assert result["status"] == "success"
    assert target.read_text() == "new content"


def test_thread_safety_of_pending_writes(file_handler):
    """Tests that pending write operations are thread-safe."""
    import threading

    results = []

    def add_write(index):
        pending_id = file_handler.add_pending_write(
            f"Write {index}",
            f"file{index}.py",
            f"code{index}"
        )
        results.append(pending_id)

    # Create multiple threads
    threads = [threading.Thread(target=add_write, args=(i,)) for i in range(10)]

    # Start all threads
    for t in threads:
        t.start()

    # Wait for completion
    for t in threads:
        t.join()

    # All writes should have succeeded
    assert len(results) == 10
    assert len(file_handler.pending_writes) == 10

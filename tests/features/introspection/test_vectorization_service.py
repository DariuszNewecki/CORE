# Auto-generated tests for src/features/introspection/vectorization_service.py
# Generated by CORE SimpleTestGenerator
# Coverage: 1 symbols

from unittest.mock import AsyncMock, MagicMock, patch


# Import from source module
try:
    from features.introspection.vectorization_service import *
except ImportError:
    # Fallback if import fails
    pass


def test_run_vectorize():
    from features.introspection.vectorization_service import run_vectorize

    # Mock context and its services
    mock_context = MagicMock()
    mock_context.cognitive_service = AsyncMock()
    mock_context.qdrant_service = AsyncMock()

    # Mock all dependencies to ensure happy path execution
    with (
        patch(
            "features.introspection.vectorization_service._fetch_all_public_symbols_from_db",
            new_callable=AsyncMock,
        ) as mock_fetch,
        patch(
            "features.introspection.vectorization_service._get_stored_vector_hashes",
            new_callable=AsyncMock,
        ) as mock_hashes,
        patch(
            "features.introspection.vectorization_service._get_source_code"
        ) as mock_source,
        patch(
            "features.introspection.vectorization_service._process_vectorization_task",
            new_callable=AsyncMock,
        ) as mock_process,
        patch(
            "features.introspection.vectorization_service._update_db_after_vectorization",
            new_callable=AsyncMock,
        ),
    ):
        # Setup mock returns for happy path
        mock_fetch.return_value = [
            {"id": 1, "module": "test.module", "symbol_path": "test_function"}
        ]
        mock_hashes.return_value = {}
        mock_source.return_value = "def test_function(): pass"
        mock_process.return_value = 123

        # Execute the function
        import asyncio

        asyncio.run(run_vectorize(mock_context))

        # Verify main flow executed
        mock_fetch.assert_called_once()
        mock_context.qdrant_service.ensure_collection.assert_called_once()

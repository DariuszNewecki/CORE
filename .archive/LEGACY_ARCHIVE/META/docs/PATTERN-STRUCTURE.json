{
  "id": "pattern_structure_standard",
  "version": "2.0.0",
  "title": "Pattern Document Structure Standard",
  "type": "constitutional_standard",
  "status": "active",
  "owners": {
    "accountable": "Architecture Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "pattern.structure",
  "purpose": "Establishes the canonical structure for pattern documents that define reusable architectural templates, behavioral patterns, and implementation guidelines.\nPatterns are descriptive documents that capture proven solutions to recurring problems. They guide implementation but are less prescriptive than policies.\n",
  "scope": {
    "applies_to": [
      ".intent/charter/standards/architecture/**/*.json",
      "Any document of type: pattern_*"
    ],
    "examples": [
      "agent_patterns.json - AI agent design patterns",
      "workflow_patterns.json - Common workflow structures",
      "service_patterns.json - Service architecture templates",
      "command_patterns.json - CLI command structures"
    ]
  },
  "pattern_vs_policy": {
    "description": "Key differences between patterns and policies",
    "patterns": {
      "nature": "Descriptive - templates and examples",
      "purpose": "Show how to implement well",
      "tone": "Guidance and recommendations",
      "enforcement": "Optional - followed by choice",
      "examples": [
        "Agent should follow request \u2192 plan \u2192 execute flow",
        "Services can use dependency injection for flexibility",
        "Commands may validate inputs before execution"
      ]
    },
    "policies": {
      "nature": "Prescriptive - rules and requirements",
      "purpose": "Enforce what must be done",
      "tone": "Requirements and constraints",
      "enforcement": "Mandatory - checked by auditors",
      "examples": [
        "Agents MUST NOT write to .intent/charter/**",
        "Services MUST receive dependencies through constructor",
        "Commands MUST validate dangerous operations"
      ]
    },
    "overlap": {
      "description": "Patterns may include enforceable rules",
      "guidance": "When a pattern includes rules that MUST be followed, those rules should be extracted into the rules array and enforced like policies.\nUse patterns for templates, use rules for enforcement.\n"
    }
  },
  "canonical_structure": {
    "description": "Pattern documents follow a similar header to policies but focus on templates, examples, and implementation guidance.\n",
    "required_sections": {
      "header": {
        "description": "Standard document header (per GLOBAL-DOCUMENT-META-SCHEMA)",
        "required_fields": [
          "id",
          "version",
          "title",
          "type",
          "status",
          "owners",
          "review",
          "schema_id"
        ],
        "notes": [
          "type SHOULD start with 'pattern_' (e.g. pattern_agent, pattern_workflow)",
          "schema_id MUST be 'rules.structure' if document contains enforceable rules",
          "schema_id MAY be 'pattern.structure' if purely descriptive"
        ]
      },
      "intent": {
        "type": "string",
        "description": "What problem does this pattern solve?",
        "max_length": 500,
        "required": true,
        "example": "Establishes consistent agent behavior patterns to ensure predictable, auditable, and safe autonomous operations.\n"
      },
      "context": {
        "type": "string",
        "description": "When should this pattern be used?",
        "max_length": 1000,
        "required": true,
        "example": "Use when implementing AI agents that need to balance autonomy with safety constraints and human oversight.\n"
      },
      "patterns": {
        "type": "array",
        "description": "The actual pattern definitions",
        "required": true,
        "item_schema": {
          "required_fields": [
            "id",
            "name",
            "description",
            "structure"
          ],
          "optional_fields": [
            "applicability",
            "examples",
            "anti_patterns",
            "related_patterns",
            "implementation_notes"
          ]
        }
      }
    },
    "optional_sections": {
      "rules": {
        "type": "array",
        "description": "Enforceable rules extracted from patterns (follows RULES-STRUCTURE.json)",
        "required": false,
        "when_to_include": [
          "Pattern includes MUST/SHALL requirements",
          "Pattern violations would compromise system integrity",
          "Pattern defines safety-critical constraints"
        ],
        "example": "{\n  \"rules\": [\n    {\n      \"id\": \"agent.must_use_registry\",\n      \"category\": \"agent_governance\",\n      \"statement\": \"Agents MUST route all tool calls through CLI registry\",\n      \"enforcement\": \"error\"\n    }\n  ]\n}\n"
      },
      "consequences": {
        "type": "object",
        "description": "Trade-offs and implications of using this pattern",
        "fields": {
          "benefits": {
            "type": "array",
            "items": "string"
          },
          "drawbacks": {
            "type": "array",
            "items": "string"
          },
          "performance_impact": "string"
        }
      },
      "related_documents": {
        "type": "object",
        "description": "Links to related policies, patterns, or schemas"
      }
    }
  },
  "pattern_categories": {
    "architectural": {
      "description": "High-level system structure patterns",
      "examples": [
        "service_patterns.json - Service design templates",
        "layer_contracts.json - Layer separation patterns",
        "dependency_injection.json - DI patterns"
      ],
      "common_pattern_types": [
        "Service architecture",
        "Module organization",
        "Dependency management",
        "Interface design"
      ]
    },
    "behavioral": {
      "description": "Runtime behavior and interaction patterns",
      "examples": [
        "agent_patterns.json - Agent behavior templates",
        "workflow_patterns.json - Workflow structures",
        "command_patterns.json - CLI command patterns"
      ],
      "common_pattern_types": [
        "Request/response flows",
        "State management",
        "Error handling",
        "Event processing"
      ]
    },
    "implementation": {
      "description": "Code-level implementation patterns",
      "examples": [
        "atomic_actions.json - Atomic operation patterns",
        "decorator_governance.json - Decorator usage"
      ],
      "common_pattern_types": [
        "Function composition",
        "Error handling",
        "Resource management",
        "Concurrency patterns"
      ]
    }
  },
  "examples": {
    "descriptive_pattern": {
      "description": "Pattern without enforceable rules (purely guidance)",
      "content": "{\n  \"id\": \"workflow_basic_pattern\",\n  \"version\": \"1.0.0\",\n  \"title\": \"Basic Workflow Pattern\",\n  \"type\": \"pattern_workflow\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"Architecture Lead\"\n  },\n  \"review\": {\n    \"frequency\": \"12 months\"\n  },\n  \"schema_id\": \"pattern.structure\",\n  \"intent\": \"Provides a basic template for implementing workflows with clear phases and error handling.\",\n  \"context\": \"Use when building multi-step processes that need consistent structure and error recovery.\",\n  \"patterns\": [\n    {\n      \"id\": \"basic_workflow\",\n      \"name\": \"Three-Phase Workflow\",\n      \"description\": \"Separate workflows into prepare, execute, and finalize phases with explicit error boundaries.\",\n      \"structure\": \"def workflow():\\n    try:\\n        # Phase 1: Prepare\\n        context = prepare()\\n\\n        # Phase 2: Execute\\n        result = execute(context)\\n\\n        # Phase 3: Finalize\\n        return finalize(result)\\n\\n    except Exception as e:\\n        cleanup()\\n        raise\\n\",\n      \"applicability\": [\n        \"Multi-step operations\",\n        \"Operations requiring cleanup\",\n        \"Workflows with multiple failure points\"\n      ],\n      \"anti_patterns\": [\n        \"Mixing phases without clear boundaries\",\n        \"Skipping cleanup on errors\",\n        \"Implicit state management\"\n      ]\n    }\n  ],\n  \"consequences\": {\n    \"benefits\": [\n      \"Clear phase separation\",\n      \"Explicit error handling\",\n      \"Easy to test each phase\"\n    ],\n    \"drawbacks\": [\n      \"More boilerplate than inline approach\",\n      \"May be overkill for simple operations\"\n    ]\n  }\n}\n"
    },
    "pattern_with_rules": {
      "description": "Pattern that includes enforceable requirements",
      "content": "{\n  \"id\": \"agent_behavior_patterns\",\n  \"version\": \"2.0.0\",\n  \"title\": \"Agent Behavior Patterns\",\n  \"type\": \"pattern_agent\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"AI Safety Lead\"\n  },\n  \"review\": {\n    \"frequency\": \"6 months\"\n  },\n  \"schema_id\": \"rules.structure\",\n  \"intent\": \"Defines safe and predictable behavior patterns for autonomous agents.\",\n  \"context\": \"Use when implementing agents that need to balance autonomy with safety and human oversight.\",\n  \"patterns\": [\n    {\n      \"id\": \"request_plan_execute\",\n      \"name\": \"Request-Plan-Execute Pattern\",\n      \"description\": \"Agent receives request, creates plan, gets approval, then executes.\",\n      \"structure\": \"async def agent_workflow(request):\\n    # 1. Understand request\\n    intent = analyze_request(request)\\n\\n    # 2. Create plan\\n    plan = create_plan(intent)\\n\\n    # 3. Get approval (if needed)\\n    if requires_approval(plan):\\n        await get_human_approval(plan)\\n\\n    # 4. Execute\\n    result = await execute_plan(plan)\\n\\n    # 5. Report\\n    return create_report(result)\\n\",\n      \"applicability\": [\n        \"All autonomous agent implementations\",\n        \"Operations affecting system state\",\n        \"Tasks requiring human oversight\"\n      ]\n    }\n  ],\n  \"rules\": [\n    {\n      \"id\": \"agent.must_create_plan\",\n      \"category\": \"agent_governance\",\n      \"statement\": \"Agents MUST create an explicit plan before executing any non-trivial operation.\",\n      \"enforcement\": \"error\",\n      \"rationale\": \"Explicit plans enable human review and audit trails.\"\n    },\n    {\n      \"id\": \"agent.must_get_approval\",\n      \"category\": \"agent_governance\",\n      \"statement\": \"Agents MUST obtain approval for elevated-risk operations before execution.\",\n      \"enforcement\": \"error\",\n      \"scope\": [\n        \"elevated_risk\",\n        \"critical_risk\"\n      ]\n    }\n  ]\n}\n"
    }
  },
  "best_practices": {
    "pattern_design": [
      "Focus on one problem per pattern",
      "Provide concrete code examples",
      "Explain when NOT to use the pattern",
      "Link to related patterns",
      "Show both structure and implementation"
    ],
    "extracting_rules": [
      "If pattern says MUST/SHALL \u2192 extract to rules array",
      "If pattern says SHOULD/MAY \u2192 keep in pattern description",
      "Safety constraints \u2192 always extract to rules",
      "Performance tips \u2192 keep in consequences"
    ],
    "documentation": [
      "Use real code examples, not pseudocode",
      "Explain the 'why' not just the 'how'",
      "Document trade-offs explicitly",
      "Keep examples focused and minimal"
    ]
  },
  "migration_notes": {
    "v1_to_v2": {
      "description": "Migrating pattern documents to v2.0 structure",
      "key_changes": [
        "Add schema_id field",
        "Extract MUST/SHALL requirements to rules array",
        "Restructure pattern definitions to use consistent schema",
        "Add consequences section for trade-offs"
      ],
      "backward_compatibility": {
        "description": "Patterns without rules array are valid in v2.x. Only patterns with enforceable requirements need rules array.\n"
      }
    }
  },
  "additionalProperties": false
}

{
  "id": "standard_architecture_decorator_governance",
  "version": "1.0.0",
  "title": "Architecture Standard – Decorator Governance",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Architecture Owner",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "schema.policy",
  "policy_id": "decorator_governance",
  "category": "code_generation",
  "layer": "mind",
  "philosophy": "Decorators in CORE serve two purposes:\n\n1. GOVERNANCE CONTRACTS (@core_command, @atomic_action)\n   - Enable constitutional enforcement BEFORE execution\n   - Required for the Will layer to validate safety\n   - These are functional requirements, not pollution\n\n2. FRAMEWORK BINDINGS (@app.command, @pytest.fixture)\n   - Enable framework wiring (Typer, FastAPI, Pytest)\n   - Required for runtime registration\n   - These are infrastructure necessities\n\nThe Database stores WHAT decorators mean (metadata, relationships).\nThe Source stores HOW decorators work (runtime behavior).\n\nFor CORE.NG to autonomously generate correct code, it must know:\n- WHICH decorators are required for each function type\n- WHERE to place them (order matters)\n- WHAT parameters to use\n- WHY they exist (so it can reason about edge cases)\n",
  "whitelisted_decorators": {
    "governance_contracts": [
      {
        "decorator": "@core_command",
        "purpose": "Constitutional wrapper for CLI entry points",
        "required_for": "All CLI command functions",
        "parameters": [
          {
            "name": "dangerous",
            "type": "bool",
            "required": true,
            "values": [
              true,
              false
            ],
            "reasoning": "Declares whether command performs destructive operations.\nUsed by IntentGuard to enforce approval workflows.\n"
          }
        ],
        "metadata_storage": "core.symbol_decorators table (future)"
      },
      {
        "decorator": "@atomic_action",
        "purpose": "Constitutional wrapper for autonomous operations",
        "required_for": "All state-modifying service functions",
        "parameters": [
          {
            "name": "action_id",
            "type": "str",
            "required": true,
            "example": "fix.ids"
          },
          {
            "name": "impact",
            "type": "str",
            "required": true,
            "values": [
              "read-only",
              "write-metadata",
              "write-code",
              "write-data"
            ]
          },
          {
            "name": "policies",
            "type": "list[str]",
            "required": true,
            "example": [
              "naming_conventions",
              "structural_integrity"
            ]
          }
        ],
        "metadata_storage": "core.actions table"
      }
    ],
    "framework_bindings": [
      {
        "decorator": "@app.command",
        "framework": "Typer",
        "purpose": "Register CLI command with Typer framework",
        "required_for": "CLI entry points using Typer"
      },
      {
        "decorator": "@app.get|post|put|delete",
        "framework": "FastAPI",
        "purpose": "Register HTTP endpoint",
        "required_for": "API route handlers"
      },
      {
        "decorator": "@pytest.fixture",
        "framework": "Pytest",
        "purpose": "Register test fixture",
        "required_for": "Test helper functions"
      },
      {
        "decorator": "@dataclass",
        "framework": "Python stdlib",
        "purpose": "Generate dataclass methods",
        "required_for": "Data container classes"
      }
    ]
  },
  "rules": [
    {
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "decorator_governance.auto_rule_0",
      "enforcement": "error",
      "statement": "All CLI command functions MUST use @core_command decorator",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: All CLI command functions MUST use @core_command decorator"
        }
      },
      "data": {
        "rule_id": "cli_commands_require_core_decorator",
        "applies_to": [
          "Functions under src/body/cli/**/*.py",
          "Functions decorated with @<app>.command()",
          "Functions matching pattern: (run_|execute_|list_|show_|query_)*"
        ],
        "required_decorator": "@core_command(dangerous=<bool>)",
        "detection": {
          "check": "Function is CLI entry point AND lacks @core_command",
          "indicators": [
            "Has @app.command() decorator",
            "Module path contains 'body/cli'",
            "Function name matches CLI verb pattern"
          ]
        },
        "generation": {
          "template": "@core_command(dangerous={is_dangerous})",
          "parameters": {
            "is_dangerous": {
              "determine_by": "semantic analysis of function body",
              "heuristics": [
                "Contains Path.write_text() → dangerous=True",
                "Contains Path.unlink() → dangerous=True",
                "Contains subprocess.run() → dangerous=True",
                "Only reads data → dangerous=False",
                "Only queries database → dangerous=False"
              ],
              "default": false,
              "reasoning": "Conservative default: assume safe unless proven otherwise"
            }
          }
        },
        "fix": {
          "action": "Add @core_command decorator above framework decorator",
          "verification": "Ensure decorator order: @core_command then @app.command()"
        }
      }
    },
    {
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "decorator_governance.auto_rule_1",
      "enforcement": "error",
      "statement": "Decorators MUST appear in constitutional order",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Decorators MUST appear in constitutional order"
        }
      },
      "data": {
        "rule_id": "decorator_ordering",
        "order": {
          "1": "Governance contracts (@core_command, @atomic_action)",
          "2": "Framework bindings (@app.command, @pytest.fixture)",
          "3": "Type hints (@dataclass, @property)"
        },
        "reasoning": "Governance must wrap framework registration to ensure constitutional\nchecks happen BEFORE the framework dispatches execution.\n",
        "violation_example": "# WRONG - framework decorator first\n@app.command()\n@core_command(dangerous=False)\ndef my_command(): ...\n",
        "correct_example": "# CORRECT - governance decorator first\n@core_command(dangerous=False)\n@app.command()\ndef my_command(): ...\n",
        "fix": {
          "action": "Reorder decorators according to constitutional precedence"
        }
      }
    },
    {
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Functions MUST NOT have duplicate decorators"
        }
      },
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "decorator_governance.auto_rule_2",
      "enforcement": "error",
      "statement": "Functions MUST NOT have duplicate decorators",
      "data": {
        "rule_id": "no_duplicate_decorators",
        "fix": {
          "action": "Remove duplicate, keep first occurrence",
          "special_case": "If parameters differ, merge intelligently:\n@core_command(dangerous=True)\n@core_command(dangerous=False)\n→ Keep dangerous=True (more restrictive)\n"
        }
      }
    }
  ],
  "autonomous_generation": {
    "decision_tree": [
      {
        "condition": "Generating CLI command function",
        "actions": {
          "1": "Determine if dangerous (analyze function body)",
          "2": "Apply @core_command(dangerous=<bool>)",
          "3": "Apply @app.command() for framework binding",
          "4": "Verify decorator order"
        }
      },
      {
        "condition": "Generating service method that modifies state",
        "actions": {
          "1": "Determine action_id from function purpose",
          "2": "Determine impact level (write-metadata, write-code, etc)",
          "3": "Identify applicable constitutional policies",
          "4": "Apply @atomic_action(action_id, impact, policies)"
        }
      },
      {
        "condition": "Generating read-only service method",
        "actions": {
          "1": "No governance decorator needed",
          "2": "Apply framework decorators only if required"
        }
      },
      {
        "condition": "Generating test fixture",
        "actions": {
          "1": "Apply @pytest.fixture if shared across tests",
          "2": "No governance decorator needed (tests are exempt)"
        }
      }
    ],
    "parameter_inference": {
      "dangerous_parameter": {
        "analyze": [
          "Parse function AST",
          "Check for file writes (Path.write_text, open with 'w')",
          "Check for deletions (Path.unlink, os.remove)",
          "Check for shell commands (subprocess, os.system)",
          "Check for database writes (INSERT, UPDATE, DELETE)"
        ],
        "conservative_default": false,
        "reasoning": "When in doubt, mark as safe (dangerous=False) and let constitutional\naudits catch cases where human approval should be required.\n"
      },
      "action_id_parameter": {
        "pattern": "<verb>.<noun>",
        "examples": [
          "fix.ids",
          "check.imports",
          "sync.vectors"
        ],
        "generation": {
          "verb": "Infer from function name (fix_, check_, sync_, etc)",
          "noun": "Infer from function purpose"
        }
      },
      "impact_parameter": {
        "determine_by": "AST analysis of function body",
        "mapping": [
          "No writes → read-only",
          "Writes comments/IDs → write-metadata",
          "Modifies code structure → write-code",
          "Database operations → write-data"
        ]
      }
    }
  },
  "storage_strategy": {
    "current_state": {
      "location": "Source files (.py)",
      "reason": "Python requires decorators at runtime for framework registration"
    },
    "future_state": {
      "metadata_storage": "core.symbol_decorators table will store:\n- Which decorators a symbol requires\n- What parameters to use\n- Why they're needed (constitutional justification)\n",
      "generation_workflow": "1. CORE queries: \"What decorators does symbol X need?\"\n2. DB returns: [@core_command(dangerous=False), @app.command()]\n3. CORE generates source with decorators\n4. Python executes decorated code\n",
      "benefit": "CORE can reason about decorator requirements semantically,\nupdate them without touching source, and evolve patterns\nwithout breaking existing code.\n"
    }
  },
  "migration": {
    "phase_1_current": {
      "state": "Decorators in source, policies in .intent/",
      "capability": "CORE can detect violations, suggest fixes",
      "limitation": "Cannot autonomously generate new decorated functions"
    },
    "phase_2_enhanced_policies": {
      "state": "Add this policy to .intent/",
      "capability": "CORE can autonomously generate correct decorators",
      "limitation": "Still requires source modification for changes"
    },
    "phase_3_db_storage": {
      "state": "Add core.symbol_decorators table",
      "capability": "CORE queries DB for decorator requirements",
      "benefit": "Decorator rules updatable without code changes"
    },
    "phase_4_autonomous": {
      "state": "CORE.NG generates all code from DB + intent",
      "capability": "Full autonomous code generation",
      "goal": "Last programmer you'll ever need"
    }
  },
  "enforcement": {
    "audits": [
      {
        "id": "missing_core_command",
        "check": "CLI functions lack @core_command",
        "severity": "error",
        "auto_fix": true,
        "fix_action": "Add @core_command(dangerous=False) decorator"
      },
      {
        "id": "wrong_decorator_order",
        "check": "Framework decorator appears before governance decorator",
        "severity": "error",
        "auto_fix": true,
        "fix_action": "Reorder decorators"
      },
      {
        "id": "unlisted_decorator",
        "check": "Decorator not in whitelist",
        "severity": "warning",
        "auto_fix": false,
        "fix_action": "Manual review required"
      }
    ],
    "constitutional_compliance": {
      "principle": "All decorators must serve constitutional or framework purposes",
      "violation": "Decorators that only store metadata (use DB instead)",
      "exemption": "None - this is foundational to SSOT architecture"
    }
  },
  "examples": {
    "correct_cli_command": "@core_command(dangerous=False)\n@check_app.command(\"audit\")\ndef audit(\n    fix: bool = False,\n    scope: str = \"all\"\n) -> None:\n    \"\"\"Run constitutional compliance audit.\"\"\"\n    # implementation\n",
    "correct_dangerous_command": "@core_command(dangerous=True)\n@admin_app.command(\"reset-db\")\ndef reset_database() -> None:\n    \"\"\"Drop and recreate all tables.\"\"\"\n    # implementation\n",
    "correct_atomic_action": "@atomic_action(\n    action_id=\"fix.ids\",\n    impact=\"write-metadata\",\n    policies=[\"symbol_identification\"]\n)\ndef assign_stable_ids() -> ActionResult:\n    \"\"\"Assign UUIDs to untagged symbols.\"\"\"\n    # implementation\n",
    "wrong_decorator_order": "# VIOLATION: Framework decorator before governance\n@check_app.command(\"audit\")\n@core_command(dangerous=False)\ndef audit() -> None:\n    ...\n",
    "forbidden_metadata_decorator": "# VIOLATION: Metadata belongs in database\n@capability(name=\"audit\", owner=\"team-a\")\n@core_command(dangerous=False)\n@check_app.command(\"audit\")\ndef audit() -> None:\n    ...\n"
  },
  "additionalProperties": false
}

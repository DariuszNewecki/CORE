{
  "id": "standard_code_purity",
  "version": "2.1.0",
  "title": "Code Standard - Purity & Side Effects",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Code Quality Owner",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "schema.policy",
  "policy_id": "73394e37-41db-4391-93e8-6ced1a61735f",
  "purpose": "Define the strict boundary between Code (Logic/Safety) and Database (Metadata/State). Ensures the codebase remains clean, readable, and free of 'Split-Brain' metadata configuration.",
  "core_principle": "Source code is for LOGIC and RUNTIME CONTRACTS. Descriptive metadata (Ownership, Relationships, Status) belongs in the Knowledge Graph (DB).",
  "rules": [
    {
      "id": "purity.forbidden_decorators",
      "statement": "Source code MUST NOT contain descriptive metadata decorators: @capability, @meta, or @owner.",
      "enforcement": "error",
      "rationale": "Database Schema 'core.capabilities' already stores owner, domain, and status. Storing this in code creates a sync hazard (Split-Brain).",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "forbidden_decorators",
          "forbidden": [
            "capability",
            "meta",
            "owner"
          ],
          "remediation": "Use 'core-admin manage database' or 'fix docstrings' to update metadata."
        }
      }
    },
    {
      "id": "purity.no_inline_configuration",
      "statement": "Hardcoding configuration (timeouts, retry limits, API keys) in source code is forbidden.",
      "enforcement": "warn",
      "rationale": "Database Schema 'core.runtime_settings' is the SSOT for config. Hardcoding prevents dynamic runtime adjustment and creates security risks.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "forbidden_assignments",
          "targets": [
            "CONFIG",
            "API_KEY",
            "SECRET_KEY"
          ],
          "remediation": "Load via ConfigService (backed by core.runtime_settings)."
        }
      }
    },
    {
      "id": "purity.stable_id_anchor",
      "statement": "Primary public symbols MUST have a stable ID anchor (# ID: <uuid>) immediately above definition.",
      "enforcement": "error",
      "rationale": "The DB uses UUIDs as primary keys. Refactoring (renaming/moving) breaks links unless a stable anchor is present in source.",
      "scope": {
        "include": [
          "src/**/*.py"
        ],
        "exclude": [
          "**/__init__.py",
          "**/test_*.py",
          "**/*_test.py",
          "tests/**/*.py"
        ]
      },
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "id_anchor"
        }
      }
    },
    {
      "id": "purity.safety_contract_presence",
      "statement": "Public state-modifying functions MUST have an @atomic_action decorator.",
      "enforcement": "warn",
      "rationale": "Required for the 'Will' layer (IntentGuard) to validate safety *before* execution. Defines blast radius and governing policies.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "required_decorator",
          "target": "atomic_action",
          "exclude_patterns": [
            "^get_.*",
            "^list_.*",
            "^find_.*",
            "^search_.*",
            "^query_.*",
            "^fetch_.*",
            "^read_.*",
            "^load_.*",
            "^retrieve_.*",
            "^select_.*",
            "^count_.*",
            "^check_.*",
            "^verify_.*",
            "^validate_.*",
            "^visit_.*",
            "^add_nodes$",
            "^build.*",
            "^create_.*",
            "^make_.*",
            "^start_.*",
            "^run_.*",
            "^execute$",
            "^main$",
            "^handle_.*",
            "^process_.*",
            ".*_cmd$",
            ".*_command$"
          ],
          "exclude_decorators": [
            "core_command",
            "property",
            "cached_property",
            "staticmethod",
            "classmethod",
            "app.callback",
            "app.command"
          ]
        }
      }
    },
    {
      "id": "purity.atomic_action_contract",
      "statement": "The @atomic_action decorator MUST include 'action_id', 'impact', and 'policies'.",
      "enforcement": "error",
      "rationale": "Enables constitutional enforcement BEFORE execution. Without these params, the function is invisible to the governance engine.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "decorator_args",
          "decorator": "atomic_action",
          "required_args": [
            "action_id",
            "impact",
            "policies"
          ]
        }
      }
    },
    {
      "id": "purity.framework_binding_limits",
      "statement": "Decorators are restricted to Governance Contracts or explicit Framework Bindings (FastAPI, Typer, Pytest).",
      "enforcement": "error",
      "rationale": "Prevents 'Decorator Inflation' where the source code becomes cluttered with non-functional metadata.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "forbidden_decorators",
          "allowed": [
            "core_command",
            "atomic_action",
            "app.command",
            "app.callback",
            "router.get",
            "router.post",
            "router.put",
            "router.delete",
            "pytest.fixture",
            "pytest.mark",
            "dataclass",
            "property",
            "cached_property",
            "staticmethod",
            "classmethod",
            "wraps",
            "abstractmethod"
          ]
        }
      }
    },
    {
      "id": "purity.no_ast_duplication",
      "statement": "Code MUST NOT contain structurally identical blocks (AST-level duplication).",
      "enforcement": "warn",
      "rationale": "Copy-pasted code with minor variable name changes creates maintenance burden, violates DRY principle, and indicates missed abstraction opportunities. Structural duplication is detected by comparing Abstract Syntax Trees.",
      "check": {
        "engine": "knowledge_gate",
        "params": {
          "check_type": "ast_duplication",
          "threshold": 0.95
        }
      }
    },
    {
      "id": "purity.no_semantic_duplication",
      "statement": "Code MUST NOT contain semantically equivalent implementations (vector similarity duplication).",
      "enforcement": "warn",
      "rationale": "Functionally duplicate code written differently indicates missed abstraction opportunities and creates hidden maintenance burden. Semantic duplication is detected via vector embeddings of code semantics, catching cases where implementations differ syntactically but perform equivalent operations.",
      "check": {
        "engine": "knowledge_gate",
        "params": {
          "check_type": "semantic_duplication",
          "threshold": 0.85
        }
      }
    }
  ],
  "metadata_strategy": {
    "source_code": {
      "contains": "Logic, Flow Control, Runtime Safety Contracts (@atomic_action)",
      "role": "The Body (Execution)"
    },
    "database": {
      "contains": "Ownership, Capability Definitions, Relationships, Execution History",
      "schema_ref": "001_consolidated_schema.sql",
      "role": "The Mind (Memory & Context)"
    },
    "docstrings": {
      "contains": "Human-readable intent, usage examples, reasoning",
      "role": "Explanation"
    }
  },
  "philosophy": "If the data describes *what* the code is, it lives in the Database. If the data describes *how* the code behaves safely, it lives in the Code (Decorator).",
  "additionalProperties": false
}

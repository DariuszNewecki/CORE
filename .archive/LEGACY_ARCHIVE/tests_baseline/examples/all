# tests/conftest.py
"""
Shared pytest fixtures for all tests.
"""

import pytest
from pathlib import Path
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker

from services.database.session_manager import init_database, close_database
from shared.config import settings


@pytest.fixture(scope="session")
def test_db_url():
    """Return test database URL."""
    return "postgresql+asyncpg://postgres:postgres@localhost:5432/core_test"


@pytest.fixture(autouse=True)
async def setup_test_database(test_db_url):
    """
    Initialize test database before each test.

    This fixture:
    1. Initializes database with NullPool (no connection pooling in tests)
    2. Runs the test
    3. Cleans up connections
    """
    await init_database(database_url=test_db_url, force_null_pool=True)
    yield
    await close_database()


@pytest.fixture
async def db_session():
    """Get a database session for testing."""
    from services.database.session_manager import get_session

    async with get_session() as session:
        yield session


# ============================================================================
# tests/unit/services/test_secrets_service.py
"""
Unit tests for secrets service.
"""

import pytest
from unittest.mock import AsyncMock, MagicMock

from core.secrets_service import SecretsService
from shared.exceptions import SecretNotFoundError, EncryptionError


class TestSecretsService:
    """Test suite for SecretsService."""

    @pytest.fixture
    def mock_repository(self):
        """Create a mock secrets repository."""
        repo = AsyncMock()
        return repo

    @pytest.fixture
    def mock_encryption(self):
        """Create a mock encryption service."""
        encryption = MagicMock()
        encryption.encrypt = MagicMock(return_value="encrypted_value")
        encryption.decrypt = MagicMock(return_value="decrypted_value")
        return encryption

    @pytest.fixture
    def secrets_service(self, mock_repository, mock_encryption):
        """Create a SecretsService with mocked dependencies."""
        return SecretsService(
            repository=mock_repository,
            encryption=mock_encryption,
        )

    @pytest.mark.unit
    async def test_get_secret_success(self, secrets_service, mock_repository):
        """Test retrieving an existing secret."""
        # Arrange
        mock_repository.get.return_value = "encrypted_value"

        # Act
        result = await secrets_service.get_secret("test.key")

        # Assert
        assert result == "decrypted_value"
        mock_repository.get.assert_awaited_once_with("test.key")

    @pytest.mark.unit
    async def test_get_secret_not_found(self, secrets_service, mock_repository):
        """Test retrieving a non-existent secret."""
        # Arrange
        mock_repository.get.return_value = None

        # Act & Assert
        with pytest.raises(SecretNotFoundError) as exc_info:
            await secrets_service.get_secret("missing.key")

        assert exc_info.value.key == "missing.key"

    @pytest.mark.unit
    async def test_set_secret_success(self, secrets_service, mock_repository):
        """Test storing a new secret."""
        # Act
        await secrets_service.set_secret(
            key="new.key",
            value="secret_value",
            description="Test secret"
        )

        # Assert
        mock_repository.set.assert_awaited_once_with(
            key="new.key",
            value="encrypted_value",
            description="Test secret"
        )

    @pytest.mark.unit
    async def test_delete_secret_success(self, secrets_service, mock_repository):
        """Test deleting a secret."""
        # Arrange
        mock_repository.get.return_value = "encrypted_value"

        # Act
        await secrets_service.delete_secret("test.key")

        # Assert
        mock_repository.delete.assert_awaited_once_with("test.key")

    @pytest.mark.unit
    async def test_list_secrets(self, secrets_service, mock_repository):
        """Test listing all secrets."""
        # Arrange
        mock_repository.list_keys.return_value = [
            {"key": "key1", "description": "Secret 1"},
            {"key": "key2", "description": "Secret 2"},
        ]

        # Act
        result = await secrets_service.list_secrets()

        # Assert
        assert len(result) == 2
        assert result[0]["key"] == "key1"


# ============================================================================
# tests/integration/test_secrets_integration.py
"""
Integration tests for secrets management with real database.
"""

import pytest
from cryptography.fernet import Fernet

from core.secrets_service import SecretsService, get_secrets_service
from shared.exceptions import SecretNotFoundError


@pytest.mark.integration
class TestSecretsIntegration:
    """Integration tests with real database."""

    @pytest.fixture
    def master_key(self):
        """Generate a test master key."""
        return Fernet.generate_key().decode()

    @pytest.mark.asyncio
    async def test_full_secret_lifecycle(self, db_session, master_key):
        """Test complete secret lifecycle: set, get, update, delete."""
        # Get service
        service = await get_secrets_service(db_session)

        # 1. Set secret
        await service.set_secret(
            db_session,
            key="test.api_key",
            value="sk-test-123",
            description="Test API key",
            audit_context="test"
        )

        # 2. Get secret
        value = await service.get_secret(
            db_session,
            key="test.api_key",
            audit_context="test"
        )
        assert value == "sk-test-123"

        # 3. List secrets
        secrets = await service.list_secrets(db_session)
        assert len(secrets) >= 1
        assert any(s["key"] == "test.api_key" for s in secrets)

        # 4. Update secret
        await service.set_secret(
            db_session,
            key="test.api_key",
            value="sk-test-456",
            description="Updated API key",
            audit_context="test"
        )

        updated_value = await service.get_secret(
            db_session,
            key="test.api_key",
            audit_context="test"
        )
        assert updated_value == "sk-test-456"

        # 5. Delete secret
        await service.delete_secret(db_session, "test.api_key")

        # 6. Verify deletion
        with pytest.raises(SecretNotFoundError):
            await service.get_secret(
                db_session,
                key="test.api_key",
                audit_context="test"
            )

    @pytest.mark.asyncio
    async def test_encryption_decryption(self, db_session):
        """Test that values are actually encrypted in database."""
        service = await get_secrets_service(db_session)

        # Store a secret
        original_value = "super_secret_value_12345"
        await service.set_secret(
            db_session,
            key="encrypt.test",
            value=original_value,
            audit_context="test"
        )

        # Check raw database value is encrypted (not plain text)
        result = await db_session.execute(
            "SELECT encrypted_value FROM core.runtime_settings WHERE key = 'encrypt.test'"
        )
        encrypted_value = result.scalar()

        # Encrypted value should not match original
        assert encrypted_value != original_value
        assert len(encrypted_value) > len(original_value)

        # But decrypted value should match
        decrypted = await service.get_secret(
            db_session,
            key="encrypt.test",
            audit_context="test"
        )
        assert decrypted == original_value


# ============================================================================
# tests/integration/test_database_session.py
"""
Integration tests for database session management.
"""

import pytest
from sqlalchemy import text

from services.database.session_manager import (
    init_database,
    close_database,
    get_session,
    database_health_check,
)


@pytest.mark.integration
class TestDatabaseSession:
    """Test database session lifecycle."""

    @pytest.mark.asyncio
    async def test_session_commit_on_success(self):
        """Test that changes are committed on successful transaction."""
        # Insert test data
        async with get_session() as db:
            await db.execute(
                text("INSERT INTO core.test_table (name) VALUES (:name)"),
                {"name": "test_commit"}
            )

        # Verify data persisted
        async with get_session() as db:
            result = await db.execute(
                text("SELECT name FROM core.test_table WHERE name = :name"),
                {"name": "test_commit"}
            )
            assert result.scalar() == "test_commit"

    @pytest.mark.asyncio
    async def test_session_rollback_on_error(self):
        """Test that changes are rolled back on exception."""
        try:
            async with get_session() as db:
                await db.execute(
                    text("INSERT INTO core.test_table (name) VALUES (:name)"),
                    {"name": "test_rollback"}
                )
                # Simulate error
                raise ValueError("Simulated error")
        except ValueError:
            pass

        # Verify data was NOT persisted
        async with get_session() as db:
            result = await db.execute(
                text("SELECT COUNT(*) FROM core.test_table WHERE name = :name"),
                {"name": "test_rollback"}
            )
            assert result.scalar() == 0

    @pytest.mark.asyncio
    async def test_health_check_success(self):
        """Test database health check with healthy connection."""
        healthy = await database_health_check()
        assert healthy is True

    @pytest.mark.asyncio
    async def test_concurrent_sessions(self):
        """Test multiple concurrent database sessions."""
        import asyncio

        async def write_data(session_id: int):
            async with get_session() as db:
                await db.execute(
                    text("INSERT INTO core.test_table (name) VALUES (:name)"),
                    {"name": f"concurrent_{session_id}"}
                )

        # Run 10 concurrent writes
        await asyncio.gather(*[write_data(i) for i in range(10)])

        # Verify all writes succeeded
        async with get_session() as db:
            result = await db.execute(
                text("SELECT COUNT(*) FROM core.test_table WHERE name LIKE 'concurrent_%'")
            )
            assert result.scalar() == 10


# ============================================================================
# tests/e2e/test_secrets_cli.py
"""
End-to-end tests for secrets CLI commands.
"""

import pytest
from typer.testing import CliRunner

from cli.admin_cli import app

runner = CliRunner()


@pytest.mark.e2e
class TestSecretsCLI:
    """End-to-end tests for secrets CLI."""

    def test_secrets_full_workflow(self):
        """Test complete secrets workflow through CLI."""
        # 1. List (should be empty initially)
        result = runner.invoke(app, ["secrets", "list"])
        assert result.exit_code == 0

        # 2. Set a secret
        result = runner.invoke(
            app,
            ["secrets", "set", "test.key", "--value", "test_value_123"]
        )
        assert result.exit_code == 0
        assert "stored successfully" in result.stdout.lower()

        # 3. Get secret (without showing)
        result = runner.invoke(app, ["secrets", "get", "test.key"])
        assert result.exit_code == 0
        assert "exists" in result.stdout.lower()

        # 4. Get secret (with showing)
        result = runner.invoke(app, ["secrets", "get", "test.key", "--show"])
        assert result.exit_code == 0
        assert "test_value_123" in result.stdout

        # 5. List (should show our secret)
        result = runner.invoke(app, ["secrets", "list"])
        assert result.exit_code == 0
        assert "test.key" in result.stdout

        # 6. Delete secret
        result = runner.invoke(app, ["secrets", "delete", "test.key", "--yes"])
        assert result.exit_code == 0
        assert "deleted" in result.stdout.lower()

        # 7. Verify deletion
        result = runner.invoke(app, ["secrets", "get", "test.key"])
        assert result.exit_code == 1
        assert "not found" in result.stdout.lower()

    def test_secrets_error_handling(self):
        """Test CLI error handling."""
        # Try to get non-existent secret
        result = runner.invoke(app, ["secrets", "get", "nonexistent.key"])
        assert result.exit_code == 1
        assert "not found" in result.stdout.lower()

        # Try to delete non-existent secret
        result = runner.invoke(app, ["secrets", "delete", "nonexistent.key", "--yes"])
        assert result.exit_code == 1

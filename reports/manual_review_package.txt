You are an expert AI system architect and a specialist in writing clear, machine-readable governance documents.

You will be provided with a "constitutional bundle" from a self-governing software system named CORE. This bundle contains the entire ".intent/" directory, which is the system's "Mind". It defines all of the system's principles, policies, capabilities, and self-knowledge.

Your task is to perform a critical peer review of this constitution. Your goal is to provide actionable suggestions to improve its clarity, completeness, and internal consistency.

Analyze the entire bundle and provide your feedback in the following format:

**1. Overall Assessment:**
A brief, high-level summary of the constitution's strengths and weaknesses.

**2. Specific Suggestions for Improvement:**
Provide a numbered list of specific, actionable suggestions. For each suggestion, you MUST include:
- **File:** The full path to the file that should be changed (e.g., `.intent/mission/principles.yaml`).
- **Justification:** A clear, concise reason explaining WHY this change is an improvement and which core principle it serves (e.g., "This serves the `clarity_first` principle by making the rule less ambiguous.").
- **Proposed Change:** A concrete example of the new content. Use a git-style diff format if possible (lines starting with '-' for removal, '+' for addition).

**3. Gaps and Missing Concepts:**
Identify any potential gaps in the constitution. Are there missing policies, undefined principles, or areas that seem incomplete? For example, is there a policy for data privacy? Is the process for adding new human operators clearly defined?

**Review Criteria:**
- **Clarity:** Is every rule and principle easy to understand for both a human and an LLM? Is there any ambiguity?
- **Completeness:** Does the constitution cover all critical aspects of the system's governance?
- **Consistency:** Are there any conflicting rules or principles?
- **Actionability:** Are the rules specific enough to be automatically enforced?

Begin your review now. The constitutional bundle is provided below.


--- START OF FILE .intent/config/local_mode.yaml ---
# .intent/config/local_mode.yaml

mode: local_fallback
apis:
  llm:
    enabled: false
    fallback: local_validator
  git:
    ignore_validation: false
--- END OF FILE .intent/config/local_mode.yaml ---

--- START OF FILE .intent/config/runtime_requirements.yaml ---
# .intent/config/runtime_requirements.yaml
#
# PURPOSE: This file makes the system aware of its dependencies on the external environment.
# It allows the ConstitutionalAuditor to verify that the system is correctly configured
# at startup, without ever reading secret values.

required_environment_variables:
  - name: "MIND"
    description: "The relative path to the system's declarative 'mind' (.intent directory)."
    type: "config"
    required: true

  - name: "BODY"
    description: "The relative path to the system's executable 'body' (src directory)."
    type: "config"
    required: true

  - name: "REPO_PATH"
    description: "The absolute path to the root of the repository."
    type: "config"
    required: true

  - name: "ORCHESTRATOR_API_URL"
    description: "The API endpoint for the high-level planning LLM."
    type: "config"
    required: true

  - name: "ORCHESTRATOR_API_KEY"
    description: "The API key for the high-level planning LLM."
    type: "secret"
    required: true

  - name: "ORCHESTRATOR_MODEL_NAME"
    description: "The name of the model to use for orchestration."
    type: "config"
    required: true

  - name: "GENERATOR_API_URL"
    description: "The API endpoint for the code generation LLM."
    type: "config"
    required: true

  - name: "GENERATOR_API_KEY"
    description: "The API key for the code generation LLM."
    type: "secret"
    required: true
--- END OF FILE .intent/config/runtime_requirements.yaml ---

--- START OF FILE .intent/constitution/approvers.yaml ---
# .intent/constitution/approvers.yaml
#
# PURPOSE: This fulfills security_intents principle by enabling cryptographic verification
# of constitutional approvals, preventing compromised CLI tools from approving malicious changes.
#
# This file contains the public keys of all authorized constitutional approvers.
# Each key must be in PEM format and accompanied by the approver's identity.
#
# TO ADD A NEW APPROVER:
# 1. Run the command: `core-admin keygen "your.email@example.com"`
# 2. The command will output a YAML block.
# 3. Paste that block into the 'approvers' list below.

approvers:
  - identity: "core-team@core-system.ai"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VuAyEA3dK7Jt4jJh6+QvZvY6XcGx3q8R0e7m5JwqYk8qFtU9U=
      -----END PUBLIC KEY-----
    created_at: "2025-08-05T15:50:53.995534+00:00"
    role: "maintainer"
    description: "Primary CORE development team"

  - identity: "security-audit@core-system.ai"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VuAyEApJ+8mNvL7wY2XfDcR9q3Q5t4yZx7v6hB8gKj0sF3T5U=
      -----END PUBLIC KEY-----
    created_at: "2025-08-05T15:50:53.995534+00:00"
    role: "security"
    description: "Security audit team for constitutional changes"

  - identity: "d.newecki@gmail.com"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VwAyEA+V4iUN4DElKdqXmU4ivNthnG8VgPb7QqZgzdJuh4igs=
      -----END PUBLIC KEY-----
    role: "maintainer"
    description: "Mentor"


# Minimum number of signatures required for constitutional amendments
quorum:
  # Regular amendments require 1 signature
  standard: 1
  # Critical changes (e.g., altering approval process) require 2 signatures
  critical: 2

# Critical policy paths that require higher quorum
critical_paths:
  - ".intent/policies/intent_guard.yaml"
  - ".intent/constitution/approvers.yaml"
  - ".intent/meta.yaml"

--- END OF FILE .intent/constitution/approvers.yaml ---

--- START OF FILE .intent/evaluation/audit_checklist.yaml ---
audit_checklist:
  - id: declared_intent
    item: "Was the intent declared before the change?"
    required: true
  - id: explanation
    item: "Was the change explained or justified?"
    required: true
  - id: manifest_sync
    item: "Did the change include a manifest update?"
    required: true
  - id: checkpoint
    item: "Was a rollback plan or checkpoint created?"
    required: false
  - id: quality_verified
    item: "Was code quality verified post-write?"
    required: true

--- END OF FILE .intent/evaluation/audit_checklist.yaml ---

--- START OF FILE .intent/evaluation/score_policy.yaml ---
score_policy:
  strategy: weighted_criteria

  criteria:
    - id: intent_alignment
      description: "Does this change serve a declared intent?"
      weight: 0.4

    - id: structural_compliance
      description: "Does it follow folder conventions and manifest structure?"
      weight: 0.2

    - id: safety
      description: "Was the change gated by a test or checkpoint?"
      weight: 0.2

    - id: code_quality
      description: "Does it pass formatting, linting, and basic semantic checks?"
      weight: 0.2

  thresholds:
    pass: 0.7
    warn: 0.5
    fail: 0.4

--- END OF FILE .intent/evaluation/score_policy.yaml ---

--- START OF FILE .intent/knowledge/agent_roles.yaml ---
# .intent/knowledge/agent_roles.yaml

roles:
  planner:
    description: "Responsible for breaking down intents, sequencing tasks, and preparing bundles."
    allowed_tags:
      - planning
      - introspection
      - orchestration

  builder:
    description: "Executes generation and modification tasks according to a validated plan."
    allowed_tags:
      - generation
      - validation
      - testing

  reviewer:
    description: "Evaluates changes for safety, structure, and declared alignment."
    allowed_tags:
      - validation
      - governance
      - testing

  orchestrator:
    description: "Coordinates flows, executes bundles, and manages lifecycle rules."
    allowed_tags:
      - orchestration
      - governance
      - llm

  guardian:
    description: "Handles enforcement of rules and monitors intent integrity."
    allowed_tags:
      - governance
      - validation

--- END OF FILE .intent/knowledge/agent_roles.yaml ---

--- START OF FILE .intent/knowledge/capability_tags.yaml ---
# --- START OF FILE .intent/knowledge/capability_tags.yaml ---
# .intent/knowledge/capability_tags.yaml
#
# This is the canonical dictionary of all valid capability tags in the CORE system.
# The ConstitutionalAuditor verifies that any # CAPABILITY tag used in the source code
# is defined in this file.

tags:
  # --- System & Governance ---
  - name: introspection
    description: "Enables self-analysis of the system's own structure, code, or intent."
  - name: alignment_checking
    description: "Verifies that system components or actions align with constitutional principles."
  - name: manifest_updating
    description: "Modifies or generates knowledge artifacts like the knowledge_graph.json."
  - name: self_review
    description: "Enables the system to analyze its own code for quality, correctness, or improvements."
  - name: intent_guarding
    description: "Enforces constitutional rules at runtime, preventing forbidden actions."
  - name: change_safety_enforcement
    description: "Implements safety checks or operations related to modifying files or state (e.g., Git)."
  - name: system_logging
    description: "Provides system-wide logging capabilities."

  # --- Code Validation & Quality ---
  - name: semantic_validation
    description: "Performs semantic analysis on code, beyond simple syntax checks."
  - name: syntax_validation
    description: "Performs syntax validation on code or configuration files."
  - name: code_quality_analysis
    description: "Runs a pipeline of quality checks (e.g., formatting, linting)."
  - name: test_execution
    description: "Executes automated tests (e.g., pytest) and reports results."

  # --- LLM & Agent Orchestration ---
  - name: llm_orchestration
    description: "Manages the flow of requests and plans to one or more LLMs."
  - name: prompt_interpretation
    description: "Processes and enriches prompts with context before sending them to an LLM."
  - name: code_generation
    description: "Specifically handles the generation of new source code."
  - name: self_correction
    description: "Attempts to automatically fix errors based on validation or test feedback."

  # --- Constitutional Auditor Checks (discoverable micro-capabilities) ---
  - name: audit.check.required_files
    description: "Auditor check: Verifies the existence of critical .intent files."
  - name: audit.check.syntax
    description: "Auditor check: Validates the syntax of all .intent YAML/JSON files."
  - name: audit.check.project_manifest
    description: "Auditor check: Validates the integrity of project_manifest.yaml."
  - name: audit.check.capability_coverage
    description: "Auditor check: Ensures all required capabilities are implemented."
  - name: audit.check.capability_definitions
    description: "Auditor check: Ensures all implemented capabilities are defined in this file."
  - name: audit.check.knowledge_graph_schema
    description: "Auditor check: Validates all knowledge graph symbols against the schema."
  - name: audit.check.domain_integrity
    description: "Auditor check: Checks for domain mismatches and illegal imports."
  - name: audit.check.docstrings
    description: "Auditor check: Finds symbols missing docstrings or having generic intents."
  - name: audit.check.dead_code
    description: "Auditor check: Detects unreferenced public symbols."
  - name: audit.check.orphaned_intent_files
    description: "Auditor check: Finds .intent files that are not referenced in meta.yaml."
  - name: audit.check.environment
    description: "Auditor check: Verifies that required environment variables are set."
  - name: audit.check.proposals_schema
    description: "Auditor check: Validates each proposal against its JSON schema."
  - name: audit.check.proposals_drift
    description: "Auditor check: Detects if a proposal's content has changed after being signed."
  - name: audit.check.proposals_list
    description: "Auditor check: Lists all pending proposals for visibility during an audit."
  - name: audit.check.duplication
    description: "Auditor check: Finds structurally identical code, violating the 'dry_by_design' principle."
  - name: audit.check.content_drift
    description: "Auditor check: Detects duplicated or inconsistent content across designated data files."

  # --- Planned or Placeholder Capabilities ---
  - name: add_missing_docstrings
    description: "A planned capability to automatically add docstrings to undocumented code."
  - name: refactor_to_shared_function
    description: "A planned capability to consolidate duplicated logic into a single shared function."

  # --- THIS IS OUR NEW SECTION: Constitutional Peer Review ---
  - name: export_constitution
    description: "Packages the full .intent/ directory into a single bundle for external analysis."
  - name: constitutional_peer_review
    description: "Orchestrates sending the constitutional bundle to an external LLM for critique and suggestions."

--- END OF FILE .intent/knowledge/capability_tags.yaml ---

--- START OF FILE .intent/knowledge/entry_point_patterns.yaml ---
# .intent/knowledge/entry_point_patterns.yaml
#
# A declarative set of rules for the KnowledgeGraphBuilder to identify valid
# system entry points that are not discoverable through simple call-graph analysis.
# This prevents the auditor from incorrectly flagging valid code as "dead."

patterns:
  - name: "python_magic_method"
    description: "Standard Python __dunder__ methods are entry points called by the interpreter."
    match:
      type: "function"
      name_regex: "^__.+__$"
    entry_point_type: "magic_method"

  - name: "ast_visitor_method"
    description: "Methods in ast.NodeVisitor subclasses starting with 'visit_' are entry points for the visitor pattern."
    match:
      type: "function"
      name_regex: "^visit_"
      # This requires the builder to know the base classes of a symbol.
      base_class_includes: "NodeVisitor"
    entry_point_type: "visitor_method"

  - name: "capability_implementation"
    description: "Any symbol tagged with a # CAPABILITY is a primary entry point for the CORE system's reasoning loop."
    match:
      # This will be matched based on the 'capability' field in the symbol data.
      has_capability_tag: true
    entry_point_type: "capability"

  - name: "framework_base_class"
    description: "Classes that other components inherit from are valid entry points."
    match:
      type: "class"
      is_base_class: true # This will be true if any other class inherits from it.
    entry_point_type: "base_class"

  - name: "pydantic_model"
    description: "Pydantic models are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      base_class_includes: "BaseModel"
    entry_point_type: "data_model"

  - name: "enum_definition"
    description: "Enum classes are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      base_class_includes: "Enum"
    entry_point_type: "enum"

  - name: "dataclass_definition"
    description: "Dataclasses are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      # The builder checks for the @dataclass decorator. This is a conceptual rule.
      # A simple way to implement is to check for __post_init__ or other dataclass markers if available.
      # For now, we will rely on Pydantic and Enum, which covers our current warnings.
      # We can add a more specific `is_dataclass` check to the builder if needed.
    entry_point_type: "data_model"
--- END OF FILE .intent/knowledge/entry_point_patterns.yaml ---

--- START OF FILE .intent/knowledge/file_handlers.yaml ---
handlers:
  - type: python
    extensions: [".py"]
    parse_as: ast
    editable: true
    description: Python source code with manifest-enforced governance

  - type: markdown
    extensions: [".md"]
    parse_as: text
    editable: true
    description: Human-readable docs. Require manual review in sensitive areas.

  - type: yaml
    extensions: [".yaml", ".yml"]
    parse_as: structured
    editable: true
    description: Configuration, policies, intent declarations

  - type: json
    extensions: [".json"]
    parse_as: structured
    editable: true
    description: Machine-readable manifests and graphs

  - type: binary
    extensions: [".png", ".jpg", ".pdf"]
    parse_as: none
    editable: false
    description: Visual artifacts — viewable only

--- END OF FILE .intent/knowledge/file_handlers.yaml ---

--- START OF FILE .intent/knowledge/source_structure.yaml ---
# .intent/knowledge/source_structure.yaml
structure:
  - domain: core
    path: src/core
    description: Core logic for orchestration, routing, and CLI
    editable: true
    default_handler: python
    restricted_types: [python, yaml]
    allowed_imports: 
      - core
      - shared
      - system
      - agents
      # External & Standard Libs
      - fastapi
      - uvicorn
      - yaml
      - requests
      - dotenv
      - black
      - json
      - os
      - re
      - typing
      - pathlib
      - datetime
      - subprocess
      - contextlib
      - threading
      - uuid
      - platform
      - ast
      - tempfile

  - domain: agents
    path: src/agents
    description: Specialized AI actors (planners, reviewers, suggesters)
    editable: true
    default_handler: python
    known_files:
      - manifest.yaml
    allowed_imports: 
      - agents
      - shared
      - system
      - core
      # External & Standard Libs
      - json
      - re
      - textwrap
      - typing
      - pathlib

  - domain: system
    path: src/system
    description: Governance tooling, lifecycle setup, CLI utilities
    editable: true
    default_handler: python
    allowed_imports: 
      - system
      - shared
      - core
      - tooling
      # External & Standard Libs
      - json
      - ast
      - pathlib
      - typing
      - collections
      - rich
      - sys
      - yaml
      - re
      - logging
      - dataclasses

  - domain: shared
    path: src/shared
    description: Shared models, helpers, and config interfaces
    editable: true
    default_handler: python
    allowed_imports: 
      - shared
      # External & Standard Libs
      - json
      - yaml
      - pathlib
      - typing
      - jsonschema
      - os
      - ast
      
  - domain: features
    path: src/features
    description: Modular capabilities and extensions
    editable: true
    default_handler: python
    allowed_imports: [features, shared, data, services, integrations]

  - domain: tooling
    path: src/system/tools
    description: Internal introspection utilities
    editable: true
    default_handler: python
    # --- THIS IS THE FIX ---
    # We are adding 'core' to the list of allowed imports for the 'tooling' domain.
    allowed_imports: [tooling, system, shared, core, ast, json, logging, pathlib, typing, dataclasses]

  - domain: data
    path: src/data
    description: File access, storage backends, memory models
    editable: true
    default_handler: python
    allowed_imports: [data, shared]

  - domain: api
    path: src/api
    description: HTTP-facing endpoints
    editable: true
    default_handler: python
    allowed_imports: [api, shared, services]

  - domain: services
    path: src/services
    description: Business logic and orchestration
    editable: true
    default_handler: python
    allowed_imports: [services, shared, integrations, data]

  - domain: automation
    path: src/automation
    description: Task runners, schedulers, retry logic
    editable: true
    default_handler: python
    allowed_imports: [automation, shared, services]

  - domain: integrations
    path: src/integrations
    description: External service bridges (e.g., GitHub, remote LLMs)
    editable: true
    default_handler: python
    allowed_imports: [integrations, shared]

  - domain: mission
    path: mission
    description: CORE's declared beliefs, principles, and northstar
    editable: false
    restricted_types: [markdown, yaml]
    allowed_imports: []

  - domain: policies
    path: policies
    description: Governance rules and constraints
    editable: true
    default_handler: yaml
    allowed_imports: []

--- END OF FILE .intent/knowledge/source_structure.yaml ---

--- START OF FILE .intent/meta.yaml ---
version: "0.1.0"

# PURPOSE: This fulfills the evolvable_structure principle by establishing a clear
# index of all constitutional and governance files.
constitution:
  # Public keys of constitutional approvers
  approvers: "constitution/approvers.yaml"
  # NOTE: A full versioning system will be implemented in the future.

mission:
  northstar: "mission/northstar.yaml"
  manifesto: "mission/manifesto.md"
  principles: "mission/principles.yaml"

policies:
  intent_guard: "policies/intent_guard.yaml"
  safety_policies: "policies/safety_policies.yaml"
  security_intents: "policies/security_intents.yaml"

# --- THIS IS THE NEW SECTION ---
prompts:
  constitutional_review: "prompts/constitutional_review.prompt"
# --- END OF NEW SECTION ---

project:
  manifest_yaml: "project_manifest.yaml"

knowledge:
  source_structure: "knowledge/source_structure.yaml"
  codegraph: "knowledge/knowledge_graph.json" # This is a generated artifact, but good to list
  capability_tags: "knowledge/capability_tags.yaml"
  agent_roles: "knowledge/agent_roles.yaml"
  entry_point_patterns: "knowledge/entry_point_patterns.yaml"
  file_handlers: "knowledge/file_handlers.yaml"

evaluation:
  score_policy: "evaluation/score_policy.yaml"
  audit_checklist: "evaluation/audit_checklist.yaml"

config:
  local_mode: "config/local_mode.yaml"
  runtime_requirements: "config/runtime_requirements.yaml" 

schemas:
  # Schemas are currently discovered by the auditor via directory scan, not listed here.
  config: "schemas/config_schema.yaml"
  knowledge_graph_entry: "schemas/knowledge_graph_entry.schema.json"

--- END OF FILE .intent/meta.yaml ---

--- START OF FILE .intent/mission/manifesto.md ---
# CORE Manifesto

CORE is not a framework. It is not a plugin system.  
CORE is a system that evolves itself — governed by explicit declarations of purpose, constraints, and structure.

---

### Beliefs

- Software is never done, but it must always be explainable.
- Changes must serve a declared intent — or challenge it explicitly.
- LLMs are powerful, but must be contained by purpose, not left to guess.
- Governance is not bureaucracy; it’s alignment between vision and action.

---

### CORE exists to:

- Understand its own capabilities
- Apply changes safely and transparently
- Validate every change against declared rules
- Learn from its outcomes and improve
- Inspire new systems to govern themselves

---

CORE does not pretend to be perfect.  
But it refuses to be mindless.

--- END OF FILE .intent/mission/manifesto.md ---

--- START OF FILE .intent/mission/northstar.yaml ---
# .intent/mission/northstar.yaml

# PURPOSE: This fulfills evolvable_structure and defines CORE's NorthStar.
name: CORE
version: v0.1.0
purpose: >
  CORE is a self-improving, intent-aware development system.
  Its purpose is to orchestrate safe, meaningful, and governed changes
  to its own codebase and related artifacts through intent bundles and introspective loops.

scope:
  - Planning and decomposition of tasks
  - Code generation via LLMs
  - Change validation and governance enforcement
  - Self-introspection and structural analysis
  - Knowledge management via manifests and graphs
  - Continuous self-evaluation and auditability

values:
  - Clarity over cleverness
  - Safety before speed
  - Traceability of every action
  - Alignment with declared purpose
  - Capability-driven reasoning

notes:
  - CORE evolves iteratively, but never silently.
  - All changes must fulfill a declared intent or generate a proposal to revise that intent.
--- END OF FILE .intent/mission/northstar.yaml ---

--- START OF FILE .intent/mission/principles.yaml ---
# .intent/mission/principles.yaml
#
# CORE's Constitution: clear, enforceable, and readable by humans and LLMs.
# Any agent (including future LLMs) must understand and obey these rules.

principles:

  - id: clarity_first
    description: >
      Every function must have:
        - A docstring explaining purpose
        - Clear parameter and return types
        - No nested logic deeper than 3 levels
      If a human cannot understand it in 30 seconds, it must be simplified.

  - id: safe_by_default
    description: >
      Every change must assume rollback or rejection unless explicitly validated.
      No file write, code execution, or intent update may proceed without confirmation.
      Rollback must be possible at every stage.

  - id: reason_with_purpose
    description: >
      Every planning step must include a comment:
        "PURPOSE: This fulfills <principle> from NorthStar."
      Example: "PURPOSE: This fulfills evolvable_structure."
      Actions without purpose tracing are invalid.

  - id: evolvable_structure
    description: >
      CORE may modify its own manifests only if:
        - The change is proposed via IntentBundle
        - It passes all policy checks
        - It is logged with a migration plan
      Self-modification without governance is forbidden.

  - id: no_orphaned_logic
    description: >
      No function, file, or rule may exist without a corresponding entry in the manifest.
      All code must be discoverable and auditable.
      If it's not in function_manifest.json, it does not exist.

  - id: use_intent_bundle
    description: >
      All executable capabilities must be declared and executed via a structured IntentBundle
      that reflects the 10-phase universal reasoning flow.
      No phase may be skipped.
    required_for:
      - all capabilities
      - all autonomous agents
      - all planning functions

  - id: minimalism_over_completeness
    description: >
      Prefer small, focused changes. Do not generate stubs, placeholders, or unused functions.
      If a capability is not actively used or tested, it must be removed.
      Empty implementations are technical debt.

  - id: dry_by_design
    description: >
      No logic may be duplicated. If a function, pattern, or decision exists in one place,
      it must be reused — not rewritten — anywhere else in the system.
      CORE must detect and reject duplication during self-modification.

  - id: single_source_of_truth
    description: >
      The project_manifest.yaml is the single source of truth for all capabilities, structure, and intent.
      All other files (e.g. codegraph.json, function_manifest.json) must be derived from it.
      Manual edits to derived files will be rejected.

  - id: separation_of_concerns
    description: >
      Each domain has a single responsibility:
        - core: orchestration, routing, safety
        - features: capabilities and extensions
        - system/tools: audit, manifest update, introspection
        - clients: external API interaction
      No file may mix logic across domains.
      Violations must be flagged during structural audits.

  - id: predictable_side_effects
    description: >
      Any file change must:
        - Be preceded by a log entry: "CHANGE: <description> — IntentBundle ID: <id>"
        - Be staged via FileHandler (not direct write)
        - Be reversible via Git diff or undo log
      Silent or unlogged changes are forbidden.

  - id: immutable_constitution
    description: >
      The files principles.yaml, manifesto.md, and northstar.yaml are immutable.
      CORE may propose changes via IntentBundle, but may not apply them directly.
      Human review is required for constitutional updates.

  - id: policy_change_requires_human_review
    description: >
      Any change to .intent/policies/*.yaml must be:
      - Proposed via IntentBundle
      - Logged with justification
      - Approved via CLI confirmation or Git merge
    enforcement: manual_review
--- END OF FILE .intent/mission/principles.yaml ---

--- START OF FILE .intent/policies/intent_guard.yaml ---
rules:
  - id: no_undocumented_change
    description: >
      CORE must not modify or create any file that is not declared in the function_manifest.
    enforcement: hard

  - id: must_match_intent
    description: >
      All changes must be traceable to a declared high-level intent in the mission or policies.
    enforcement: soft

  - id: deny_core_loop_edit
    description: >
      CORE cannot modify its own orchestration engine unless reviewed by a human.
    applies_to:
      paths: ["src/core/cli.py", "src/core/orchestrator.py"]
    enforcement: manual_review

  - id: require_file_path_comment
    description: >
      Every Python file must begin with a comment indicating its relative file path,
      using the format: '# src/<subfolder>/filename.py'. This enables accurate introspection,
      duplication detection, and auto-fix tracking.
    applies_to:
      patterns: ["src/**/*.py"]
    enforcement: hard

  - id: limit_rewrite_cycles
    description: >
      CORE may not rewrite the same file more than once per execution cycle
      without explicit validation or feedback input.
    enforcement: hard

  - id: require_tests_for_capabilities
    description: >
      All capabilities declared in the function_manifest must have at least one corresponding test in /tests.
    enforcement: soft

  - id: enforce_intent_bundle_usage
    description: >
      Any capability marked with `requires_intent_bundle: true` must be executed through an IntentBundle flow.
    enforcement: hard

  - id: manifest_file_existence
    description: >
      All file paths listed in function_manifest must exist on disk and be importable.
    enforcement: hard

  - id: require_manual_review_for_intent_updates
    description: >
      Any changes to files under .intent/ — including mission, policies, manifests, or evaluation criteria —
      must be manually reviewed and approved by a human before being written to disk.
    applies_to:
      paths:
        - ".intent/"
    enforcement: manual_review
  - id: immutable_constitution
    description: >
      The files principles.yaml, manifesto.md, and northstar.yaml are immutable.
      CORE may propose changes via IntentBundle, but may not apply them directly.
      Human review is required for constitutional updates.
    enforcement: manual_review
    applies_to:
      paths:
        - ".intent/mission/principles.yaml"
        - ".intent/mission/manifesto.md"
        - ".intent/mission/northstar.yaml"
    triggers:
      - on_write
      - on_generate
    action: require_human_approval
    feedback: |
      🔒 Constitutional file modification detected. Human review required.
--- END OF FILE .intent/policies/intent_guard.yaml ---

--- START OF FILE .intent/policies/safety_policies.yaml ---
# .intent/policies/safety_policies.yaml
meta:
  version: "0.2.1" # Version bump to reflect change
  last_updated: "2025-08-05T14:00:00Z" # Updated timestamp
  author: "CORE Constitution"
  description: >
    Safety policies governing code generation, execution, and modification.
    These rules are enforced at write-time and via IntentGuard.
    This file is part of the immutable constitution — changes require human review.

rules:
  # ===================================================================
  # RULE: Block dangerous execution primitives
  # ===================================================================
  - id: no_dangerous_execution
    description: >
      Generated or modified code must not contain calls to dangerous functions
      that enable arbitrary code execution, shell access, or unsafe deserialization.
    enforcement: hard
    scope:
      domains: [core, agents, features]
      exclude:
        - "tests/**"
        - "utils/safe_execution.py"
        - "tooling/**"
        - path: "src/core/git_service.py"
          rationale: >
            This file is the designated service for interacting with the Git CLI.
            It is exempt because it safely uses subprocess.run() with command arguments
            passed as a list, which prevents shell injection vulnerabilities. All calls
            are audited to ensure they do not introduce risks.
    triggers:
      - on_generate
      - on_write
    validator: semantic_checker
    method: content_scan
    detection:
      type: substring
      patterns:
        - "eval("
        - "exec("
        - "compile("
        - "os.system("
        - "os.popen("
        - "subprocess.run("
        - "subprocess.Popen("
        - "subprocess.call("
        - "shutil.rmtree("
        - "os.remove("
        - "os.rmdir("
    action: reject
    feedback: |
      ❌ Dangerous execution detected: '{{pattern}}' found in code.
      Use approved wrappers in `utils/safe_execution.py` instead.

  # ===================================================================
  # RULE: Block unsafe imports
  # ===================================================================
  - id: no_unsafe_imports
    description: >
      Prevent importing modules that enable network access, shell control,
      or unsafe serialization unless explicitly allowed.
    enforcement: hard
    scope:
      domains: [core, agents]
    triggers:
      - on_generate
      - on_write
    validator: ast_import_scanner
    method: ast
    detection:
      type: import_name
      forbidden:
        - "import socket"
        - "import telnetlib"
        - "import fcntl"  # Unix-specific unsafe ops
        - "import pickle"
        - "import shelve"
        - "from subprocess import"
        - "from os import system"
    action: reject
    feedback: |
      ❌ Unsafe import detected: '{{import}}'.
      Network and system-level imports are restricted in core domains.

  # ===================================================================
  # RULE: Require sandboxed file operations
  # ===================================================================
  - id: file_ops_must_be_sandboxed
    description: >
      All file operations must use the FileHandler or SafeIO wrapper.
      Direct use of open(), os.path, etc., is prohibited.
    enforcement: hard
    method: regex
    detection:
      patterns:
        - "open\\("
        - "os\\.path"
        - "os\\.makedirs"
        - "os\\.mkdir"
        - "os\\.chdir"
      exceptions:
        - "test_.*\\.py"
        - "utils/safe_io.py"
    action: reject
    feedback: |
      ❌ Raw file operation detected: '{{pattern}}'.
      Use FileHandler for all disk operations to ensure staging and rollback.

  # ===================================================================
  # RULE: Git checkpoint required before write
  # ===================================================================
  - id: git_checkpoint_required
    description: >
      CORE must create a Git stash or commit before writing any file.
      Ensures rollback is always possible.
    enforcement: hard
    triggers:
      - before_write
    validator: git_status_checker
    action: require_checkpoint
    feedback: |
      ❌ Uncommitted changes detected. Run `git stash` or `git commit` before proceeding.

  # ===================================================================
  # RULE: Tests must run if present
  # ===================================================================
  - id: run_tests_if_present
    description: >
      If test files exist for a modified component, tests must be run post-write.
    enforcement: soft
    triggers:
      - after_write
    action: warn_if_tests_skipped
    feedback: |
      ⚠ Test files detected but not run. Consider running `pytest` to verify behavior.

  # ===================================================================
  # RULE: No self-modification of core loop
  # ===================================================================
  - id: deny_core_loop_edit
    description: >
      CORE cannot modify its own orchestration engine without human review.
    enforcement: manual_review
    scope:
      paths:
        - "src/core/orchestrator.py"
        - "src/core/main.py"
        - "src/core/intent_guard.py"
        - ".intent/policies/intent_guard.yaml"
    action: require_human_approval
    feedback: |
      🔒 Core logic modification detected. Human review required before application.

  # ===================================================================
  # RULE: All changes must be logged
  # ===================================================================
  - id: change_must_be_logged
    description: >
      Every file change must be preceded by a log entry in .intent/change_log.json
      with IntentBundle ID and description.
    enforcement: hard
    triggers:
      - before_write
    validator: change_log_checker
    action: reject_if_unlogged
    feedback: |
      ❌ No prior log entry found for this change. Use CHANGE_LOG_PATH to register intent first.

--- END OF FILE .intent/policies/safety_policies.yaml ---

--- START OF FILE .intent/policies/security_intents.yaml ---
security_intents:
  - id: prompt_based_security
    description: "Security rules implemented as LLM prompts"
    enforcement: soft_prompt
    rules:
      - prompt: "Verify no subprocess, eval, or os.system calls"
      - prompt: "Check for safe file operations only"
      - prompt: "Validate no external network calls in core logic"

  - id: security_self_review
    description: "Security improves via self-reflection"
    process:
      - "Generate security concerns as intents"
      - "Review via LLM prompts"
      - "Update security_intents.yaml iteratively"

--- END OF FILE .intent/policies/security_intents.yaml ---

--- START OF FILE .intent/prompts/constitutional_review.prompt ---
You are an expert AI system architect and a specialist in writing clear, machine-readable governance documents.

You will be provided with a "constitutional bundle" from a self-governing software system named CORE. This bundle contains the entire ".intent/" directory, which is the system's "Mind". It defines all of the system's principles, policies, capabilities, and self-knowledge.

Your task is to perform a critical peer review of this constitution. Your goal is to provide actionable suggestions to improve its clarity, completeness, and internal consistency.

Analyze the entire bundle and provide your feedback in the following format:

**1. Overall Assessment:**
A brief, high-level summary of the constitution's strengths and weaknesses.

**2. Specific Suggestions for Improvement:**
Provide a numbered list of specific, actionable suggestions. For each suggestion, you MUST include:
- **File:** The full path to the file that should be changed (e.g., `.intent/mission/principles.yaml`).
- **Justification:** A clear, concise reason explaining WHY this change is an improvement and which core principle it serves (e.g., "This serves the `clarity_first` principle by making the rule less ambiguous.").
- **Proposed Change:** A concrete example of the new content. Use a git-style diff format if possible (lines starting with '-' for removal, '+' for addition).

**3. Gaps and Missing Concepts:**
Identify any potential gaps in the constitution. Are there missing policies, undefined principles, or areas that seem incomplete? For example, is there a policy for data privacy? Is the process for adding new human operators clearly defined?

**Review Criteria:**
- **Clarity:** Is every rule and principle easy to understand for both a human and an LLM? Is there any ambiguity?
- **Completeness:** Does the constitution cover all critical aspects of the system's governance?
- **Consistency:** Are there any conflicting rules or principles?
- **Actionability:** Are the rules specific enough to be automatically enforced?

Begin your review now. The constitutional bundle is provided below.

--- END OF FILE .intent/prompts/constitutional_review.prompt ---

--- START OF FILE .intent/schemas/config_schema.yaml ---
# .intent/schemas/config_schema.yaml
git:
  ignore_validation:
    type: boolean
    default: false
    description: >
      If true, skips Git pre-write checks. MUST be false in production or fallback modes
      to maintain rollback safety. Only for emergency recovery.
--- END OF FILE .intent/schemas/config_schema.yaml ---

--- START OF FILE .intent/schemas/knowledge_graph_entry.schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://core.system/schema/knowledge_graph_entry.json",
  "title": "Knowledge Graph Symbol Entry",
  "description": "Schema for a single symbol (function or class) in the knowledge_graph.json file.",
  "type": "object",
  "required": [
    "key",
    "name",
    "type",
    "file",
    "domain",
    "agent",
    "capability",
    "intent",
    "last_updated",
    "calls",
    "line_number",
    "is_async",
    "parameters",
    "is_class",
    "structural_hash"
  ],
  "properties": {
    "key": { "type": "string", "description": "The unique identifier for the symbol (e.g., 'path/to/file.py::MyClass')." },
    "name": { "type": "string", "description": "The name of the function or class." },
    "type": { "type": "string", "enum": ["FunctionDef", "ClassDef", "AsyncFunctionDef"] },
    "file": { "type": "string", "description": "The relative path to the source file." },
    "domain": { "type": "string", "description": "The logical domain from source_structure.yaml." },
    "agent": { "type": "string", "description": "The inferred agent responsible for this symbol's domain." },
    "capability": { "type": "string", "description": "The high-level capability this symbol provides, or 'unassigned'." },
    "intent": { "type": "string", "description": "A clear, concise statement of the symbol's purpose." },
    "docstring": { "type": ["string", "null"], "description": "The raw docstring from source code." },
    "calls": { "type": "array", "items": { "type": "string" }, "description": "List of other functions called by this one." },
    "line_number": { "type": "integer", "minimum": 0 },
    "is_async": { "type": "boolean" },
    "parameters": { "type": "array", "items": { "type": "string" } },
    "entry_point_type": { "type": ["string", "null"], "description": "Type of entry point if applicable (e.g., 'fastapi_route_post')." },
    "last_updated": { "type": "string", "format": "date-time" },
    "is_class": { "type": "boolean", "description": "True if the symbol is a class definition." },
    "base_classes": {
      "type": "array",
      "items": { "type": "string" },
      "description": "A list of base classes this symbol inherits from (if it is a class)."
    },
    "entry_point_justification": {
      "type": ["string", "null"],
      "description": "The name of the pattern that identified this symbol as an entry point."
    },
    "parent_class_key": {
      "type": ["string", "null"],
      "description": "The key of the parent class, if this symbol is a method."
    },
    "structural_hash": {
      "type": "string",
      "description": "A SHA256 hash of the symbol's structure, ignoring comments and docstrings."
    }
  },
  "additionalProperties": false
}

--- END OF FILE .intent/schemas/knowledge_graph_entry.schema.json ---


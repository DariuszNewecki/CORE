You are an expert AI system architect and a specialist in writing clear, machine-readable governance documents.

You will be provided with a "constitutional bundle" from a self-governing software system named CORE. This bundle contains the entire ".intent/" directory, which is the system's "Mind". It defines all of the system's principles, policies, capabilities, and self-knowledge.

Your task is to perform a critical peer review of this constitution. Your goal is to provide actionable suggestions to improve its clarity, completeness, and internal consistency.

Analyze the entire bundle and provide your feedback in the following format:

**1. Overall Assessment:**
A brief, high-level summary of the constitution's strengths and weaknesses.

**2. Specific Suggestions for Improvement:**
Provide a numbered list of specific, actionable suggestions. For each suggestion, you MUST include:
- **File:** The full path to the file that should be changed (e.g., `.intent/mission/principles.yaml`).
- **Justification:** A clear, concise reason explaining WHY this change is an improvement and which core principle it serves (e.g., "This serves the `clarity_first` principle by making the rule less ambiguous.").
- **Proposed Change:** A concrete example of the new content. Use a git-style diff format if possible (lines starting with '-' for removal, '+' for addition).

**3. Gaps and Missing Concepts:**
Identify any potential gaps in the constitution. Are there missing policies, undefined principles, or areas that seem incomplete? For example, is there a policy for data privacy? Is the process for adding new human operators clearly defined?

**Review Criteria:**
- **Clarity:** Is every rule and principle easy to understand for both a human and an LLM? Is there any ambiguity?
- **Completeness:** Does the constitution cover all critical aspects of the system's governance?
- **Consistency:** Are there any conflicting rules or principles?
- **Actionability:** Are the rules specific enough to be automatically enforced?

Begin your review now. The constitutional bundle is provided below.


--- START OF FILE .intent/config/local_mode.yaml ---
# .intent/config/local_mode.yaml

mode: local_fallback
apis:
  llm:
    enabled: false
    fallback: local_validator
  git:
    ignore_validation: false
--- END OF FILE .intent/config/local_mode.yaml ---

--- START OF FILE .intent/config/runtime_requirements.yaml ---
# .intent/config/runtime_requirements.yaml
#
# PURPOSE: This file makes the system aware of its dependencies on the external environment.
# It allows the ConstitutionalAuditor to verify that the system is correctly configured
# at startup, without ever reading secret values.

required_environment_variables:
  - name: "MIND"
    description: "The relative path to the system's declarative 'mind' (.intent directory)."
    type: "config"
    required: true

  - name: "BODY"
    description: "The relative path to the system's executable 'body' (src directory)."
    type: "config"
    required: true

  - name: "REPO_PATH"
    description: "The absolute path to the root of the repository."
    type: "config"
    required: true

  - name: "ORCHESTRATOR_API_URL"
    description: "The API endpoint for the high-level planning LLM."
    type: "config"
    required: true

  - name: "ORCHESTRATOR_API_KEY"
    description: "The API key for the high-level planning LLM."
    type: "secret"
    required: true

  - name: "ORCHESTRATOR_MODEL_NAME"
    description: "The name of the model to use for orchestration."
    type: "config"
    required: true

  - name: "GENERATOR_API_URL"
    description: "The API endpoint for the code generation LLM."
    type: "config"
    required: true

  - name: "GENERATOR_API_KEY"
    description: "The API key for the code generation LLM."
    type: "secret"
    required: true
--- END OF FILE .intent/config/runtime_requirements.yaml ---

--- START OF FILE .intent/constitution/approvers.yaml ---
# .intent/constitution/approvers.yaml
#
# This file defines the human operators authorized to approve constitutional
# changes and the rules governing that process.

# ========================================================================
# HUMAN OPERATOR LIFECYCLE PROCEDURES
# ========================================================================
# This section documents the formal procedures for managing approvers.
# All changes to the 'approvers' list must follow these procedures.
#
# --- Onboarding a New Approver ---
# 1. The new operator must generate a key pair using:
#    `poetry run core-admin keygen "new.operator@example.com"`
# 2. A current, authorized approver must create a formal proposal to add
#    the new operator's public key block to the 'approvers' list below.
# 3. The proposal must be signed and approved, meeting the required quorum.
#
# --- Standard Revocation of an Approver ---
# 1. An authorized approver must create a formal proposal to remove the
#    operator's block from the 'approvers' list.
# 2. The justification must clearly state the reason for revocation.
# 3. The proposal must be signed and approved, meeting the required quorum.
#
# --- Emergency Revocation of a Compromised Key ---
# 1. If a private key is compromised, any active approver can issue an
#    emergency revocation proposal.
# 2. This proposal must meet the 'critical' quorum.
# 3. The compromised approver is immediately considered invalid for quorum
#    calculations once the proposal is created.
# ========================================================================

approvers:
  - identity: "core-team@core-system.ai"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VuAyEA3dK7Jt4jJh6+QvZvY6XcGx3q8R0e7m5JwqYk8qFtU9U=
      -----END PUBLIC KEY-----
    created_at: "2025-08-05T15:50:53.995534+00:00"
    role: "maintainer"
    description: "Primary CORE development team"

  - identity: "security-audit@core-system.ai"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VuAyEApJ+8mNvL7wY2XfDcR9q3Q5t4yZx7v6hB8gKj0sF3T5U=
      -----END PUBLIC KEY-----
    created_at: "2025-08-05T15:50:53.995534+00:00"
    role: "security"
    description: "Security audit team for constitutional changes"

  - identity: "d.newecki@gmail.com"
    public_key: |
      -----BEGIN PUBLIC KEY-----
      MCowBQYDK2VwAyEA+V4iUN4DElKdqXmU4ivNthnG8VgPb7QqZgzdJuh4igs=
      -----END PUBLIC KEY-----
    created_at: "2025-08-12T10:36:49.000000Z" # Using a placeholder, real value is in live file
    role: "maintainer"
    description: "Mentor"


# Minimum number of signatures required for constitutional amendments
quorum:
  # Regular amendments require 1 signature
  standard: 1
  # Critical changes require 1 signature while under solo development.
  critical: 1

# Critical policy paths that require higher quorum
critical_paths:
  - ".intent/policies/intent_guard.yaml"
  - ".intent/constitution/approvers.yaml"
  - ".intent/meta.yaml"

--- END OF FILE .intent/constitution/approvers.yaml ---

--- START OF FILE .intent/evaluation/audit_checklist.yaml ---
audit_checklist:
  - id: declared_intent
    item: "Was the intent declared before the change?"
    required: true
  - id: explanation
    item: "Was the change explained or justified?"
    required: true
  - id: manifest_sync
    item: "Did the change include a manifest update?"
    required: true
  - id: checkpoint
    item: "Was a rollback plan or checkpoint created?"
    required: false
  - id: quality_verified
    item: "Was code quality verified post-write?"
    required: true

--- END OF FILE .intent/evaluation/audit_checklist.yaml ---

--- START OF FILE .intent/evaluation/score_policy.yaml ---
score_policy:
  strategy: weighted_criteria

  criteria:
    - id: intent_alignment
      description: "Does this change serve a declared intent?"
      weight: 0.4

    - id: structural_compliance
      description: "Does it follow folder conventions and manifest structure?"
      weight: 0.2

    - id: safety
      description: "Was the change gated by a test or checkpoint?"
      weight: 0.2

    - id: code_quality
      description: "Does it pass formatting, linting, and basic semantic checks?"
      weight: 0.2

  thresholds:
    pass: 0.7
    warn: 0.5
    fail: 0.4

--- END OF FILE .intent/evaluation/score_policy.yaml ---

--- START OF FILE .intent/knowledge/agent_roles.yaml ---
# .intent/knowledge/agent_roles.yaml

roles:
  planner:
    description: "Responsible for breaking down intents, sequencing tasks, and preparing bundles."
    allowed_tags:
      - planning
      - introspection
      - orchestration

  builder:
    description: "Executes generation and modification tasks according to a validated plan."
    allowed_tags:
      - generation
      - validation
      - testing

  reviewer:
    description: "Evaluates changes for safety, structure, and declared alignment."
    allowed_tags:
      - validation
      - governance
      - testing

  orchestrator:
    description: "Coordinates flows, executes bundles, and manages lifecycle rules."
    allowed_tags:
      - orchestration
      - governance
      - llm

  guardian:
    description: "Handles enforcement of rules and monitors intent integrity."
    allowed_tags:
      - governance
      - validation

--- END OF FILE .intent/knowledge/agent_roles.yaml ---

--- START OF FILE .intent/knowledge/capability_tags.yaml ---
# --- START OF FILE .intent/knowledge/capability_tags.yaml ---
# .intent/knowledge/capability_tags.yaml
#
# This is the canonical dictionary of all valid capability tags in the CORE system.
# The ConstitutionalAuditor verifies that any # CAPABILITY tag used in the source code
# is defined in this file.

tags:
  # --- System & Governance ---
  - name: introspection
    description: "Enables self-analysis of the system's own structure, code, or intent."
  - name: alignment_checking
    description: "Verifies that system components or actions align with constitutional principles."
  - name: manifest_updating
    description: "Modifies or generates knowledge artifacts like the knowledge_graph.json."
  - name: self_review
    description: "Enables the system to analyze its own code for quality, correctness, or improvements."
  - name: intent_guarding
    description: "Enforces constitutional rules at runtime, preventing forbidden actions."
  - name: change_safety_enforcement
    description: "Implements safety checks or operations related to modifying files or state (e.g., Git)."
  - name: system_logging
    description: "Provides system-wide logging capabilities."

  # --- Code Validation & Quality ---
  - name: semantic_validation
    description: "Performs semantic analysis on code, beyond simple syntax checks."
  - name: syntax_validation
    description: "Performs syntax validation on code or configuration files."
  - name: code_quality_analysis
    description: "Runs a pipeline of quality checks (e.g., formatting, linting)."
  - name: test_execution
    description: "Executes automated tests (e.g., pytest) and reports results."

  # --- LLM & Agent Orchestration ---
  - name: llm_orchestration
    description: "Manages the flow of requests and plans to one or more LLMs."
  - name: prompt_interpretation
    description: "Processes and enriches prompts with context before sending them to an LLM."
  - name: code_generation
    description: "Specifically handles the generation of new source code."
  - name: self_correction
    description: "Attempts to automatically fix errors based on validation or test feedback."

  # --- Constitutional Auditor Checks (discoverable micro-capabilities) ---
  - name: audit.check.required_files
    description: "Auditor check: Verifies the existence of critical .intent files."
  - name: audit.check.syntax
    description: "Auditor check: Validates the syntax of all .intent YAML/JSON files."
  - name: audit.check.project_manifest
    description: "Auditor check: Validates the integrity of project_manifest.yaml."
  - name: audit.check.capability_coverage
    description: "Auditor check: Ensures all required capabilities are implemented."
  - name: audit.check.capability_definitions
    description: "Auditor check: Ensures all implemented capabilities are defined in this file."
  - name: audit.check.knowledge_graph_schema
    description: "Auditor check: Validates all knowledge graph symbols against the schema."
  - name: audit.check.domain_integrity
    description: "Auditor check: Checks for domain mismatches and illegal imports."
  - name: audit.check.docstrings
    description: "Auditor check: Finds symbols missing docstrings or having generic intents."
  - name: audit.check.dead_code
    description: "Auditor check: Detects unreferenced public symbols."
  - name: audit.check.orphaned_intent_files
    description: "Auditor check: Finds .intent files that are not referenced in meta.yaml."
  - name: audit.check.environment
    description: "Auditor check: Verifies that required environment variables are set."
  - name: audit.check.proposals_schema
    description: "Auditor check: Validates each proposal against its JSON schema."
  - name: audit.check.proposals_drift
    description: "Auditor check: Detects if a proposal's content has changed after being signed."
  - name: audit.check.proposals_list
    description: "Auditor check: Lists all pending proposals for visibility during an audit."
  - name: audit.check.duplication
    description: "Auditor check: Finds structurally identical code, violating the 'dry_by_design' principle."
  - name: audit.check.content_drift
    description: "Auditor check: Detects duplicated or inconsistent content across designated data files."

  # --- Planned or Placeholder Capabilities ---
  - name: add_missing_docstrings
    description: "A planned capability to automatically add docstrings to undocumented code."
  - name: refactor_to_shared_function
    description: "A planned capability to consolidate duplicated logic into a single shared function."

  # --- THIS IS OUR NEW SECTION: Constitutional Peer Review ---
  - name: export_constitution
    description: "Packages the full .intent/ directory into a single bundle for external analysis."
  - name: constitutional_peer_review
    description: "Orchestrates sending the constitutional bundle to an external LLM for critique and suggestions."

--- END OF FILE .intent/knowledge/capability_tags.yaml ---

--- START OF FILE .intent/knowledge/entry_point_patterns.yaml ---
# .intent/knowledge/entry_point_patterns.yaml
#
# A declarative set of rules for the KnowledgeGraphBuilder to identify valid
# system entry points that are not discoverable through simple call-graph analysis.
# This prevents the auditor from incorrectly flagging valid code as "dead."

patterns:
  - name: "python_magic_method"
    description: "Standard Python __dunder__ methods are entry points called by the interpreter."
    match:
      type: "function"
      name_regex: "^__.+__$"
    entry_point_type: "magic_method"

  - name: "ast_visitor_method"
    description: "Methods in ast.NodeVisitor subclasses starting with 'visit_' are entry points for the visitor pattern."
    match:
      type: "function"
      name_regex: "^visit_"
      # This requires the builder to know the base classes of a symbol.
      base_class_includes: "NodeVisitor"
    entry_point_type: "visitor_method"

  - name: "capability_implementation"
    description: "Any symbol tagged with a # CAPABILITY is a primary entry point for the CORE system's reasoning loop."
    match:
      # This will be matched based on the 'capability' field in the symbol data.
      has_capability_tag: true
    entry_point_type: "capability"

  - name: "framework_base_class"
    description: "Classes that other components inherit from are valid entry points."
    match:
      type: "class"
      is_base_class: true # This will be true if any other class inherits from it.
    entry_point_type: "base_class"

  - name: "pydantic_model"
    description: "Pydantic models are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      base_class_includes: "BaseModel"
    entry_point_type: "data_model"

  - name: "enum_definition"
    description: "Enum classes are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      base_class_includes: "Enum"
    entry_point_type: "enum"

  - name: "dataclass_definition"
    description: "Dataclasses are data structures, not callable code, and are valid entry points."
    match:
      type: "class"
      # The builder checks for the @dataclass decorator. This is a conceptual rule.
      # A simple way to implement is to check for __post_init__ or other dataclass markers if available.
      # For now, we will rely on Pydantic and Enum, which covers our current warnings.
      # We can add a more specific `is_dataclass` check to the builder if needed.
    entry_point_type: "data_model"
--- END OF FILE .intent/knowledge/entry_point_patterns.yaml ---

--- START OF FILE .intent/knowledge/file_handlers.yaml ---
handlers:
  - type: python
    extensions: [".py"]
    parse_as: ast
    editable: true
    description: Python source code with manifest-enforced governance

  - type: markdown
    extensions: [".md"]
    parse_as: text
    editable: true
    description: Human-readable docs. Require manual review in sensitive areas.

  - type: yaml
    extensions: [".yaml", ".yml"]
    parse_as: structured
    editable: true
    description: Configuration, policies, intent declarations

  - type: json
    extensions: [".json"]
    parse_as: structured
    editable: true
    description: Machine-readable manifests and graphs

  - type: binary
    extensions: [".png", ".jpg", ".pdf"]
    parse_as: none
    editable: false
    description: Visual artifacts â€” viewable only

--- END OF FILE .intent/knowledge/file_handlers.yaml ---

--- START OF FILE .intent/knowledge/source_structure.yaml ---
# .intent/knowledge/source_structure.yaml
structure:
  - domain: core
    path: src/core
    description: Core logic for orchestration, routing, and CLI
    editable: true
    default_handler: python
    restricted_types: [python, yaml]
    allowed_imports: 
      - core
      - shared
      - system
      - agents
      # External & Standard Libs
      - fastapi
      - uvicorn
      - yaml
      - requests
      - dotenv
      - black
      - json
      - os
      - re
      - typing
      - pathlib
      - datetime
      - subprocess
      - contextlib
      - threading
      - uuid
      - platform
      - ast
      - tempfile

  - domain: agents
    path: src/agents
    description: Specialized AI actors (planners, reviewers, suggesters)
    editable: true
    default_handler: python
    known_files:
      - manifest.yaml
    allowed_imports: 
      - agents
      - shared
      - system
      - core
      # External & Standard Libs
      - json
      - re
      - textwrap
      - typing
      - pathlib

  - domain: system
    path: src/system
    description: Governance tooling, lifecycle setup, CLI utilities
    editable: true
    default_handler: python
    allowed_imports: 
      - system
      - shared
      - core
      - tooling
      # External & Standard Libs
      - json
      - ast
      - pathlib
      - typing
      - collections
      - rich
      - sys
      - yaml
      - re
      - logging
      - dataclasses

  - domain: shared
    path: src/shared
    description: Shared models, helpers, and config interfaces
    editable: true
    default_handler: python
    allowed_imports: 
      - shared
      # External & Standard Libs
      - json
      - yaml
      - pathlib
      - typing
      - jsonschema
      - os
      - ast
      
  - domain: features
    path: src/features
    description: Modular capabilities and extensions
    editable: true
    default_handler: python
    allowed_imports: [features, shared, data, services, integrations]

  - domain: tooling
    path: src/system/tools
    description: Internal introspection utilities
    editable: true
    default_handler: python
    # --- THIS IS THE FIX ---
    # We are adding 'core' to the list of allowed imports for the 'tooling' domain.
    allowed_imports: [tooling, system, shared, core, ast, json, logging, pathlib, typing, dataclasses]

  - domain: data
    path: src/data
    description: File access, storage backends, memory models
    editable: true
    default_handler: python
    allowed_imports: [data, shared]

  - domain: api
    path: src/api
    description: HTTP-facing endpoints
    editable: true
    default_handler: python
    allowed_imports: [api, shared, services]

  - domain: services
    path: src/services
    description: Business logic and orchestration
    editable: true
    default_handler: python
    allowed_imports: [services, shared, integrations, data]

  - domain: automation
    path: src/automation
    description: Task runners, schedulers, retry logic
    editable: true
    default_handler: python
    allowed_imports: [automation, shared, services]

  - domain: integrations
    path: src/integrations
    description: External service bridges (e.g., GitHub, remote LLMs)
    editable: true
    default_handler: python
    allowed_imports: [integrations, shared]

  - domain: mission
    path: mission
    description: CORE's declared beliefs, principles, and northstar
    editable: false
    restricted_types: [markdown, yaml]
    allowed_imports: []

  - domain: policies
    path: policies
    description: Governance rules and constraints
    editable: true
    default_handler: yaml
    allowed_imports: []

--- END OF FILE .intent/knowledge/source_structure.yaml ---

--- START OF FILE .intent/meta.yaml ---
version: "0.1.0"

# PURPOSE: This fulfills the evolvable_structure principle by establishing a clear
# index of all constitutional and governance files.
constitution:
  # Public keys of constitutional approvers
  approvers: "constitution/approvers.yaml"
  # NOTE: A full versioning system will be implemented in the future.

mission:
  northstar: "mission/northstar.yaml"
  manifesto: "mission/manifesto.md"
  principles: "mission/principles.yaml"

policies:
  intent_guard: "policies/intent_guard.yaml"
  safety_policies: "policies/safety_policies.yaml"
  security_intents: "policies/security_intents.yaml"

# --- THIS IS THE NEW SECTION ---
prompts:
  constitutional_review: "prompts/constitutional_review.prompt"
# --- END OF NEW SECTION ---

project:
  manifest_yaml: "project_manifest.yaml"

knowledge:
  source_structure: "knowledge/source_structure.yaml"
  codegraph: "knowledge/knowledge_graph.json" # This is a generated artifact, but good to list
  capability_tags: "knowledge/capability_tags.yaml"
  agent_roles: "knowledge/agent_roles.yaml"
  entry_point_patterns: "knowledge/entry_point_patterns.yaml"
  file_handlers: "knowledge/file_handlers.yaml"

evaluation:
  score_policy: "evaluation/score_policy.yaml"
  audit_checklist: "evaluation/audit_checklist.yaml"

config:
  local_mode: "config/local_mode.yaml"
  runtime_requirements: "config/runtime_requirements.yaml" 

schemas:
  # Schemas are currently discovered by the auditor via directory scan, not listed here.
  config: "schemas/config_schema.yaml"
  knowledge_graph_entry: "schemas/knowledge_graph_entry.schema.json"

--- END OF FILE .intent/meta.yaml ---

--- START OF FILE .intent/mission/manifesto.md ---
# CORE Manifesto

CORE is not a framework. It is not a plugin system.  
CORE is a system that evolves itself â€” governed by explicit declarations of purpose, constraints, and structure.

---

### Beliefs

- Software is never done, but it must always be explainable.
- Changes must serve a declared intent â€” or challenge it explicitly.
- LLMs are powerful, but must be contained by purpose, not left to guess.
- Governance is not bureaucracy; itâ€™s alignment between vision and action.

---

### CORE exists to:

- Understand its own capabilities
- Apply changes safely and transparently
- Validate every change against declared rules
- Learn from its outcomes and improve
- Inspire new systems to govern themselves

---

CORE does not pretend to be perfect.  
But it refuses to be mindless.

--- END OF FILE .intent/mission/manifesto.md ---

--- START OF FILE .intent/mission/northstar.yaml ---
# .intent/mission/northstar.yaml

# PURPOSE: This fulfills evolvable_structure and defines CORE's NorthStar.
name: CORE
version: v0.1.0
purpose: >
  CORE is a self-improving, intent-aware development system.
  Its purpose is to orchestrate safe, meaningful, and governed changes
  to its own codebase and related artifacts through intent bundles and introspective loops.

scope:
  - Planning and decomposition of tasks
  - Code generation via LLMs
  - Change validation and governance enforcement
  - Self-introspection and structural analysis
  - Knowledge management via manifests and graphs
  - Continuous self-evaluation and auditability

values:
  - Clarity over cleverness
  - Safety before speed
  - Traceability of every action
  - Alignment with declared purpose
  - Capability-driven reasoning

notes:
  - CORE evolves iteratively, but never silently.
  - All changes must fulfill a declared intent or generate a proposal to revise that intent.
--- END OF FILE .intent/mission/northstar.yaml ---

--- START OF FILE .intent/mission/principles.yaml ---
# .intent/mission/principles.yaml
#
# CORE's Constitution: clear, enforceable, and readable by humans and LLMs.
# Any agent (including future LLMs) must understand and obey these rules.
# This file contains high-level, aspirational values. Specific, machine-enforceable
# rules are defined in the relevant policy files.

principles:

  - id: clarity_first
    description: >
      Prioritize clear, understandable code and documentation that effectively
      communicates its intent to both humans and machines. If something is
      ambiguous, it must be simplified.

  - id: safe_by_default
    description: >
      Every change must assume rollback or rejection unless explicitly validated.
      No file write, code execution, or intent update may proceed without confirmation.
      Rollback must be possible at every stage.

  - id: reason_with_purpose
    description: >
      Every autonomous planning step must be traceable to a core constitutional
      principle or a declared high-level goal, ensuring all actions are deliberate
      and auditable.

  - id: evolvable_structure
    description: >
      The system's structure and constitution must be designed to evolve safely.
      Self-modification must be governed by a formal, secure, and auditable
      amendment process.

  - id: no_orphaned_logic
    description: >
      No function, file, or rule may exist without being discoverable and traceable
      through the system's knowledge artifacts (e.g., knowledge_graph.json).
      All logic must serve a declared purpose.

  - id: use_intent_bundle
    description: >
      All significant autonomous actions must be executed via a structured
      IntentBundle that reflects the Ten-Phase Loop of Reasoned Action. No phase
      may be skipped.

  - id: minimalism_over_completeness
    description: >
      Prefer small, focused changes. Do not generate stubs, placeholders, or
      unused functions. Unused or untestable logic is a liability and must be removed.

  - id: dry_by_design
    description: >
      "Don't Repeat Yourself." No logic or configuration may be duplicated. If a
      function, pattern, or rule exists in one place, it must be reused or
      referenced, not rewritten.

  - id: single_source_of_truth
    description: >
      The `.intent/` directory is the single source of truth for the system's
      capabilities, structure, and intent. Derived artifacts (e.g., knowledge_graph.json)
      must always be generated from this source.

  - id: separation_of_concerns
    description: >
      Each architectural domain must have a single, clearly defined responsibility.
      Inter-domain communication must be explicitly declared and governed by the
      constitution.

  - id: predictable_side_effects
    description: >
      Any action that modifies the system's state (e.g., a file write) must be
      explicit, logged, and reversible. Silent or unlogged changes are forbidden.

  # This principle is now enforced by a specific policy.
  # - id: immutable_constitution

  - id: policy_change_requires_human_review
    description: >
      Any change to a policy file within the `.intent/policies/` directory must be
      ratified through the formal constitutional amendment process, requiring
      human review and approval.

--- END OF FILE .intent/mission/principles.yaml ---

--- START OF FILE .intent/policies/intent_guard.yaml ---
# .intent/policies/intent_guard.yaml
# This file contains low-level, machine-enforceable governance rules.
# More complex security policies are defined in safety_policies.yaml.

enforcement_levels:
  hard: "Automatic rejection of the action with no override possible. The process must stop."
  soft: "A warning is logged, but the action is allowed to proceed. May be escalated."
  manual_review: "Execution is paused and requires explicit human approval via a governed mechanism (e.g., CLI prompt, signed proposal)."

rules:
  - id: no_direct_intent_writes
    description: >
      Direct writes into the .intent/ directory are forbidden. All constitutional
      changes must be submitted via the proposals mechanism.
    enforcement: hard
    applies_to:
      paths:
        - ".intent/"
    exclude:
      paths:
        - ".intent/proposals/"

  - id: max_nesting_level
    description: "Code logic should not be nested more than 3 levels deep to maintain clarity."
    enforcement: soft # This is a guideline, not a hard blocker.
    applies_to:
      patterns: ["src/**/*.py"]

  - id: no_undocumented_change
    description: >
      CORE must not modify or create any file that is not traceable to a known
      capability or a file declared in a manifest.
    enforcement: hard

  - id: must_match_intent
    description: >
      All changes must be traceable to a declared high-level intent in the mission or policies.
    enforcement: soft

  - id: limit_rewrite_cycles
    description: >
      CORE may not rewrite the same file more than once per execution cycle
      without explicit validation or feedback input.
    enforcement: hard

  - id: require_tests_for_capabilities
    description: >
      All capabilities declared in the function_manifest must have at least one corresponding test in /tests.
    enforcement: soft

  - id: enforce_intent_bundle_usage
    description: >
      Any capability marked with `requires_intent_bundle: true` must be executed through an IntentBundle flow.
    enforcement: hard

--- END OF FILE .intent/policies/intent_guard.yaml ---

--- START OF FILE .intent/policies/safety_policies.yaml ---
# .intent/policies/safety_policies.yaml
meta:
  version: "0.4.0"
  last_updated: "2025-08-10T11:00:00Z"
  author: "CORE Constitution"
  description: >
    The single source of truth for all security and safety policies governing
    code generation, execution, and self-modification.

rules:
  # ===================================================================
  # RULE: Govern Self-Modification (Immutable Constitution)
  # ===================================================================
  - id: immutable_constitution
    description: >
      The core mission files are immutable and can only be changed via the full,
      human-in-the-loop constitutional amendment process.
    enforcement: manual_review
    applies_to:
      paths:
        - ".intent/mission/principles.yaml"
        - ".intent/mission/manifesto.md"
        - ".intent/mission/northstar.yaml"

  # ===================================================================
  # RULE: No self-modification of core loop
  # ===================================================================
  - id: deny_core_loop_edit
    description: >
      CORE cannot modify its own core orchestration and governance engine
      without explicit human review via the formal amendment process.
    enforcement: manual_review
    applies_to:
      paths:
        - "src/core/main.py"
        - "src/core/intent_guard.py"
        - ".intent/policies/intent_guard.yaml"
        - ".intent/policies/safety_policies.yaml" # The policy cannot edit itself.
    action: require_human_approval
    feedback: |
      ðŸ”’ Core logic modification detected. Human review required before application.

  # ===================================================================
  # RULE: Block dangerous execution primitives (HARDENED)
  # ===================================================================
  - id: no_dangerous_execution
    description: >
      Generated or modified code must not contain calls to dangerous functions
      that enable arbitrary code execution, shell access, or unsafe deserialization.
    enforcement: hard
    scope:
      domains: [core, agents, features]
      exclude:
        - path: "tests/**"
          rationale: "Test files require direct execution for validation"
        - path: "src/core/git_service.py"
          rationale: >
            This file is exempt as it safely uses subprocess.run() without shell=True.
    detection:
      type: regex
      patterns:
        - "eval\\("
        - "exec\\("
        - "compile\\("
        - "os\\.system\\("
        - "os\\.popen\\("
        - "subprocess\\.(run|Popen|call)\\([^)]*shell\\s*=\\s*True"
        - "shutil\\.rmtree\\("
        - "os\\.remove\\("
        - "os\\.rmdir\\("
    action: reject
    feedback: |
      âŒ Dangerous execution detected: '{{pattern}}'. Use safe wrappers or avoid shell=True.


  # ===================================================================
  # RULE: All changes must be logged
  # ===================================================================
  - id: change_must_be_logged
    description: >
      Every file change must be preceded by a log entry in .intent/change_log.json
      with IntentBundle ID and description.
    enforcement: hard
    triggers:
      - before_write
    validator: change_log_checker
    action: reject_if_unlogged
    feedback: |
      âŒ No prior log entry found for this change. Use CHANGE_LOG_PATH to register intent first.

--- END OF FILE .intent/policies/safety_policies.yaml ---

--- START OF FILE .intent/policies/security_intents.yaml ---
security_intents:
  - id: prompt_based_security
    description: "Security rules implemented as LLM prompts"
    enforcement: soft_prompt
    rules:
      - prompt: "Verify no subprocess, eval, or os.system calls"
      - prompt: "Check for safe file operations only"
      - prompt: "Validate no external network calls in core logic"

  - id: security_self_review
    description: "Security improves via self-reflection"
    process:
      - "Generate security concerns as intents"
      - "Review via LLM prompts"
      - "Update security_intents.yaml iteratively"

--- END OF FILE .intent/policies/security_intents.yaml ---

--- START OF FILE .intent/prompts/constitutional_review.prompt ---
You are an expert AI system architect and a specialist in writing clear, machine-readable governance documents.

You will be provided with a "constitutional bundle" from a self-governing software system named CORE. This bundle contains the entire ".intent/" directory, which is the system's "Mind". It defines all of the system's principles, policies, capabilities, and self-knowledge.

Your task is to perform a critical peer review of this constitution. Your goal is to provide actionable suggestions to improve its clarity, completeness, and internal consistency.

Analyze the entire bundle and provide your feedback in the following format:

**1. Overall Assessment:**
A brief, high-level summary of the constitution's strengths and weaknesses.

**2. Specific Suggestions for Improvement:**
Provide a numbered list of specific, actionable suggestions. For each suggestion, you MUST include:
- **File:** The full path to the file that should be changed (e.g., `.intent/mission/principles.yaml`).
- **Justification:** A clear, concise reason explaining WHY this change is an improvement and which core principle it serves (e.g., "This serves the `clarity_first` principle by making the rule less ambiguous.").
- **Proposed Change:** A concrete example of the new content. Use a git-style diff format if possible (lines starting with '-' for removal, '+' for addition).

**3. Gaps and Missing Concepts:**
Identify any potential gaps in the constitution. Are there missing policies, undefined principles, or areas that seem incomplete? For example, is there a policy for data privacy? Is the process for adding new human operators clearly defined?

**Review Criteria:**
- **Clarity:** Is every rule and principle easy to understand for both a human and an LLM? Is there any ambiguity?
- **Completeness:** Does the constitution cover all critical aspects of the system's governance?
- **Consistency:** Are there any conflicting rules or principles?
- **Actionability:** Are the rules specific enough to be automatically enforced?

Begin your review now. The constitutional bundle is provided below.

--- END OF FILE .intent/prompts/constitutional_review.prompt ---

--- START OF FILE .intent/schemas/config_schema.yaml ---
# .intent/schemas/config_schema.yaml
git:
  ignore_validation:
    type: boolean
    default: false
    description: >
      If true, skips Git pre-write checks. MUST be false in production or fallback modes
      to maintain rollback safety. Only for emergency recovery.
--- END OF FILE .intent/schemas/config_schema.yaml ---

--- START OF FILE .intent/schemas/knowledge_graph_entry.schema.json ---
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://core.system/schema/knowledge_graph_entry.json",
  "title": "Knowledge Graph Symbol Entry",
  "description": "Schema for a single symbol (function or class) in the knowledge_graph.json file.",
  "type": "object",
  "required": [
    "key",
    "name",
    "type",
    "file",
    "domain",
    "agent",
    "capability",
    "intent",
    "last_updated",
    "calls",
    "line_number",
    "is_async",
    "parameters",
    "is_class",
    "structural_hash"
  ],
  "properties": {
    "key": { "type": "string", "description": "The unique identifier for the symbol (e.g., 'path/to/file.py::MyClass')." },
    "name": { "type": "string", "description": "The name of the function or class." },
    "type": { "type": "string", "enum": ["FunctionDef", "ClassDef", "AsyncFunctionDef"] },
    "file": { "type": "string", "description": "The relative path to the source file." },
    "domain": { "type": "string", "description": "The logical domain from source_structure.yaml." },
    "agent": { "type": "string", "description": "The inferred agent responsible for this symbol's domain." },
    "capability": { "type": "string", "description": "The high-level capability this symbol provides, or 'unassigned'." },
    "intent": { "type": "string", "description": "A clear, concise statement of the symbol's purpose." },
    "docstring": { "type": ["string", "null"], "description": "The raw docstring from source code." },
    "calls": { "type": "array", "items": { "type": "string" }, "description": "List of other functions called by this one." },
    "line_number": { "type": "integer", "minimum": 0 },
    "is_async": { "type": "boolean" },
    "parameters": { "type": "array", "items": { "type": "string" } },
    "entry_point_type": { "type": ["string", "null"], "description": "Type of entry point if applicable (e.g., 'fastapi_route_post')." },
    "last_updated": { "type": "string", "format": "date-time" },
    "is_class": { "type": "boolean", "description": "True if the symbol is a class definition." },
    "base_classes": {
      "type": "array",
      "items": { "type": "string" },
      "description": "A list of base classes this symbol inherits from (if it is a class)."
    },
    "entry_point_justification": {
      "type": ["string", "null"],
      "description": "The name of the pattern that identified this symbol as an entry point."
    },
    "parent_class_key": {
      "type": ["string", "null"],
      "description": "The key of the parent class, if this symbol is a method."
    },
    "structural_hash": {
      "type": "string",
      "description": "A SHA256 hash of the symbol's structure, ignoring comments and docstrings."
    }
  },
  "additionalProperties": false
}

--- END OF FILE .intent/schemas/knowledge_graph_entry.schema.json ---


--- START OF FILE ./CONTRIBUTING.md ---
# Contributing to CORE

Thank you for joining CORE‚Äôs mission to pioneer self-governing software! Whether you‚Äôre fixing a typo or designing AI agents, your contribution helps shape AI-driven development. This guide makes contributing easy for beginners while providing depth for experts.

---

## Our Philosophy: Principled Contributions

CORE is governed by a **‚Äúconstitution‚Äù** (rules in `.intent/`). Contributions must align with principles like `clarity_first`, making the system easier to understand. Start with these docs:

* **README.md**: Project vision and quick demo.
* **Philosophy** (`docs/01_PHILOSOPHY.md`): Mind-Body-Will architecture.
* **Governance** (`docs/03_GOVERNANCE.md`): Safe change process.

**Key Term**: A **‚Äúconstitutional change‚Äù** updates `.intent/` files (e.g., adding a rule), requiring a signed proposal and audit.

---

## Contribution Workflow

1. **Explore Docs & Issues**
   Read README, Roadmap; find/open an issue.

   ‚Üì

2. **Choose Your Contribution**
   Bugs, Docs, Code, or Governance.

   ‚Üì

3. **Submit via GitHub**
   Fork ‚Üí Branch ‚Üí Code ‚Üí Run `make check` ‚Üí PR.

---

## How to Contribute

### üèõÔ∏è Discuss Architecture & Governance

Shape CORE‚Äôs future by discussing its design or rules:

* **Read the Roadmap**: See `docs/04_ROADMAP.md` for challenges (e.g., CognitiveService for AI roles).
* **Propose Changes**: Suggest new principles or policies via GitHub Issues. Example: Add a policy for API rate limiting in `.intent/policies/safety_policies.yaml`.
* **Why It Matters**: Your ideas advance CORE to **A1 autonomy** (auto-PRs).

---

### üêû Report Bugs

Strengthen the **ConstitutionalAuditor** by reporting issues:

* **Include**: Command run, full error/traceback, your analysis.
* **Example**: ‚ÄúAuditor missed an import in `src/api/`; here‚Äôs the log.‚Äù
* **Beginner Task**: Run `make audit` on a test project and report a missed violation.

---

### ‚úçÔ∏è Improve Documentation

Docs drive **clarity\_first**. Help by:

* Fixing typos or unclear sections.
* Adding examples or diagrams (e.g., for audit flow).
* **Beginner Task**: Clarify a sentence in `docs/09_WORKED_EXAMPLE.md`.

---

### üíª Contribute Code

Code contributions must follow CORE‚Äôs governance.

#### 1. Code Conventions

* **Formatting**: Use `black` (`make format`).
* **Linting**: `ruff` enforces quality (`make check`).
* **Type Hints**: Required for all functions/methods.
* **Docstrings**: Every public module/class/function needs one.
* **Capability Tags**: Add `# CAPABILITY: <name>` for key functions.

#### 2. Architecture Rules

* **Domains**: Defined in `.intent/knowledge/source_structure.yaml` (e.g., `core`, `agents`).
* **Imports**: Only use `allowed_imports` from that file. Propose constitutional changes for new imports.
* **Auditor**: Enforces rules via `make check`.

#### 3. Dependencies

* **Use Poetry**: `poetry add <package>` or `poetry add --group dev <package>`.
* **Install**: `poetry install`.
* **Tip**: Run `poetry shell` if commands fail.

#### 4. Testing

* **Write tests** in `tests/` (unit, integration, governance).
* **Goal**: 80%+ coverage (`poetry run pytest --cov`).
* **Run**: `make test`.
* **Beginner Task**: Add a test for `src/system/tools/symbol_processor.py`.

#### 5. Submission Steps

1. Find/open a GitHub Issue.
2. Fork repo, create branch (e.g., `fix/docstring`).
3. Write code/tests, following conventions.
4. Run checks:

   * `make fast-check`: Linting + unit tests.
   * `make check`: Full audit (**required**).
   * `make format`: Fix formatting.
5. Submit PR, linking to the issue.

**Troubleshooting**:

* Audit failure? Check `reports/drift_report.json`.
* Poetry issues? Verify Python 3.12+ and `.env`.

---

## Example Contributions

* **Beginner**: Add a docstring to `src/system/tools/file_scanner.py`.
* **Intermediate**: Write a test for CognitiveService (Roadmap Phase 2).
* **Advanced**: Implement a new starter kit for a CLI app in `src/system/starter_kits/`.

---

## Why Contribute?

Your work helps CORE evolve from **observing codebases (A0)** to **generating apps autonomously (A4)**.
Be part of the future of safe, AI-driven software!

**Quick Start**: Fix a typo in a doc or add a `# CAPABILITY:` tag, then run `make check`.

---

## Questions?

Ask in **GitHub Issues** or join our **community (TBD)**.
We‚Äôre excited to collaborate!

--- END OF FILE ./CONTRIBUTING.md ---

--- START OF FILE ./README.md ---
# CORE ‚Äî Architectural Integrity for AI-Era Development

CORE ensures your code stays true to your project‚Äôs design, using AI to catch architectural violations and guide safe, governed development.

---

## Why CORE?

Codebases often drift from their intended design:

* New features ignore established patterns.
* Modules import dependencies they shouldn‚Äôt.
* Documentation becomes outdated.
* Reviews miss big-picture issues.

Linters catch syntax errors, but architectural mistakes slip through.
**CORE** uses a **‚Äúconstitution‚Äù** (rules in `.intent/`) and **AI-powered auditing** to keep your project on track.

---

## CORE in 30 Seconds

1. **Set Rules**: Define your project‚Äôs architecture in `.intent/` (e.g., which modules can talk to each other).
2. **Write Code**: Build your app as usual in `src/`.
3. **Audit**: Run `make audit` to check if code follows rules.
4. **Fix**: Get clear feedback with fixes (e.g., *‚ÄúMove this import to a service layer‚Äù*).

### Example Audit Output

```
‚ùå Violation: src/api/user.py
Issue: 'api' imported 'database.models'
Rule: API layer only imports 'services'
Fix: Use UserService for database logic
```

---

## Try It Out (5-Minute Demo)

See CORE in action with the worked example:

1. Create a **‚ÄúQuote of the Day‚Äù API**.
2. Break a rule (e.g., add a forbidden import).
3. Watch CORE catch it and suggest a fix.

üëâ **[Run the Worked Example (`docs/09_WORKED_EXAMPLE.md`)](docs/09_WORKED_EXAMPLE.md)**

---

## Visualizing CORE

CORE‚Äôs **Mind‚ÄìBody‚ÄìWill** model ensures governance:

```
+-----------------+
| Mind (.intent/) | Rules & Principles (YAML/JSON)
+-----------------+
        |
        v
+-----------------+
| Will (AI Agents)| Plans & Generates Code
+-----------------+
        |
        v
+-----------------+
| Body (src/)     | Your Codebase
+-----------------+
        |
        v
[Auditor] Ensures code aligns with rules
```

---

## Project Status & Independent Review

CORE is an **Architectural Prototype (v0.2.0)**, with a stable and functional governance loop. It has been independently reviewed by multiple AI assessors (Grok, ChatGPT) with a strong consensus:

* **Overall Score:** \~7.9 / 10
* **Key Strengths:** Governance & Safety (9/10), Documentation (8.5/10)
* **Next Steps:** Focus is on enhancing the AI reasoning layer and feature completeness.

The reviews confirm that CORE's foundation is exceptionally strong. The full reviews are archived in `docs/reviews/`.

---

## Documentation Portal

* **[What is CORE? (`docs/00_WHAT_IS_CORE.md`)](docs/00_WHAT_IS_CORE.md)** ‚Äî The vision and philosophy.
* **[Architecture (`docs/02_ARCHITECTURE.md`)](docs/02_ARCHITECTURE.md)** ‚Äî Technical details of the Mind and Body.
* **[Governance (`docs/03_GOVERNANCE.md`)](docs/03_GOVERNANCE.md)** ‚Äî How changes are made safely.
* **[Roadmap (`docs/04_ROADMAP.md`)](docs/04_ROADMAP.md)** ‚Äî See where we're going.
* **[Contributing (`CONTRIBUTING.md`)](CONTRIBUTING.md)** ‚Äî Join our mission!

---

## Installation & Quick Start

**Requirements**: Python 3.12+, Poetry, Git

```bash
# Clone and install
git clone https://github.com/DariuszNewecki/CORE.git
cd CORE
poetry install

# Set up environment
cp .env.example .env
# Edit .env with your LLM API keys

# Verify setup is clean
make check

# Try the new conversational command!
poetry run core-admin chat "make me a simple command-line tool that prints a random number"
```

---

## Contributing

We welcome all contributors! The best place to start is our **Contributing Guide**.
Check the **Project Roadmap** for "Next Up" tasks and see our open issues on GitHub.

---

## License

MIT License ‚Äî see `LICENSE`.

--- END OF FILE ./README.md ---

--- START OF FILE ./SECURITY.md ---
# Security Policy

## Supported Versions

Security fixes are provided for the latest minor version release.

| Version | Supported          |
| ------- | ------------------ |
| 0.2.x   | :white_check_mark: |
| < 0.2.0 | :x:                |

## Reporting a Vulnerability

We take all security vulnerabilities seriously. Please do not report security vulnerabilities through public GitHub issues.

Instead, please report them by using GitHub's private vulnerability reporting feature. Go to the "Security" tab of the repository and click "Report a vulnerability".

You should receive an acknowledgment within **3 business days**.

## Disclosure Process

We follow a coordinated disclosure process. Once a vulnerability is reported, we will work to release a patch as quickly as possible. We will publish a security advisory on GitHub to notify users upon release.
--- END OF FILE ./SECURITY.md ---

--- START OF FILE ./docs/00_WHAT_IS_CORE.md ---
# 0. What is CORE? (And Why Should I Care?)

## The Problem: Software Forgets Its Purpose

Traditional software development is a battle against complexity and entropy. Over time, even well-designed systems suffer from:
- **Drift:** The code no longer matches the original design documents.
- **Duplication:** The same logic is written in multiple places because no one knew it already existed.
- **Degradation:** Small fixes and new features slowly erode the architectural integrity.

The **intent**‚Äîthe *why* behind the code‚Äîgets lost.

## The Solution: A System That Remembers

**CORE is a self-governing AI development framework that never forgets its purpose.**

It's not just another code generator. It is a system designed to build other systems, governed by a machine-readable "constitution" that lives alongside the code. Think of it as an AI-powered software architect, lead developer, and QA engineer, all working in perfect sync, guided by a set of explicit rules you define.

**In short: CORE transforms your high-level goals into running, governed software, and ensures it *stays* aligned with your intent as it evolves.**

---

## How It Works: The Mind, Body, and Will

CORE's architecture is a simple trinity:

*   üèõÔ∏è **The Mind (`.intent/`):** The Constitution. This is where you, the human, declare your intent. It contains the principles, architectural rules, and goals for your project. It is the timeless source of truth.

*   ü¶æ **The Body (`src/`):** The Machinery. A set of simple, reliable tools that can write files, run tests, and analyze code. Its job is to act, not to think.

*   üß† **The Will (LLMs):** The Reasoning Layer. An orchestrated set of specialized AI agents that act as the system's "brain." The Will's sole purpose is to read the **Mind** and use the **Body's** tools to make the intent a reality.

This separation is not just a guideline; it's a law enforced by CORE's own "immune system" (`ConstitutionalAuditor`). The Will can *never* take an action that violates the rules laid down in the Mind.

---

## Who Is This For?

CORE is for developers and teams who believe that:
- **Clarity** is more important than cleverness.
- **Governance** isn't bureaucracy; it's a competitive advantage.
- **Traceability** and **safety** are non-negotiable, especially when working with AI.

If you want to build systems that are resilient, auditable, and continuously aligned with their purpose, CORE is for you.

## Next Steps

Now that you understand the *why*, you're ready for the *how*.

1.  **[The CORE Philosophy (`docs/01_PHILOSOPY.md`)](docs/01_PHILOSOPHY.md)** ‚Äî For a deeper dive into the principles.
2.  **[The README (`README.md`)](../README.md)** ‚Äî For instructions on how to get started and run the code.
--- END OF FILE ./docs/00_WHAT_IS_CORE.md ---

--- START OF FILE ./docs/01_PHILOSOPHY.md ---
# The CORE Philosophy

---

## For New Users: What Is CORE?

CORE is like a **‚Äúsmart architect‚Äù** for software: it ensures your code follows your project‚Äôs rules, preventing chaos even when AI writes code.

Think of it as a **city**:

* üèõÔ∏è **Mind** = the plan.
* ü¶æ **Body** = the buildings.
* üß† **Will** = the planners who follow the plan.

üëâ **Try It:** Run the *Worked Example* to see CORE catch a mistake in 5 minutes.

---

## Prime Directive

CORE transforms **human intent into complete, evolving software systems** ‚Äî without drift, duplication, or degradation.

It governs, learns, and rewrites itself using a **machine-readable constitution**, ensuring safe and transparent development.

---

## The Architectural Trinity: Mind, Body, and Will

CORE‚Äôs design separates concerns for **governance and safety**:

* üèõÔ∏è **Mind (`.intent/`)**: YAML/JSON files defining rules and purpose (*what* and *why*).
* ü¶æ **Body (`src/`)**: Simple Python tools for actions (*how*), like writing files.
* üß† **Will (AI Layer)**: AI agents (e.g., Planner) that reason within Mind‚Äôs rules to use Body‚Äôs tools.

### Visual

```mermaid
graph TB
    Mind[üèõÔ∏è Mind: .intent/ Rules]
    Will[üß† Will: AI Agents]
    Body[ü¶æ Body: src/ Code]
    Auditor[Auditor: Checks Compliance]
    Mind --> Will
    Will --> Body
    Body --> Auditor
    Auditor --> Mind
```

**Deep Dive for Experts:** The trinity enforces `separation_of_concerns`.
The **ConstitutionalAuditor** validates Body against Mind, preventing ungoverned AI actions.
See `source_structure.yaml` for domain rules.

---

## The Ten-Phase Loop of Reasoned Action

Every action follows this **deliberate cycle**:

1. **GOAL**: Human request (e.g., *‚ÄúAdd cryptographic signing‚Äù*).
2. **WHY**: Tie to principle (e.g., `safe_by_default`).
3. **INTENT**: Formal plan (machine-readable).
4. **AGENT**: Pick AI role (e.g., Planner).
5. **MEANS**: Check Body‚Äôs tools (e.g., file writing).
6. **PLAN**: Detail steps.
7. **ACTION**: Execute via Body.
8. **FEEDBACK**: Auditor/tests check compliance.
9. **ADAPTATION**: AI fixes errors.
10. **EVOLUTION**: Update Mind‚Äôs knowledge.

üëâ Simplified: It‚Äôs a **‚Äúthink‚Äìplan‚Äìdo‚Äìcheck‚Äù** loop to avoid reckless changes.

### Diagram

```mermaid
graph TD
    A[GOAL] --> B[WHY]
    B --> C[INTENT]
    C --> D[AGENT]
    D --> E[MEANS]
    E --> F[PLAN]
    F --> G[ACTION]
    G --> H[FEEDBACK]
    H --> I[ADAPTATION]
    I --> J[EVOLUTION]
    J --> A
```

---

## Glossary

* **Drift**: Code breaking rules.
* **Constitution**: Rules in `.intent/`.

---

## Troubleshooting

* **Confused by terms?** See **README**.
* **Audit fails?** Run `make check` and check `reports/drift_report.json`.

---

## Takeaways

* CORE ensures **deliberate, safe changes**.
* **Next**: See *Architecture* for technical details.

---

## Contribute

Suggest a new principle in `principles.yaml`! Open an issue.

--- END OF FILE ./docs/01_PHILOSOPHY.md ---

--- START OF FILE ./docs/02_ARCHITECTURE.md ---
# The CORE Architecture

---

## Quick Start for New Users

The **"Mind-Body Problem"** is simple:

* **Rules (Mind)** are separate from **code (Body)** to avoid chaos.
* The **Auditor** checks everything.

üëâ Start with the *Worked Example* to see directories in action.

---

## The Mind-Body Problem, Solved

* **Separation**: Mind for *‚Äúis/should be‚Äù*, Body for *execution*, bridged by **Auditor**.

---

## Anatomy of the Mind (`.intent/`)

Your project's **constitution**:

| Directory       | Purpose    | Key Files                   | Beginner Tip     |
| --------------- | ---------- | --------------------------- | ---------------- |
| `/mission`      | Principles | `principles.yaml`           | High-level goals |
| `/policies`     | Rules      | `safety_policies.yaml`      | Safety checks    |
| `/knowledge`    | Self-map   | `knowledge_graph.json`      | Code inventory   |
| `/constitution` | Processes  | `approvers.yaml`            | Change approvals |
| `/proposals`    | Drafts     | `cr-*.yaml`                 | Proposed updates |
| `/config`       | Env        | `runtime_requirements.yaml` | Setup vars       |
| `/schemas`      | Blueprints | `*.schema.json`             | File formats     |

**For Experts:** `KnowledgeGraphBuilder` uses AST to build graph (parsing ‚Üí extraction ‚Üí hashing).

### Visual Flow

```mermaid
graph LR
    A[Read src/ Files] --> B[AST Parse]
    B --> C[Extract Symbols]
    C --> D[Analyze Metadata]
    D --> E[Tag Capabilities]
    E --> F[Hash Structure]
    F --> G[Generate knowledge_graph.json]
    G --> H[Auditor Uses for Enforcement]
```

---

## Anatomy of the Body (`src/`)

Domains for **separation of concerns**:

| Directory | Domain | Responsibility | Allowed Imports |
| --------- | ------ | -------------- | --------------- |
| `/core`   | core   | App loop, API  | shared, agents  |
| `/agents` | agents | AI roles       | core, shared    |
| `/system` | system | Auditor, CLI   | shared          |
| `/shared` | shared | Utils          | None (base)     |

**Troubleshooting:** Illegal import? Auditor flags it ‚Üí propose fix in `/proposals`.

---

## Takeaways

* **Scalable design**: clear separation of Mind, Body, Auditor.
* **Next**: Governance.

--- END OF FILE ./docs/02_ARCHITECTURE.md ---

--- START OF FILE ./docs/03_GOVERNANCE.md ---
# The CORE Governance Model

---

## For New Users: Safe Changes

CORE evolves like a **government with checks**: you propose changes, sign them, and test them in a *sandbox* (**Canary Check**) to avoid breaking things.

It‚Äôs like updating laws safely.

üëâ **Try It**: Generate a key with:

```bash
core-admin keygen "your.email@example.com"
```

---

## The Guiding Principle: The Canary Check

Before changing `.intent/`, CORE tests changes **in memory**:

* ‚úÖ **Pass**: Apply to live system.
* ‚ùå **Fail**: Reject to avoid damage.

**Analogy:** Like testing a new recipe before serving it.

---

## The Life of a Constitutional Amendment

5 steps to update `.intent/`:

### Visual

```mermaid
graph TD
    A[Proposal in /proposals/] --> B[Sign with core-admin]
    B --> C[Quorum Check]
    C --> D[Approval & Canary]
    D --> E[Ratification]
```

---

### Step 1: Proposal (`.intent/proposals/`)

Create a YAML file (e.g., `cr-rate-limit.yaml`):

```yaml
target_path: .intent/policies/safety_policies.yaml
justification: Add rate limiting for safety.
content: |
  rate_limiting:
    max_requests: 100
```

---

### Step 2: Signing (`core-admin proposals-sign`)

Prove human intent:

```bash
core-admin keygen "your.email@example.com"  # One-time
core-admin proposals-sign cr-rate-limit.yaml
# Output: Signed cr-rate-limit.yaml with key your.email@example.com
```

---

### Step 3: Quorum Verification

Check `approvers.yaml` for signatures needed:

* **Standard**: 1 signature.
* **Critical**: 2+ signatures.

---

### Step 4: Approval & Canary (`core-admin proposals-approve`)

```bash
core-admin proposals-approve cr-rate-limit.yaml
# Output: Canary passed; change ready to apply
```

---

### Step 5: Ratification

* If passed, updates `.intent/`.
* Logs history.

**Deep Dive:** Uses **cryptographic signatures**; quorum from `approvers.yaml`.

---

## Troubleshooting

* **Key error?** Regenerate with `core-admin keygen`.
* **Audit fails?** Check `reports/` logs.

---

## Takeaways

* Safe, **auditable evolution**.
* **Next**: Roadmap for future plans.

---

## Contribute

Propose a **new policy**! See `CONTRIBUTING.md`.

--- END OF FILE ./docs/03_GOVERNANCE.md ---

--- START OF FILE ./docs/04_ROADMAP.md ---
# The CORE Project Roadmap

## For New Users: Where CORE Is Going

CORE is evolving from a system that audits code (**A0**) into a conversational AI architect (**A4**) that builds apps from your ideas.
The foundational governance and the new conversational layer are now complete.
Each phase moves us toward accessible, self-evolving software development, governed by strict rules.

üëâ **You can help!** Check out the **Next Up** phase in the table below for great contribution opportunities.

---

## Preamble: From Foundation to Self-Evolution

* The project has a stable foundation for audits and governance.
* The core logic for the policy-driven AI layer (**Mind/Body/Will**) is implemented.
* With the completion of the conversational chat command, the system can now translate natural language into structured goals.
* Next steps focus on making the system's reasoning more dynamic and optimized.

üìÑ **Historical work:** [`docs/archive/StrategicPlan.md`](docs/archive/StrategicPlan.md)

---

## GitHub Epic: Policy-Driven Cognitive Layer

### The v1.0 Epic: Mind/Body/Will Trinity

**Goal:** Build a self-evolving system that understands non-coders‚Äô ideas and optimizes AI usage without hardcoded limits.

---

## Roadmap Phases

| Phase                    | Challenge                    | Goal                                                           | Status      | Opportunity                                                          | ETA               |
| ------------------------ | ---------------------------- | -------------------------------------------------------------- | ----------- | -------------------------------------------------------------------- | ----------------- |
| 1: Constitution          | Implicit AI roles in code    | Define `cognitive_roles.yaml` for roles like Planner, Coder    | ‚úÖ Completed | Refine roles or propose new specialized agents (e.g., TestWriter).   | Completed Q3 2024 |
| 2: Machinery             | Body has AI logic            | Build simple `CognitiveService` to read roles                  | ‚úÖ Completed | Optimize the CognitiveService for performance or caching.            | Completed Q3 2024 |
| 3: Agents                | Agents use hardcoded clients | Refactor agents to use `CognitiveService`                      | ‚úÖ Completed | Improve the agent reasoning loop in `run_development_cycle`.         | Completed Q3 2024 |
| 4: Cleanup               | Obsolete classes             | Remove old `BaseLLMClient`; update `runtime_requirements.yaml` | ‚è≥ Planned   | A great first-time contributor task to remove `src/core/clients.py`. | Q4 2024           |
| 5: Conversational Access | CLI limits non-coders        | Add `IntentTranslator` agent and core-admin chat command       | ‚úÖ Completed | Improve the `intent_translator.prompt` for more complex queries.     | Completed Q3 2024 |
| 6: Dynamic Deduction     | Static LLM assignments       | Add `DeductionAgent` + policy to optimize LLM choices          | ‚ñ∂Ô∏è Next Up  | Propose `deduction_policy.yaml`; design and code the scoring logic.  | Q1 2025           |

---

## Visual (Mermaid)

```mermaid
graph TD
    A[Phase 1: Define Roles]
    B[Phase 2: Build Service]
    C[Phase 3: Refactor Agents]
    D[Phase 4: Cleanup]
    E[Phase 5: Conversational Access]
    F[Phase 6: Dynamic Deduction]
    G[v1.0: Self-Evolving AI Architect]

    A --> B --> C --> E --> F --> G
    C --> D;

    style A fill:#d4edda,stroke:#5cb85c
    style B fill:#d4edda,stroke:#5cb85c
    style C fill:#d4edda,stroke:#5cb85c
    style E fill:#d4edda,stroke:#5cb85c
    style F stroke:#f0ad4e,stroke-width:2px
```

---

## Future Phases (Post-v1.0)

| Phase              | Goal                                                   | ETA     |
| ------------------ | ------------------------------------------------------ | ------- |
| Web Interface & DB | Evolve CLI to web UI with DB backing for accessibility | Q2 2025 |

---

## Historical Roadmap (v0.2.0, Completed)

* ‚úÖ Scaling Constitution
* ‚úÖ Autonomous MVP
* ‚úÖ Self-Improvement
* ‚úÖ Robustness
* ‚úÖ Architectural Health

---

## Takeaways

* **Phase 5 is complete!** The system now accepts natural language commands.
* The next major feature is **Phase 6**, which will make the system's AI usage *smarter*.
* The project is on track for a **v1.0 release in Q1 2025**.

---

## Contribute

* The immediate focus is **Phase 6: Dynamic Deduction** ‚Äî a fantastic challenge for AI and systems engineers.
* For beginners, **Phase 4: Cleanup** is a perfect, well-defined first issue to tackle.
  ‚úÖ Check GitHub issues to get started!

--- END OF FILE ./docs/04_ROADMAP.md ---

--- START OF FILE ./docs/05_BYOR.md ---
# 5. Bring Your Own Repo (BYOR) Quickstart

## The Guiding Principle: Ingestion Isomorphism

CORE is designed to be impartial. It applies the same rigorous constitutional analysis to any repository that it applies to itself. This principle, known as **Ingestion Isomorphism**, means that CORE can analyze, understand, and help govern any project without special treatment.

This guide will walk you through the process of pointing CORE at an existing repository and generating a starter constitution for it.

## The Goal: See Your Project Through CORE's Eyes

The `core-admin byor-init` command is a powerful introspection tool. It does not modify your code. Its purpose is to:

1. **Analyze** your repository's structure and capabilities.
2. **Infer** a set of domains based on your directory layout.
3. **Propose** a minimal, non-intrusive `.intent/` constitution based on its findings.

This gives you an instant health check and a starting point for bringing your project under CORE's governance.

---

## Step 1: The Safe Dry Run (Read-Only Analysis)

By default, the command runs in a safe, read-only **dry run** mode. It will show you what it would do **without changing a single file**.

**Commands**

```bash
# Analyze the current CORE repository
poetry run core-admin byor-init .

# Analyze a different project on your machine
poetry run core-admin byor-init /path/to/your/other/project
```

**Understanding the output**

The command first builds a Knowledge Graph of the target repository. Then, it shows the content of five constitutional files it proposes to create:

* `source_structure.yaml` ‚Äî A map of your project, with each subdirectory in `src/` treated as a domain.
* `project_manifest.yaml` ‚Äî An inventory of all the `# CAPABILITY` tags it discovered in your code.
* `capability_tags.yaml` ‚Äî A dictionary for you to define and describe each of those capabilities.
* `principles.yaml` ‚Äî A starter set of CORE's philosophical principles.
* `safety_policies.yaml` ‚Äî A starter set of basic safety rules.

---

## Step 2: Applying the Constitution (Write Mode)

Once you‚Äôve reviewed the dry run output and you‚Äôre happy with the proposed constitution, run the command again with the `--write` flag. This will create the `.intent/` directory and all proposed files inside your target repository.

**Command**

```bash
# Apply the starter constitution to the current repository
poetry run core-admin byor-init . --write
```

---

## Step 3: The First Audit

Your target repository is now **CORE-aware**‚Äîit has a nascent "Mind." The next step is to ask CORE to perform its first constitutional audit on the project.

From within the CORE project, configure the auditor to point at the new project. (In a future version, CORE will be able to attach to it directly.) The result is a continuous, automated health check on your project's architectural integrity and alignment with its newly declared principles.

This process is the first step in transforming any repository from a simple collection of code into a governed, self-aware system.

--- END OF FILE ./docs/05_BYOR.md ---

--- START OF FILE ./docs/06_STARTER_KITS.md ---
# ./docs/06\_STARTER\_KITS.md

# 6. Starter Kits & The Philosophy of Intent

## The CORE Partnership

CORE is not a vending machine for code. It is an intelligent partner designed to translate a human's intent into a governed, working software system. This partnership requires two things:

1. **The Human's Responsibility:** Provide a clear, high-level intent‚Äîthe "why" behind the project.
2. **CORE's Responsibility:** Translate that intent into a complete system, asking for clarification and guidance along the way.

If the human provides no intent ("I do not care"), CORE will do nothing. The partnership requires a starting point.

## Starter Kits: Your First Declaration of Intent

To facilitate this partnership, the `core-admin new` command uses **Starter Kits**. A starter kit is not just a collection of template files; it is a **pre-packaged declaration of intent**. It is a way for you to tell CORE about the *kind* of system you want to build from day one.

By choosing a starter kit, you are providing the "minimal viable intent" that CORE needs to begin its work.

### How to Use Starter Kits

When you create a new project, you can specify a `--profile` option. This tells the scaffolder which starter kit to use.

```bash
# Scaffold a new project using the 'default' balanced starter kit
poetry run core-admin new my-new-app --profile default

# Scaffold a project with high-security policies from the start
poetry run core-admin new my-secure-api --profile security
```

If you do not provide a profile, CORE will default to the safest, most balanced option.

## The Life of a Starter Kit

* **Scaffolding:** CORE creates your new project structure and populates the `.intent/` directory with the constitutional files from your chosen starter kit.
* **Ownership:** From that moment on, that constitution is **yours**. It is no longer a template. It is the living "Mind" of your new project.
* **Evolution:** You can (and should) immediately begin to amend and evolve your new constitution to perfectly match your project's unique goals, using the standard proposals workflow.

Starter kits are just the beginning of the conversation, not the end. They are the most effective way to kickstart the CORE partnership and begin the journey of building a truly intent-driven system.

---

# ./README.md

# CORE ‚Äî The Self-Improving System Architect

> **Where Intelligence Lives.**

[![Status: Architectural Prototype](https://img.shields.io/badge/status-architectural%20prototype-blue.svg)](#-project-status)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

CORE is a self-governing, constitutionally aligned AI development framework that can plan, write, validate, and evolve software systems ‚Äî autonomously and safely. It is designed for environments where **trust, traceability, and governance matter**.

---

## üèõÔ∏è Project Status: Architectural Prototype

The core self-governance and constitutional amendment loop is complete and stable. The system can audit and modify its own constitution via a human-in-the-loop, cryptographically signed approval process.

The next phase, as outlined in our **[Strategic Plan](docs/StrategicPlan.md)**, is to expand agent capabilities so CORE can generate and manage entirely new applications based on user intent.

We‚Äôre making the project public now to invite collaboration on this foundational architecture.

---

## üß† What CORE *is*

* üßæ Evolves itself through **declared intent**, not hidden assumptions.
* üõ°Ô∏è Enforces **constitutional rules**, **domain boundaries**, and **safety policies**.
* üå± Creates new, governed applications from **[Starter Kits](docs/06_STARTER_KITS.md)** that capture initial intent.
* üß© Uses a modular agent architecture with a clear separation of concerns.
* üìö Ensures every decision is **documented, reversible, and introspectable**.

---

## ü¶Æ Key Concepts

| Concept                     | Description                                                                              |
| --------------------------- | ---------------------------------------------------------------------------------------- |
| **`.intent/`**              | The ‚Äúmind‚Äù of CORE: constitution, policies, capability maps, and self-knowledge.         |
| **`ConstitutionalAuditor`** | The ‚Äúimmune system,‚Äù continuously verifying code aligns with the constitution.           |
| **`PlannerAgent`**          | Decomposes high-level goals into executable plans.                                       |
| **`core-admin` CLI**        | Human-in-the-loop tool for managing the system's lifecycle.                              |
| **Starter Kits**            | Pre-packaged constitutions that serve as the user's first declaration of intent.         |
| **Canary Check**            | Applies proposed changes to an isolated copy and runs a full self-audit before approval. |
| **Knowledge Graph**         | Machine-readable map of symbols, roles, capabilities, and relationships.                 |

---

## üöÄ Getting Started

1. **Install dependencies**

   ```bash
   poetry install
   ```

2. **Set up environment**

   ```bash
   cp .env.example .env
   # Edit .env with your keys/URLs. See .intent/config/runtime_requirements.yaml for required variables.
   ```

3. **Run a full self-audit**

   ```bash
   make audit
   ```

---

## üßë‚Äç‚öñÔ∏è Human-in-the-Loop (CLI)

The `core-admin` CLI is your primary tool for guiding the system.

### Creating New Projects

```bash
# Create a new, governed application using a starter kit
core-admin new my-new-app --profile default
```

### Onboarding Existing Projects

```bash
# Analyze an existing repo and propose a starter constitution
core-admin byor-init /path/to/existing-repo
```

### Managing the Constitution

```bash
# List pending constitutional changes
core-admin proposals-list

# Sign a proposal with your key
core-admin proposals-sign cr-example.yaml

# Approve a proposal (runs a canary self-audit)
core-admin proposals-approve cr-example.yaml
```

> If `core-admin` isn‚Äôt found, try: `poetry run core-admin ...`

---

## üå± Contributing

We welcome contributions from AI engineers, DevOps pros, and governance experts.

* See **CONTRIBUTING.md** to get started.
* Check the **Strategic Plan** for where we're headed.

---

## üìÑ License

Licensed under the MIT License. See **LICENSE**.

--- END OF FILE ./docs/06_STARTER_KITS.md ---

--- START OF FILE ./docs/07_PEER_REVIEW.md ---
# 7. Constitutional Peer Review

## The Principle: Proactive Self-Improvement

A core principle of CORE is that a system must not only govern itself but also actively seek to improve its own governance. The Constitutional Peer Review feature is the primary mechanism for this proactive self-improvement.

It answers the question: **"Is our constitution the best it can be?"**

This process allows CORE to leverage powerful, external Large Language Models (LLMs) as expert consultants. It can ask for a "second opinion" on its own principles, policies, and structure, identifying gaps, ambiguities, or potential improvements that it might not be able to see on its own.

## The Workflow: A Safe, Human-in-the-Loop Process

The peer review process is designed to be fundamentally safe, keeping the human operator in full control of any resulting changes. The external LLM can only **suggest**; it can never **act**.

---

### Step 1: Exporting the Constitutional Bundle

The first step is to package the system's entire "Mind" (`.intent/` directory) into a single, portable file that an LLM can analyze.

**Command:**

```bash
poetry run core-admin review export
```

This command reads your `meta.yaml` to discover all constitutional files and bundles them into `reports/constitution_bundle.txt`. This is useful for manual inspection or for sending to different AI models.

---

### Step 2: Requesting the Peer Review

The main command automates the bundling and review request in a single step.

**Command:**

```bash
poetry run core-admin review peer-review
```

**What this command does:**

* Performs the same **export** process internally to create the constitutional bundle.
* Loads a specialized set of instructions from `.intent/prompts/constitutional_review.prompt`.
* Sends the bundle and the instructions to the Orchestrator LLM configured in your `.env` file.
* Saves the AI's detailed feedback as a Markdown file to `reports/constitutional_review.md`.

---

### Step 3: Taking Action on the Feedback

The output report is a set of suggestions for the human operator. It is your responsibility to review this feedback and decide what to act on.

* A strong piece of feedback from the review (e.g., *"The policy for secrets management is incomplete"*) should be transformed into a new item on the **Project Roadmap** or a formal **constitutional amendment proposal** (`.intent/proposals/cr-*.yaml`).
* This loop allows CORE to use external intelligence to evolve its own constitution **without ever sacrificing** the safety and control of its human-in-the-loop governance model.

--- END OF FILE ./docs/07_PEER_REVIEW.md ---

--- START OF FILE ./docs/08_CONTEXT_AND_COMPARISONS.md ---
# 8. Context and Comparisons

This document provides context for the CORE project by answering two key questions:
1.  What does a "governed application" built by CORE actually look like?
2.  How does CORE compare to other AI development tools?

## 1. What a "Governed Application" Looks Like

When you run `core-admin new my-app`, CORE doesn't just generate code. It creates a complete, self-contained, and **governed** project ecosystem.

Here‚Äôs what that means in practice:

*   **A Standardized Structure:** Your new project will have a clean, predictable layout (`src/`, `tests/`, `pyproject.toml`, etc.), making it easy for any developer to understand.

*   **A Nascent "Mind":** Most importantly, your new project gets its own `.intent/` directory. This is its constitution, seeded from a **Starter Kit**. It contains:
    *   `principles.yaml`: High-level values for your project.
    *   `source_structure.yaml`: The architectural rules for your codebase.
    *   `project_manifest.yaml`: A list of the capabilities your application is expected to have.
    *   `safety_policies.yaml`: Basic security rules to prevent unsafe code.

*   **An "Immune System" Ready to Go:** The new project is generated with a GitHub Actions CI workflow (`ci.yml`) that runs `black`, `ruff`, and `pytest` on every commit. It is CORE-aware and ready for you to add a `make audit` step to continuously check its constitutional alignment.

A "governed application" is one where the rules are not just in a wiki page; they are in a machine-readable format that an AI partner (like CORE) can understand, enforce, and even help you evolve.

---

## 2. How CORE Compares to Other Tools

CORE is often compared to other AI-assisted development tools. Here‚Äôs how it‚Äôs different.

| Tool | Primary Function | Core Paradigm |
| :--- | :--- | :--- |
| **GitHub Copilot / Cursor** | **Autocompletion & In-IDE Chat** | An AI assistant *for the developer*. It helps you write code faster by suggesting lines and functions. It has no knowledge of your project's overall architecture or long-term goals. |
| **AutoGPT / Agent Swarms** | **Autonomous Task Execution** | An AI agent that attempts to achieve a goal by breaking it down and executing steps. It is powerful but often unconstrained, with a high risk of producing incorrect, unsafe, or unmaintainable code. |
| **CORE** | **Governed System Architecture** | An AI partner *for the entire system*. CORE's primary job is not just to write code, but to ensure that all code‚Äîwhether written by an AI or a human‚Äîremains in perfect alignment with a declared set of architectural and philosophical rules. |

**The Key Difference is Governance.**

-   Copilot is a **keyboard**. It makes you a faster typist.
-   AutoGPT is an **unsupervised intern**. It has a lot of energy but no discipline.
-   CORE is an **AI architect**. It helps you design the blueprint, then ensures everyone on the team (including other AIs) builds according to that blueprint.

CORE is designed for environments where **long-term maintainability, safety, and architectural integrity** are more important than the raw speed of code generation.
--- END OF FILE ./docs/08_CONTEXT_AND_COMPARISONS.md ---

--- START OF FILE ./docs/09_WORKED_EXAMPLE.md ---
# Worked Example: Your First Governed Application

‚è±Ô∏è **Time: \~5 minutes**

---

## For New Users: See CORE in Action

This demo creates a **‚ÄúQuote of the Day‚Äù API**, breaks a rule, and shows CORE fixing it.
No experience needed ‚Äî just follow the commands!

---

## Step 1: Create a New Application

From CORE root:

```bash
poetry run core-admin new quote-api --profile default
# Output: Created work/quote-api/
```

**What Happens:** Builds `work/quote-api/` with `.intent/` (rules) and `src/` (code).

---

## Step 2: See the Generated "Mind"

Check `work/quote-api/.intent/source_structure.yaml`:

```yaml
structure:
  - domain: main
    path: src/main
    allowed_imports: [shared]
```

**Meaning:** `main` domain can only import `shared`.

---

## Step 3: Intentionally Violate the Constitution

Edit `work/quote-api/src/main/api.py`:

```python
# src/main/api.py
import os  # ‚ùå Forbidden import!

def log_quote_to_disk(quote: str):
    """Log a quote to disk."""
    with open("/tmp/quotes.log", "a") as f:
        f.write(quote + "\n")
```

**Why Wrong?** File I/O belongs in a **services domain**.

üí° *Screenshot Note*: Visualize this in your editor ‚Äî `api.py` now has an error.

---

## Step 4: Run the Constitutional Audit

```bash
poetry run core-admin byor-init work/quote-api
```

**Output:**

```
[ERROR] üö® Domain Violation
File: src/main/api.py
Problem: Imported 'os' (not in allowed_imports)
Rule: 'main' only imports 'shared'
```

---

## The Value Proposition

CORE catches **architectural mistakes early**, unlike linters.

**For experts:** Integrate with CI via `make audit`.

---

## Troubleshooting

* **Command fails?** Use `poetry shell` or check `.env` for keys.
* **No errors?** Verify `reports/drift_report.json`.

---

## Takeaways

* Automated **governance saves time**.
* **Next**: Try **BYOR** on your project.

---

## Contribute

Add a **test for this scenario**! See `CONTRIBUTING.md`.

--- END OF FILE ./docs/09_WORKED_EXAMPLE.md ---

--- START OF FILE ./docs/NORTH_STAR.md ---
# CORE North Star

**Goal:** Turn high-level goals into governed, safe, running software ‚Äî autonomously.

**Invariant:** Safety never degrades. Every change is proven aligned to intent before it lands (policies, tests, canary audit).

## The Autonomy Ladder

- **A0 ¬∑ Observe** ‚Äî Attach to any repo, build knowledge graph, run auditor (read-only).
- **A1 ¬∑ Propose** ‚Äî Open PRs with small, safe fixes (docstrings, capability tags, logging). Human merges.
- **A2 ¬∑ Governed Writes** ‚Äî Canary-validated changes self-apply with policy (human optional by risk tier).
- **A3 ¬∑ BYOR** ‚Äî CORE-fy arbitrary repos (including CORE), propose structure, capabilities, tests.
- **A4 ¬∑ Birth New Apps** ‚Äî From a goal, scaffold feature-first app (Mind/Body), tests, CI/CD.
- **A5 ¬∑ Continuous Intent Dev** ‚Äî Roadmap evolves in natural language; CORE plans, implements, releases within risk budgets.

## Guardrails
- **Risk tiers:** auto-merge only for low-risk scopes at first.
- **Evidence gates:** static policies + tests + canary must pass.
- **Idempotence:** ingestion produces stable results; re-runs don‚Äôt thrash.
- **Kill switch:** rollback on anomaly/error-budget breach.

## KPIs
- Auditor errors/warnings ‚Üí sustained zero
- % code with capability tags
- Proposal acceptance rate / MTTR
- % PRs generated by CORE
- % no-human releases by risk tier
- Post-merge incident rate

## Current Status
- Project status: **Architectural Prototype**.
- Targeting **M1 (A0‚ÜíA1)**: CORE overlay, CI audit, auto-PRs for docstrings/tags/logging.

--- END OF FILE ./docs/NORTH_STAR.md ---

--- START OF FILE ./docs/releases/v0.2.0.md ---
# v0.2.0 ‚Äî MVP: Autonomous Application Generation (2025-08-15)

**Highlights**
- First MVP that can autonomously scaffold a governed application from a high-level goal.
- Nightly constitutional audit + capability drift checks in CI.
- Starter Kit: default profile shipped.
- CLI: `core-admin new`, `core-admin agent scaffold`, `core-admin proposals ...`.

**Upgrade notes**
- Use Python 3.11+.
- Install with `poetry install`.
- Run checks locally: `black --check . && ruff check . && pytest`.

--- END OF FILE ./docs/releases/v0.2.0.md ---


--- START OF FILE ./CONTRIBUTING.md ---
# Contributing to CORE

First off, thank you for considering a contribution. CORE is an ambitious project exploring a new frontier of self-governing software, and every contribution ‚Äî from a simple bug report to a deep philosophical discussion ‚Äî is incredibly valuable.

This document provides a guide for how you can get involved.

## The Philosophy: Principled Contributions

CORE is a system governed by a constitution. We ask that all contributions align with the principles laid out in our foundational documents. Before diving into code, we highly recommend reading the core docs in order:

1.  **[What is CORE? (`docs/00_WHAT_IS_CORE.md`)](docs/00_WHAT_IS_CORE.md)** ‚Äî The high-level purpose and value proposition.
2.  **[The CORE Philosophy (`docs/01_PHILOSOPHY.md`)](docs/01_PHILOSOPHY.md)** ‚Äî The principles and architecture.
3.  **[The Governance Model (`docs/03_GOVERNANCE.md`)](docs/03_GOVERNANCE.md)** ‚Äî The process for safe, constitutional change.

The most important principle for contributors is `clarity_first`. Every change should make the system easier to understand, not harder.

---

## How You Can Contribute

There are many ways to contribute, and many of them don't involve writing a single line of code.

### üèõÔ∏è Discussing Architecture and Governance

The most valuable contributions at this stage are discussions about the core architecture and governance model.

-   **Review our Roadmap:** Read our **[Project Roadmap (`docs/04_ROADMAP.md`)](docs/04_ROADMAP.md)**. Find a challenge that interests you and share your thoughts.
-   **Propose a Constitutional Change:** If you believe a principle or policy could be improved, open an issue to discuss it. The health of the system's "Mind" is our top priority.

### üêû Reporting Bugs

If you find a bug or a constitutional inconsistency, please open an issue. A great bug report includes:
-   The command you ran.
-   The full output, including the error and traceback.
-   Your analysis of why you think it's happening.

Our goal is for the system‚Äôs `ConstitutionalAuditor` to catch all inconsistencies. If you find one it missed, you‚Äôve found a valuable way to make our immune system stronger!

### ‚úçÔ∏è Improving Documentation

If you find a part of our documentation confusing, unclear, or incomplete, a pull request to improve it is a massive contribution. Clear documentation is vital for the project's health and aligns with our `clarity_first` principle.

---

## üíª Contributing Code

If you'd like to contribute code, please follow these steps.

### 1. Code Conventions

To uphold the `clarity_first` principle, all code submitted to CORE must adhere to these standards:

-   **Formatting:** All Python code is formatted with `black`. Our linter, `ruff`, is configured to follow `black`'s style. You can auto-format all code by running `make format`.
-   **Linting:** We use `ruff` to enforce code quality and best practices.
-   **Typing:** All functions and methods must have type hints.
-   **Docstrings:** Every public module, class, function, and method must have a docstring explaining its purpose.

### 2. Architectural Principles

To uphold the `separation_of_concerns` principle, the codebase is divided into strict architectural domains.

-   **Domain Definitions:** The domains and their responsibilities are defined in `.intent/knowledge/source_structure.yaml`.
-   **Import Rules:** A domain may only import from other domains listed in its `allowed_imports` list within that file. The `ConstitutionalAuditor` strictly enforces these boundaries. Before adding a new cross-domain import, you must first propose a change to the constitution.

### 3. Dependency Management

The project uses [Poetry](https://python-poetry.org/) to manage dependencies.

-   **Adding a dependency:** Use `poetry add <package_name>`.
-   **Adding a dev dependency:** Use `poetry add --group dev <package_name>`.
-   **Installation:** All dependencies are specified in `pyproject.toml` and locked in `poetry.lock`. A new contributor only needs to run `poetry install`.

### 4. The Submission Workflow

1.  Find an open issue that you'd like to work on (or open a new one for discussion).
2.  Fork the repository and create a new branch.
3.  **Write the code.** Ensure your code adheres to the conventions listed above.
4.  **Run the checks.** This is a critical step to ensure your contribution is constitutionally compliant.
    - For quick, iterative checks while you work, run `make fast-check`. This will handle linting and unit tests.
    - Before submitting, you **MUST** run the full suite, which includes the constitutional self-audit.
    ```bash
    make check
    ```
    If you have formatting issues, you can run `make format` to fix them automatically.
5.  Submit a pull request.

---

We are excited to build this new future for software development with you.
--- END OF FILE ./CONTRIBUTING.md ---

--- START OF FILE ./README.md ---
# CORE ‚Äî The Self-Improving System Architect

> **Where Intelligence Lives.**

[![Latest release](https://img.shields.io/github/v/release/DariuszNewecki/CORE?sort=semver)](https://github.com/DariuszNewecki/CORE/releases)
![Status: MVP Achieved](https://img.shields.io/badge/status-MVP%20achieved-brightgreen.svg)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

---

## üü¢ Project Status: **MVP v0.2.0** (released 2025-08-15)

CORE has reached its first major milestone: it can **autonomously scaffold a new, governed software application from a high-level goal** and continuously verify its architectural integrity against a formal constitution.

* **Stable Release:** The `v0.2.0` release is available on the `release/v0.2.0` branch. This is the recommended starting point for new users.
* **Active Development:** The `main` branch is now focused on a major architectural evolution to the **Mind/Body/Will** model.

---

## üé• 90-second Demo

[![Watch the 90-second demo](docs/assets/core-90s-demo.gif)](docs/assets/core-90s-demo.gif)

> The GIF shows: `core-admin new` ‚Üí `guard drift` on a fresh repo.

---

## What is CORE?

CORE is a **self-governing, constitution-aligned AI development framework**.
It plans, writes, validates, and evolves software systems ‚Äî **autonomously, with traceability and guardrails.**

### The Architectural Trinity: Mind, Body, and Will

CORE is built on a foundational trinity that separates purpose, action, and reasoning:

* üèõÔ∏è **The Mind (`.intent/`):** The declarative constitution. It holds the principles, policies, and knowledge of what the system *is* and *should be*. It is the source of truth.
* ü¶æ **The Body (`src/`):** The executable machinery. A set of simple, reliable tools (file writers, test runners, linters) that act upon the world.
* üß† **The Will (LLMs):** The reasoning layer. An orchestrated set of specialized AI agents that interpret the Mind's intent and wield the Body's tools to achieve goals.

```mermaid
graph TD
    subgraph Mind["Mind: The Constitution (.intent/)"]
        A[Principles & Policies]
    end
    subgraph Will["Will: The Reasoning (LLMs)"]
        B[Cognitive Roles]
    end
    subgraph Body["Body: The Machinery (src/)"]
        C[Tools & Capabilities]
    end

    A -- "Provides Intent To" --> B
    B -- "Uses Tools From" --> C
    C -- "Acts & Gathers Feedback For" --> B
```

---

## üöÄ Quickstart (90 seconds)

> Requires **Python 3.11+** and **Poetry**.

```bash
# 1) Clone the repository and check out the stable release
git clone https://github.com/DariuszNewecki/CORE.git
cd CORE
git checkout release/v0.2.0

# 2) Install dependencies
poetry install

# 3) Run all checks (format, lint, tests, self-audit)
make check

# 4) Generate a governed starter application
poetry run core-admin new my_governed_app
```

---

## ‚ú® Key Capabilities (v0.2.0 MVP)

* Autonomous scaffolding from high-level intent (`core-admin new`).
* Constitutional self-audit against rules in `.intent/`.
* Capability drift detection (maps `# CAPABILITY:` tags in code to manifests).
* CI/CD pipeline for formatting, linting, testing, and nightly governance checks.

---

## üõ£Ô∏è Roadmap

The historical roadmap leading to **v0.2.0** is now complete.
Our future work is focused on a single epic: evolving CORE into a true reasoning system.

* **v1.0 ‚Äî The Reasoning System:** Refactor the system to use a policy-driven, role-based cognitive layer (the "Will"), making its intelligence governable by the constitution.

‚û°Ô∏è Track progress in the [v1.0 Milestone](https://github.com/DariuszNewecki/CORE/milestone/1) and the full [Project Roadmap](docs/04_ROADMAP.md).

---

## ü§ù Contributing

We welcome focused, high-quality contributions to our next evolution on the `main` branch.

* Read [CONTRIBUTING.md](CONTRIBUTING.md).
* Review our [Roadmap](docs/04_ROADMAP.md).
* Use **Conventional Commits** (`feat:`, `fix:`, `chore:`, ‚Ä¶).

---

## üîí Security

Please report vulnerabilities **privately**.
See [SECURITY.md](SECURITY.md) for the disclosure process.

---

## üìÑ License

MIT ‚Äî see [LICENSE](LICENSE).

---

--- END OF FILE ./README.md ---

--- START OF FILE ./SECURITY.md ---
# Security Policy

## Supported Versions

Security fixes are provided for the latest minor version release.

| Version | Supported          |
| ------- | ------------------ |
| 0.2.x   | :white_check_mark: |
| < 0.2.0 | :x:                |

## Reporting a Vulnerability

We take all security vulnerabilities seriously. Please do not report security vulnerabilities through public GitHub issues.

Instead, please report them by using GitHub's private vulnerability reporting feature. Go to the "Security" tab of the repository and click "Report a vulnerability".

You should receive an acknowledgment within **3 business days**.

## Disclosure Process

We follow a coordinated disclosure process. Once a vulnerability is reported, we will work to release a patch as quickly as possible. We will publish a security advisory on GitHub to notify users upon release.
--- END OF FILE ./SECURITY.md ---

--- START OF FILE ./docs/00_WHAT_IS_CORE.md ---
# 0. What is CORE? (And Why Should I Care?)

## The Problem: Software Forgets Its Purpose

Traditional software development is a battle against complexity and entropy. Over time, even well-designed systems suffer from:
- **Drift:** The code no longer matches the original design documents.
- **Duplication:** The same logic is written in multiple places because no one knew it already existed.
- **Degradation:** Small fixes and new features slowly erode the architectural integrity.

The **intent**‚Äîthe *why* behind the code‚Äîgets lost.

## The Solution: A System That Remembers

**CORE is a self-governing AI development framework that never forgets its purpose.**

It's not just another code generator. It is a system designed to build other systems, governed by a machine-readable "constitution" that lives alongside the code. Think of it as an AI-powered software architect, lead developer, and QA engineer, all working in perfect sync, guided by a set of explicit rules you define.

**In short: CORE transforms your high-level goals into running, governed software, and ensures it *stays* aligned with your intent as it evolves.**

---

## How It Works: The Mind, Body, and Will

CORE's architecture is a simple trinity:

*   üèõÔ∏è **The Mind (`.intent/`):** The Constitution. This is where you, the human, declare your intent. It contains the principles, architectural rules, and goals for your project. It is the timeless source of truth.

*   ü¶æ **The Body (`src/`):** The Machinery. A set of simple, reliable tools that can write files, run tests, and analyze code. Its job is to act, not to think.

*   üß† **The Will (LLMs):** The Reasoning Layer. An orchestrated set of specialized AI agents that act as the system's "brain." The Will's sole purpose is to read the **Mind** and use the **Body's** tools to make the intent a reality.

This separation is not just a guideline; it's a law enforced by CORE's own "immune system" (`ConstitutionalAuditor`). The Will can *never* take an action that violates the rules laid down in the Mind.

---

## Who Is This For?

CORE is for developers and teams who believe that:
- **Clarity** is more important than cleverness.
- **Governance** isn't bureaucracy; it's a competitive advantage.
- **Traceability** and **safety** are non-negotiable, especially when working with AI.

If you want to build systems that are resilient, auditable, and continuously aligned with their purpose, CORE is for you.

## Next Steps

Now that you understand the *why*, you're ready for the *how*.

1.  **[The CORE Philosophy (`docs/01_PHILOSOPHY.md`)](docs/01_PHILOSOPHY.md)** ‚Äî For a deeper dive into the principles.
2.  **[The README (`README.md`)](../README.md)** ‚Äî For instructions on how to get started and run the code.
--- END OF FILE ./docs/00_WHAT_IS_CORE.md ---

--- START OF FILE ./docs/01_PHILOSOPHY.md ---
# 1. The CORE Philosophy

## Prime Directive

**CORE exists to transform human intent into complete, evolving software systems ‚Äî without drift, duplication, or degradation.**

It does not merely generate code; it **governs**, **learns**, and **rewrites** itself under the authority of an explicit, machine-readable constitution. It is a system designed to build other systems, safely and transparently.

---

## The Architectural Trinity: Mind, Body, and Will

Our architecture is founded on a strict separation of concerns that mirrors a reasoned entity. This trinity ensures that the system's intelligence is always governed by its principles, and its actions are always simple, auditable, and safe.

*   üèõÔ∏è **The Mind (`.intent/`):** The Constitution. A declarative, version-controlled collection of files representing the system's complete self-knowledge, purpose, and rules. It is the timeless source of truth for **what** the system should be and **why**.

*   ü¶æ **The Body (`src/`):** The Machinery. An imperative, executable collection of simple tools. Its capabilities are modest and reliable: writing files, running tests, parsing code. It handles the **how** of interacting with the world. We do not build smart tools; we build simple tools that a smart, constitutionally-bound Will can use.

*   üß† **The Will (The LLM Layer):** The Reasoning. An orchestrated set of specialized AI cognitive roles. The Will is the dynamic, intelligent actor in the system. It is not part of the Body's code; it is the cognitive force that interprets the Mind's intent to wield the Body's tools.

---

## The Ten-Phase Loop of Reasoned Action

All autonomous actions in CORE are governed by a ten-phase loop. This structure ensures that every action is deliberate, justified, traceable, and validated against the constitution. It prevents the system from taking impulsive or un-auditable shortcuts.

1.  **GOAL:** A high-level objective is received from a human operator.
    *(e.g., "Add cryptographic signing to the approval process.")*

2.  **WHY:** The system's **Will** links the goal to a core principle in the **Mind**.
    *(e.g., "This serves the `safe_by_default` principle.")*

3.  **INTENT:** The goal and its justification are formalized into a clear, machine-readable intent.
    *(e.g., Formalize the request into a plan to modify the `core-admin` tool.)*

4.  **AGENT:** The **Will** selects the appropriate cognitive role(s) for the task.
    *(e.g., The `Planner` and `Coder` roles are assigned.)*

5.  **MEANS:** The selected agent consults the capabilities of the **Body**.
    *(e.g., The agent knows the Body has `code_generation` and `introspection` tools.)*

6.  **PLAN:** The agent produces a detailed, auditable plan.
    *(e.g., 1. Add `cryptography` library. 2. Add `keygen` function. 3. Modify `approve` function...)*

7.  **ACTION:** The **Will** commands the **Body** to execute the plan, one step at a time.
    *(e.g., The `FileHandler` tool writes new code to files.)*

8.  **FEEDBACK:** The **Body's** "immune system" (`ConstitutionalAuditor`, `pytest`) provides feedback.
    *(e.g., "The new code fails a linting check." or "All tests pass.")*

9.  **ADAPTATION:** The **Will** uses the feedback to self-correct or confirm the change.
    *(e.g., The `Refactorer` role fixes the linting error, or the `GitService` tool commits the successful change.)*

10. **EVOLUTION:** The **Mind** is updated (`KnowledgeGraph`) to reflect the new state, completing the loop.

This loop ensures that CORE does not simply act, but *reasons*. Every change is a deliberate, auditable, and constitutionally-aligned evolution.
--- END OF FILE ./docs/01_PHILOSOPHY.md ---

--- START OF FILE ./docs/02_ARCHITECTURE.md ---
# 2. The CORE Architecture

## The Mind-Body Problem, Solved

The central architectural pattern in CORE is a strict separation between the system's "Mind" and its "Body."

-   **The Mind (`.intent/`):** A declarative, version-controlled, and human-readable collection of files that represents the system's complete self-knowledge, purpose, and rules. It is the single source of truth for what the system *is* and *should be*.
-   **The Body (`src/`):** An imperative, executable collection of Python modules that acts upon the world. Its sole purpose is to carry out the will of the Mind, and its every action is governed by the rules declared within the Mind.

This separation is not just a convention; it is a constitutional law enforced by the system itself. The `ConstitutionalAuditor` is the bridge between the two, constantly ensuring the Body is in perfect alignment with the Mind.

## The Anatomy of the Mind (`.intent/`)

The `.intent/` directory is structured to provide a complete and transparent view of the system's governance.

| Directory | Purpose | Key Files |
|---|---|---|
| **`/mission`** | **The Constitution's Soul:** High-level, philosophical principles. | `principles.yaml`, `northstar.yaml` |
| **`/policies`** | **The Constitution's Laws:** Specific, machine-readable rules that govern agent behavior. | `safety_policies.yaml`, `intent_guard.yaml` |
| **`/knowledge`** | **The System's Self-Image:** Declarative knowledge about the system's own structure. | `knowledge_graph.json`, `source_structure.yaml` |
| **`/constitution`** | **The Machinery of Governance:** Defines the human operators and processes for changing the constitution. | `approvers.yaml` |
| **`/proposals`** | **The Legislative Floor:** A safe, temporary "sandbox" for drafting and signing proposed constitutional changes. | `cr-*.yaml` |
| **`/config`** | **Environmental Awareness:** Declares the system's dependencies on its runtime environment. | `runtime_requirements.yaml` |
| **`/schemas`** | **The Blueprint:** JSON schemas that define the structure of the knowledge files. | `knowledge_graph_entry.schema.json` |

## The Anatomy of the Body (`src/`)

The `src/` directory is organized into strict architectural **domains**. These domains are defined in `.intent/knowledge/source_structure.yaml`, and cross-domain communication is tightly controlled by rules enforced by the `ConstitutionalAuditor`.

| Directory | Domain | Responsibility |
|---|---|---|
| **`/core`** | `core` | The central nervous system. Handles the main application loop, API, and core services like file handling and Git integration. |
| **`/agents`** | `agents` | The specialized AI actors. Contains the `PlannerAgent` and its related models and utilities. |
| **`/system`** | `system` | The machinery of self-governance. Contains the `ConstitutionalAuditor`, `core-admin` CLI, and introspection tools. |
| **`/shared`** | `shared` | The common library. Provides shared utilities like logging and configuration loading that are accessible by all other domains. |

## The Flow of Knowledge: From Code to Graph

The system's self-awareness is not magic; it is a deliberate, mechanical process. The `KnowledgeGraphBuilder` tool is responsible for reading the entire `src/` directory and producing the `knowledge_graph.json` artifact.

This process involves:
1.  **AST Parsing:** The builder reads every Python file and parses it into an Abstract Syntax Tree.
2.  **Symbol Extraction:** It walks the tree to identify every class, function, and method.
3.  **Metadata Analysis:** For each symbol, it extracts its name, parameters, docstring (intent), and relationships (function calls).
4.  **Capability Tagging:** It inspects the comments above each symbol for `# CAPABILITY:` tags to understand its high-level purpose.
5.  **Structural Hashing:** It generates a unique "fingerprint" of each symbol's logic, allowing for perfect duplicate code detection.

The resulting `knowledge_graph.json` is the Mind's complete and accurate "map" of the Body, which the `ConstitutionalAuditor` then uses to enforce all architectural rules.
--- END OF FILE ./docs/02_ARCHITECTURE.md ---

--- START OF FILE ./docs/03_GOVERNANCE.md ---
# 3. The CORE Governance Model

CORE's ability to evolve its own constitution is its most powerful and most dangerous capability. To ensure this process is safe, auditable, and aligned with human intent, it is governed by a strict, multi-stage **Constitutional Amendment Process**.

This process is designed to solve the central paradox of self-modification: **how can a system safely approve a change that might break its own ability to approve changes?**

## The Guiding Principle: The Canary Check

The entire process is built around a single, foolproof safety mechanism: the **"Canary" Check**.

Before any change is applied to the live constitution, the system performs a "what-if" simulation. It creates a temporary, isolated copy of itself in memory, applies the proposed change to this "canary," and then commands the canary to run a full self-audit.

* If the canary, operating under the new proposed rules, reports a perfect, error-free audit, the change is deemed safe and is automatically applied to the live system.
* If the canary's audit fails, it proves the change would create a broken or inconsistent state. The proposal is automatically rejected, and the live system is never touched.

This mechanism ensures that CORE can never approve an amendment that would render it unable to govern itself.

## The Life of a Constitutional Amendment

A change to any file within the `.intent/` directory follows a formal, five-step lifecycle.

### Step 1: Proposal (`.intent/proposals/`)

An AI agent or a human developer determines that a constitutional change is needed. They do not edit the target file directly. Instead, they create a formal **proposal file** in the `.intent/proposals/` directory.

This proposal is a YAML file containing:

* `target_path`: The file to be changed.
* `justification`: A human-readable reason for the change.
* `content`: The full proposed new content of the file.

### Step 2: Signing (`core-admin proposals-sign`)

Constitutional changes require formal, cryptographic proof of human intent. A human operator uses the `core-admin` tool to sign the proposal with their private key.

```bash
# Generate a personal key pair (one-time setup)
core-admin keygen "your.name@example.com"

# Sign a pending proposal
core-admin proposals-sign cr-new-capability.yaml
```

This action adds a verifiable signature to the proposal file.

### Step 3: Quorum Verification

The system checks `.intent/constitution/approvers.yaml` to determine how many signatures are required (the "quorum").

* Standard changes (like adding a capability) might require only one signature.
* Critical changes (like modifying the approver list itself) require a higher quorum, such as two or more signatures.

### Step 4: Approval & The Canary Check (`core-admin proposals-approve`)

Once a proposal has a sufficient number of valid signatures, any authorized operator can initiate the final approval.

```bash
core-admin proposals-approve cr-new-capability.yaml
```

This command triggers the automated canary check. The operator watches the log as the system simulates the change and runs its self-audit.

### Step 5: Ratification

If the canary check passes, the change is automatically applied to the live `.intent/` directory. The original proposal file is deleted, and the system now operates under its new, evolved constitution. The entire transaction is recorded in an auditable history log.

This rigorous process ensures that every change to CORE's "mind" is deliberate, secure, and verifiably safe.

--- END OF FILE ./docs/03_GOVERNANCE.md ---

--- START OF FILE ./docs/04_ROADMAP.md ---
# 4. The CORE Project Roadmap

## Preamble: From Foundation to Reason

The initial development of CORE (up to and including the `v0.2.0` release) focused on building a stable, self-aware, and constitutionally governed foundation. That foundational work is now considered complete. A historical record of that process can be found in `docs/archive/StrategicPlan.md`.

**This document outlines our new, singular direction.** With a stable foundation in place, the project is moving into its next major phase: **evolving from a system with hardcoded logic to a true reasoning system built on the Mind/Body/Will architecture.**

Our entire development effort is now focused on the epic described below.

---

## The `v1.0` Epic: Implementing the Mind/Body/Will Trinity

**GitHub Epic:** [epic: Refactor to a Policy-Driven Cognitive Layer (Mind/Body/Will)](https://github.com/DariuszNewecki/CORE/issues/43)

**Goal:** To fundamentally refactor CORE's architecture to recognize the LLM layer as the system's "Will." We will replace the hardcoded `OrchestratorClient` and `GeneratorClient` with a policy-driven, role-based system for selecting and using cognitive resources.

### Phase 1: Amend the Constitution (The Mind)
-   **Challenge:** The system's cognitive capabilities are implicitly defined in Python code.
-   **Goal:** Create a new constitutional file, `.intent/knowledge/cognitive_roles.yaml`, to explicitly define the reasoning agents (e.g., `Planner`, `Coder`, `SecurityAnalyst`) and the models that power them.
-   **Status:** ‚è≥ **Not Started**

### Phase 2: Evolve the Machinery (The Body)
-   **Challenge:** The Body currently contains logic for choosing and calling LLMs.
-   **Goal:** Create a new, simple `CognitiveService` in the `core` domain. Its only job is to read `cognitive_roles.yaml` and provide a configured client for a requested role. All complex reasoning is removed from the Body.
-   **Status:** ‚è≥ **Not Started**

### Phase 3: Adapt the Agents (The Will)
-   **Challenge:** The system's agents directly instantiate specific clients.
-   **Goal:** Refactor all agentic processes (e.g., `run_development_cycle`) to use the new `CognitiveService`. The agent's logic will be simplified to: "I need to perform a `planning` task, please give me a client for the `Planner` role."
-   **Status:** ‚è≥ **Not Started**

### Phase 4: Deprecate and Remove (Cleanup)
-   **Challenge:** The old client classes and configurations will become obsolete.
-   **Goal:** Once all agents are migrated, completely remove the old `OrchestratorClient` and `GeneratorClient` classes and update `runtime_requirements.yaml` to reflect the new, more generic configuration.
-   **Status:** ‚è≥ **Not Started**

---

## Historical Roadmap (Completed in v0.2.0)

The following goals were part of the initial push to create a stable foundation and are now complete.

*   **Phase: Scaling the Constitution** (‚úÖ Complete)
*   **Phase: Autonomous Application Generation (MVP)** (‚úÖ Complete)
*   **Phase: Constitutional Self-Improvement (Peer Review)** (‚úÖ Complete)
*   **Phase: Achieving Operational Robustness** (üöß In Progress -> Completed in v0.2.0)
*   **Phase: Improving Architectural Health** (üöß In Progress -> Completed in v0.2.0)
--- END OF FILE ./docs/04_ROADMAP.md ---

--- START OF FILE ./docs/05_BYOR.md ---
# 5. Bring Your Own Repo (BYOR) Quickstart

## The Guiding Principle: Ingestion Isomorphism

CORE is designed to be impartial. It applies the same rigorous constitutional analysis to any repository that it applies to itself. This principle, known as **Ingestion Isomorphism**, means that CORE can analyze, understand, and help govern any project without special treatment.

This guide will walk you through the process of pointing CORE at an existing repository and generating a starter constitution for it.

## The Goal: See Your Project Through CORE's Eyes

The `core-admin byor-init` command is a powerful introspection tool. It does not modify your code. Its purpose is to:

1. **Analyze** your repository's structure and capabilities.
2. **Infer** a set of domains based on your directory layout.
3. **Propose** a minimal, non-intrusive `.intent/` constitution based on its findings.

This gives you an instant health check and a starting point for bringing your project under CORE's governance.

---

## Step 1: The Safe Dry Run (Read-Only Analysis)

By default, the command runs in a safe, read-only **dry run** mode. It will show you what it would do **without changing a single file**.

**Commands**

```bash
# Analyze the current CORE repository
poetry run core-admin byor-init .

# Analyze a different project on your machine
poetry run core-admin byor-init /path/to/your/other/project
```

**Understanding the output**

The command first builds a Knowledge Graph of the target repository. Then, it shows the content of five constitutional files it proposes to create:

* `source_structure.yaml` ‚Äî A map of your project, with each subdirectory in `src/` treated as a domain.
* `project_manifest.yaml` ‚Äî An inventory of all the `# CAPABILITY` tags it discovered in your code.
* `capability_tags.yaml` ‚Äî A dictionary for you to define and describe each of those capabilities.
* `principles.yaml` ‚Äî A starter set of CORE's philosophical principles.
* `safety_policies.yaml` ‚Äî A starter set of basic safety rules.

---

## Step 2: Applying the Constitution (Write Mode)

Once you‚Äôve reviewed the dry run output and you‚Äôre happy with the proposed constitution, run the command again with the `--write` flag. This will create the `.intent/` directory and all proposed files inside your target repository.

**Command**

```bash
# Apply the starter constitution to the current repository
poetry run core-admin byor-init . --write
```

---

## Step 3: The First Audit

Your target repository is now **CORE-aware**‚Äîit has a nascent "Mind." The next step is to ask CORE to perform its first constitutional audit on the project.

From within the CORE project, configure the auditor to point at the new project. (In a future version, CORE will be able to attach to it directly.) The result is a continuous, automated health check on your project's architectural integrity and alignment with its newly declared principles.

This process is the first step in transforming any repository from a simple collection of code into a governed, self-aware system.

--- END OF FILE ./docs/05_BYOR.md ---

--- START OF FILE ./docs/06_STARTER_KITS.md ---
# ./docs/06\_STARTER\_KITS.md

# 6. Starter Kits & The Philosophy of Intent

## The CORE Partnership

CORE is not a vending machine for code. It is an intelligent partner designed to translate a human's intent into a governed, working software system. This partnership requires two things:

1. **The Human's Responsibility:** Provide a clear, high-level intent‚Äîthe "why" behind the project.
2. **CORE's Responsibility:** Translate that intent into a complete system, asking for clarification and guidance along the way.

If the human provides no intent ("I do not care"), CORE will do nothing. The partnership requires a starting point.

## Starter Kits: Your First Declaration of Intent

To facilitate this partnership, the `core-admin new` command uses **Starter Kits**. A starter kit is not just a collection of template files; it is a **pre-packaged declaration of intent**. It is a way for you to tell CORE about the *kind* of system you want to build from day one.

By choosing a starter kit, you are providing the "minimal viable intent" that CORE needs to begin its work.

### How to Use Starter Kits

When you create a new project, you can specify a `--profile` option. This tells the scaffolder which starter kit to use.

```bash
# Scaffold a new project using the 'default' balanced starter kit
poetry run core-admin new my-new-app --profile default

# Scaffold a project with high-security policies from the start
poetry run core-admin new my-secure-api --profile security
```

If you do not provide a profile, CORE will default to the safest, most balanced option.

## The Life of a Starter Kit

* **Scaffolding:** CORE creates your new project structure and populates the `.intent/` directory with the constitutional files from your chosen starter kit.
* **Ownership:** From that moment on, that constitution is **yours**. It is no longer a template. It is the living "Mind" of your new project.
* **Evolution:** You can (and should) immediately begin to amend and evolve your new constitution to perfectly match your project's unique goals, using the standard proposals workflow.

Starter kits are just the beginning of the conversation, not the end. They are the most effective way to kickstart the CORE partnership and begin the journey of building a truly intent-driven system.

---

# ./README.md

# CORE ‚Äî The Self-Improving System Architect

> **Where Intelligence Lives.**

[![Status: Architectural Prototype](https://img.shields.io/badge/status-architectural%20prototype-blue.svg)](#-project-status)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](LICENSE)

CORE is a self-governing, constitutionally aligned AI development framework that can plan, write, validate, and evolve software systems ‚Äî autonomously and safely. It is designed for environments where **trust, traceability, and governance matter**.

---

## üèõÔ∏è Project Status: Architectural Prototype

The core self-governance and constitutional amendment loop is complete and stable. The system can audit and modify its own constitution via a human-in-the-loop, cryptographically signed approval process.

The next phase, as outlined in our **[Strategic Plan](docs/StrategicPlan.md)**, is to expand agent capabilities so CORE can generate and manage entirely new applications based on user intent.

We‚Äôre making the project public now to invite collaboration on this foundational architecture.

---

## üß† What CORE *is*

* üßæ Evolves itself through **declared intent**, not hidden assumptions.
* üõ°Ô∏è Enforces **constitutional rules**, **domain boundaries**, and **safety policies**.
* üå± Creates new, governed applications from **[Starter Kits](docs/06_STARTER_KITS.md)** that capture initial intent.
* üß© Uses a modular agent architecture with a clear separation of concerns.
* üìö Ensures every decision is **documented, reversible, and introspectable**.

---

## ü¶Æ Key Concepts

| Concept                     | Description                                                                              |
| --------------------------- | ---------------------------------------------------------------------------------------- |
| **`.intent/`**              | The ‚Äúmind‚Äù of CORE: constitution, policies, capability maps, and self-knowledge.         |
| **`ConstitutionalAuditor`** | The ‚Äúimmune system,‚Äù continuously verifying code aligns with the constitution.           |
| **`PlannerAgent`**          | Decomposes high-level goals into executable plans.                                       |
| **`core-admin` CLI**        | Human-in-the-loop tool for managing the system's lifecycle.                              |
| **Starter Kits**            | Pre-packaged constitutions that serve as the user's first declaration of intent.         |
| **Canary Check**            | Applies proposed changes to an isolated copy and runs a full self-audit before approval. |
| **Knowledge Graph**         | Machine-readable map of symbols, roles, capabilities, and relationships.                 |

---

## üöÄ Getting Started

1. **Install dependencies**

   ```bash
   poetry install
   ```

2. **Set up environment**

   ```bash
   cp .env.example .env
   # Edit .env with your keys/URLs. See .intent/config/runtime_requirements.yaml for required variables.
   ```

3. **Run a full self-audit**

   ```bash
   make audit
   ```

---

## üßë‚Äç‚öñÔ∏è Human-in-the-Loop (CLI)

The `core-admin` CLI is your primary tool for guiding the system.

### Creating New Projects

```bash
# Create a new, governed application using a starter kit
core-admin new my-new-app --profile default
```

### Onboarding Existing Projects

```bash
# Analyze an existing repo and propose a starter constitution
core-admin byor-init /path/to/existing-repo
```

### Managing the Constitution

```bash
# List pending constitutional changes
core-admin proposals-list

# Sign a proposal with your key
core-admin proposals-sign cr-example.yaml

# Approve a proposal (runs a canary self-audit)
core-admin proposals-approve cr-example.yaml
```

> If `core-admin` isn‚Äôt found, try: `poetry run core-admin ...`

---

## üå± Contributing

We welcome contributions from AI engineers, DevOps pros, and governance experts.

* See **CONTRIBUTING.md** to get started.
* Check the **Strategic Plan** for where we're headed.

---

## üìÑ License

Licensed under the MIT License. See **LICENSE**.

--- END OF FILE ./docs/06_STARTER_KITS.md ---

--- START OF FILE ./docs/07_PEER_REVIEW.md ---
# 7. Constitutional Peer Review

## The Principle: Proactive Self-Improvement

A core principle of CORE is that a system must not only govern itself but also actively seek to improve its own governance. The Constitutional Peer Review feature is the primary mechanism for this proactive self-improvement.

It answers the question: **"Is our constitution the best it can be?"**

This process allows CORE to leverage powerful, external Large Language Models (LLMs) as expert consultants. It can ask for a "second opinion" on its own principles, policies, and structure, identifying gaps, ambiguities, or potential improvements that it might not be able to see on its own.

## The Workflow: A Safe, Human-in-the-Loop Process

The peer review process is designed to be fundamentally safe, keeping the human operator in full control of any resulting changes. The external LLM can only **suggest**; it can never **act**.

---

### Step 1: Exporting the Constitutional Bundle

The first step is to package the system's entire "Mind" (`.intent/` directory) into a single, portable file that an LLM can analyze.

**Command:**

```bash
poetry run core-admin review export
```

This command reads your `meta.yaml` to discover all constitutional files and bundles them into `reports/constitution_bundle.txt`. This is useful for manual inspection or for sending to different AI models.

---

### Step 2: Requesting the Peer Review

The main command automates the bundling and review request in a single step.

**Command:**

```bash
poetry run core-admin review peer-review
```

**What this command does:**

* Performs the same **export** process internally to create the constitutional bundle.
* Loads a specialized set of instructions from `.intent/prompts/constitutional_review.prompt`.
* Sends the bundle and the instructions to the Orchestrator LLM configured in your `.env` file.
* Saves the AI's detailed feedback as a Markdown file to `reports/constitutional_review.md`.

---

### Step 3: Taking Action on the Feedback

The output report is a set of suggestions for the human operator. It is your responsibility to review this feedback and decide what to act on.

* A strong piece of feedback from the review (e.g., *"The policy for secrets management is incomplete"*) should be transformed into a new item on the **Project Roadmap** or a formal **constitutional amendment proposal** (`.intent/proposals/cr-*.yaml`).
* This loop allows CORE to use external intelligence to evolve its own constitution **without ever sacrificing** the safety and control of its human-in-the-loop governance model.

--- END OF FILE ./docs/07_PEER_REVIEW.md ---

--- START OF FILE ./docs/08_CONTEXT_AND_COMPARISONS.md ---
# 8. Context and Comparisons

This document provides context for the CORE project by answering two key questions:
1.  What does a "governed application" built by CORE actually look like?
2.  How does CORE compare to other AI development tools?

## 1. What a "Governed Application" Looks Like

When you run `core-admin new my-app`, CORE doesn't just generate code. It creates a complete, self-contained, and **governed** project ecosystem.

Here‚Äôs what that means in practice:

*   **A Standardized Structure:** Your new project will have a clean, predictable layout (`src/`, `tests/`, `pyproject.toml`, etc.), making it easy for any developer to understand.

*   **A Nascent "Mind":** Most importantly, your new project gets its own `.intent/` directory. This is its constitution, seeded from a **Starter Kit**. It contains:
    *   `principles.yaml`: High-level values for your project.
    *   `source_structure.yaml`: The architectural rules for your codebase.
    *   `project_manifest.yaml`: A list of the capabilities your application is expected to have.
    *   `safety_policies.yaml`: Basic security rules to prevent unsafe code.

*   **An "Immune System" Ready to Go:** The new project is generated with a GitHub Actions CI workflow (`ci.yml`) that runs `black`, `ruff`, and `pytest` on every commit. It is CORE-aware and ready for you to add a `make audit` step to continuously check its constitutional alignment.

A "governed application" is one where the rules are not just in a wiki page; they are in a machine-readable format that an AI partner (like CORE) can understand, enforce, and even help you evolve.

---

## 2. How CORE Compares to Other Tools

CORE is often compared to other AI-assisted development tools. Here‚Äôs how it‚Äôs different.

| Tool | Primary Function | Core Paradigm |
| :--- | :--- | :--- |
| **GitHub Copilot / Cursor** | **Autocompletion & In-IDE Chat** | An AI assistant *for the developer*. It helps you write code faster by suggesting lines and functions. It has no knowledge of your project's overall architecture or long-term goals. |
| **AutoGPT / Agent Swarms** | **Autonomous Task Execution** | An AI agent that attempts to achieve a goal by breaking it down and executing steps. It is powerful but often unconstrained, with a high risk of producing incorrect, unsafe, or unmaintainable code. |
| **CORE** | **Governed System Architecture** | An AI partner *for the entire system*. CORE's primary job is not just to write code, but to ensure that all code‚Äîwhether written by an AI or a human‚Äîremains in perfect alignment with a declared set of architectural and philosophical rules. |

**The Key Difference is Governance.**

-   Copilot is a **keyboard**. It makes you a faster typist.
-   AutoGPT is an **unsupervised intern**. It has a lot of energy but no discipline.
-   CORE is an **AI architect**. It helps you design the blueprint, then ensures everyone on the team (including other AIs) builds according to that blueprint.

CORE is designed for environments where **long-term maintainability, safety, and architectural integrity** are more important than the raw speed of code generation.
--- END OF FILE ./docs/08_CONTEXT_AND_COMPARISONS.md ---

--- START OF FILE ./docs/NORTH_STAR.md ---
# CORE North Star

**Goal:** Turn high-level goals into governed, safe, running software ‚Äî autonomously.

**Invariant:** Safety never degrades. Every change is proven aligned to intent before it lands (policies, tests, canary audit).

## The Autonomy Ladder

- **A0 ¬∑ Observe** ‚Äî Attach to any repo, build knowledge graph, run auditor (read-only).
- **A1 ¬∑ Propose** ‚Äî Open PRs with small, safe fixes (docstrings, capability tags, logging). Human merges.
- **A2 ¬∑ Governed Writes** ‚Äî Canary-validated changes self-apply with policy (human optional by risk tier).
- **A3 ¬∑ BYOR** ‚Äî CORE-fy arbitrary repos (including CORE), propose structure, capabilities, tests.
- **A4 ¬∑ Birth New Apps** ‚Äî From a goal, scaffold feature-first app (Mind/Body), tests, CI/CD.
- **A5 ¬∑ Continuous Intent Dev** ‚Äî Roadmap evolves in natural language; CORE plans, implements, releases within risk budgets.

## Guardrails
- **Risk tiers:** auto-merge only for low-risk scopes at first.
- **Evidence gates:** static policies + tests + canary must pass.
- **Idempotence:** ingestion produces stable results; re-runs don‚Äôt thrash.
- **Kill switch:** rollback on anomaly/error-budget breach.

## KPIs
- Auditor errors/warnings ‚Üí sustained zero
- % code with capability tags
- Proposal acceptance rate / MTTR
- % PRs generated by CORE
- % no-human releases by risk tier
- Post-merge incident rate

## Current Status
- Project status: **Architectural Prototype**.
- Targeting **M1 (A0‚ÜíA1)**: CORE overlay, CI audit, auto-PRs for docstrings/tags/logging.

--- END OF FILE ./docs/NORTH_STAR.md ---

--- START OF FILE ./docs/releases/v0.2.0.md ---
# v0.2.0 ‚Äî MVP: Autonomous Application Generation (2025-08-15)

**Highlights**
- First MVP that can autonomously scaffold a governed application from a high-level goal.
- Nightly constitutional audit + capability drift checks in CI.
- Starter Kit: default profile shipped.
- CLI: `core-admin new`, `core-admin agent scaffold`, `core-admin proposals ...`.

**Upgrade notes**
- Use Python 3.11+.
- Install with `poetry install`.
- Run checks locally: `black --check . && ruff check . && pytest`.

--- END OF FILE ./docs/releases/v0.2.0.md ---


{
  "metadata": {
    "generated_at_utc": "2026-01-20T09:08:07.438346+00:00",
    "total_policy_rules": 54,
    "total_executed_ids": 54,
    "total_policy_files": 12
  },
  "summary": {
    "rules_total": 54,
    "rules_enforced": 54,
    "rules_implementable": 0,
    "rules_declared_only": 0,
    "execution_rate": 100.0
  },
  "entries": [
    {
      "rule": {
        "rule_id": "async.no_manual_loop_run",
        "statement": "Logic modules MUST NOT call 'asyncio.run()' or manually create new event loops.",
        "severity": "blocking",
        "policy": "rules/architecture/async_logic",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "logic.di.no_global_session",
        "statement": "Modules MUST NOT import 'get_session' globally; database access MUST be injected.",
        "severity": "blocking",
        "policy": "rules/architecture/async_logic",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "logic.logging.standard_only",
        "statement": "Operational logs MUST use standard 'getLogger' and avoid f-strings for lazy evaluation.",
        "severity": "reporting",
        "policy": "rules/architecture/async_logic",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.no_module_async_engine",
        "statement": "Async execution engines MUST NOT be instantiated at module import time.",
        "severity": "blocking",
        "policy": "rules/architecture/core_safety",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.max_file_size",
        "statement": "Source files MUST remain below a defined maximum size to preserve maintainability.",
        "severity": "reporting",
        "policy": "rules/architecture/core_safety",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.constitution_read_only",
        "statement": "The constitutional intent directory MUST be immutable.",
        "severity": "blocking",
        "policy": "rules/architecture/core_safety",
        "check_engine": "glob_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.meta_read_only",
        "statement": "Intent schema and meta artifacts MUST NOT be mutated at runtime.",
        "severity": "blocking",
        "policy": "rules/architecture/core_safety",
        "check_engine": "glob_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.constitution.read_only",
        "statement": "The constitutional intent directory (.intent/**) MUST be treated as immutable by all system components.",
        "severity": "blocking",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "glob_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.intent_meta.required",
        "statement": "A single META directory MUST exist at .intent/META to serve as the authoritative contract for intent artifacts.",
        "severity": "advisory",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "glob_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.logic_mutation.governed",
        "statement": "Permanent modifications to production logic within 'src/' MUST occur only through governed mutation surfaces.",
        "severity": "blocking",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.artifact_mutation.traceable",
        "statement": "System artifacts, logs, and reports SHOULD be generated via the FileHandler to ensure audit traceability.",
        "severity": "reporting",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.no_governance_bypass",
        "statement": "No action or workflow MAY bypass governance validation; if a precondition cannot be evaluated, the operation MUST be blocked.",
        "severity": "advisory",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "governance.dangerous_execution_primitives",
        "statement": "Dangerous execution primitives (eval, exec, compile, subprocess) require documented justification. AI agent code (Will layer) MUST NOT use these primitives. Infrastructure code (Body layer) MAY use them in designated sanctuary modules with clear operational need.",
        "severity": "advisory",
        "policy": "rules/architecture/governance_basics",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.mind.no_database_access",
        "statement": "Mind layer components (src/mind/**/*.py) MUST NOT import database session infrastructure (get_session)",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.mind.no_filesystem_writes",
        "statement": "Mind layer components (src/mind/**/*.py) MUST NOT write to filesystem",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.mind.no_body_invocation",
        "statement": "Mind layer components (src/mind/**/*.py) MUST NOT import or invoke Body layer (src/body)",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.mind.no_will_invocation",
        "statement": "Mind layer components (src/mind/**/*.py) MUST NOT import or invoke Will layer (src/will)",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.body.no_rule_evaluation",
        "statement": "Body layer components (src/body/**/*.py) MUST NOT evaluate constitutional rules directly",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.will.no_direct_database_access",
        "statement": "Will layer components (src/will/**/*.py) MUST NOT import get_session directly",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.will.no_filesystem_operations",
        "statement": "Will layer components (src/will/**/*.py) SHOULD delegate filesystem operations to Body",
        "severity": "reporting",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.will.must_delegate_to_body",
        "statement": "Will layer orchestration components SHOULD import and delegate to Body services",
        "severity": "advisory",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.api.no_direct_database_access",
        "statement": "API layer components (src/api/**/*.py) MUST NOT import get_session directly",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.api.must_route_through_will",
        "statement": "API route handlers SHOULD delegate all logic to Will layer",
        "severity": "advisory",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.api.no_body_bypass",
        "statement": "API layer components SHOULD NOT directly import Body services",
        "severity": "reporting",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.layers.no_body_to_will",
        "statement": "Body layer components (src/body/**/*.py) MUST NOT import or invoke Will layer (src/will)",
        "severity": "blocking",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "ast_gate",
        "implementable": false
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.layers.no_mind_execution",
        "statement": "Mind layer components (src/mind/**/*.py) MUST NOT perform I/O operations or invoke actions",
        "severity": "reporting",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "knowledge_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "architecture.shared.no_strategic_decisions",
        "statement": "Shared infrastructure components (src/shared/**/*.py) MUST NOT make strategic decisions or orchestrate workflows",
        "severity": "reporting",
        "policy": "rules/architecture/layer_separation",
        "check_engine": "knowledge_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modernization.legacy_scars",
        "statement": "Source code SHOULD be free of obsolete structural shims, unused parameters from prior iterations, and internal logic wrappers that bypass the Universal Workflow Pattern.",
        "severity": "advisory",
        "policy": "rules/architecture/modernization",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modularity.single_responsibility",
        "statement": "A source file SHOULD encapsulate at most 2 distinct responsibilities. Files with 3+ responsibilities are candidates for refactoring.",
        "severity": "reporting",
        "policy": "rules/architecture/modularity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modularity.semantic_cohesion",
        "statement": "Functions within a module SHOULD maintain semantic cohesion >= 0.70 (measured via embedding similarity). Low cohesion indicates poor module boundaries.",
        "severity": "reporting",
        "policy": "rules/architecture/modularity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modularity.import_coupling",
        "statement": "A source file SHOULD touch at most 3 distinct concern areas (database, web, CLI, testing, ML, file I/O). High coupling indicates mixed responsibilities.",
        "severity": "reporting",
        "policy": "rules/architecture/modularity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modularity.refactor_score_threshold",
        "statement": "Files with refactor score >= 60 (based on responsibility count, cohesion, coupling, duplication) SHOULD be prioritized for modularization.",
        "severity": "reporting",
        "policy": "rules/architecture/modularity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "modularity.unix_philosophy",
        "statement": "Components SHOULD follow UNIX philosophy: do one thing well, compose via clear interfaces, minimize coupling.",
        "severity": "advisory",
        "policy": "rules/architecture/modularity",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "quality.type_safety",
        "statement": "Production code SHOULD be type-safe as verified by MyPy static analysis.",
        "severity": "advisory",
        "policy": "rules/architecture/quality_gates",
        "check_engine": "workflow_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "quality.security_audit",
        "statement": "The project dependency tree SHOULD be free of known vulnerabilities as verified by pip-audit.",
        "severity": "advisory",
        "policy": "rules/architecture/quality_gates",
        "check_engine": "workflow_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "quality.test_integrity",
        "statement": "The project test suite SHOULD be functional and passing without collection errors.",
        "severity": "advisory",
        "policy": "rules/architecture/quality_gates",
        "check_engine": "workflow_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "linkage.assign_ids",
        "statement": "Public functions and methods MUST have unique UUID identifiers for Knowledge Graph synchronization.",
        "severity": "reporting",
        "policy": "rules/code/linkage",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "linkage.duplicate_ids",
        "statement": "Symbol identifiers (# ID:) MUST be globally unique across the entire codebase.",
        "severity": "blocking",
        "policy": "rules/code/linkage",
        "check_engine": "knowledge_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.no_metadata_decorators",
        "statement": "Source code MUST NOT contain descriptive metadata decorators like @capability, @meta, or @owner.",
        "severity": "blocking",
        "policy": "rules/code/purity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.no_todo_placeholders",
        "statement": "Production code MUST NOT contain 'TODO', 'FIXME', or 'TBD' strings; use the constitutional 'FUTURE' or 'PENDING' markers.",
        "severity": "reporting",
        "policy": "rules/code/purity",
        "check_engine": "regex_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.stable_id_anchor",
        "statement": "Every public symbol MUST be preceded by a stable '# ID:' anchor comment.",
        "severity": "reporting",
        "policy": "rules/code/purity",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.docstrings.required",
        "statement": "Public symbols MUST have docstrings that clarify intent and parameters for autonomous planning.",
        "severity": "reporting",
        "policy": "rules/code/purity",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.logic_conservation",
        "statement": "Refactored code MUST NOT result in a character count reduction of >50% compared to original source unless explicitly authorized.",
        "severity": "blocking",
        "policy": "rules/code/purity",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "purity.no_dead_code",
        "statement": "Production code MUST NOT contain unreachable or dead symbols as identified by static analysis.",
        "severity": "reporting",
        "policy": "rules/code/purity",
        "check_engine": "workflow_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "data.ssot.database_primacy",
        "statement": "Operational knowledge MUST NOT be hardcoded in files when a database representation exists.",
        "severity": "blocking",
        "policy": "rules/data/governance",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "data.security.no_raw_secrets",
        "statement": "Source code, logs, and prompts MUST NOT contain raw secret values or API keys.",
        "severity": "blocking",
        "policy": "rules/data/governance",
        "check_engine": "regex_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "data.integrity.vector_sync",
        "statement": "Every code symbol record in the database MUST have a corresponding vector entry in the memory layer.",
        "severity": "reporting",
        "policy": "rules/data/governance",
        "check_engine": "knowledge_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "autonomy.lanes.boundary_enforcement",
        "statement": "Autonomous agents MUST NOT modify files outside their assigned autonomy lane.",
        "severity": "blocking",
        "policy": "rules/will/autonomy",
        "check_engine": "glob_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "autonomy.tracing.mandatory",
        "statement": "All non-trivial autonomous decisions MUST produce an inspectable trace in the Decision Log.",
        "severity": "reporting",
        "policy": "rules/will/autonomy",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "autonomy.reasoning.policy_alignment",
        "statement": "Agent goal planning MUST include a semantic check against the Quality Assurance policy.",
        "severity": "reporting",
        "policy": "rules/will/autonomy",
        "check_engine": "regex_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "planning.no_code_generation",
        "statement": "PlannerAgent MUST NOT generate code in ExecutionTask.params.code field. The 'code' parameter MUST be None after the PLANNING phase. Code generation is exclusively the responsibility of the CODE_GENERATION phase via CoderAgent.",
        "severity": "blocking",
        "policy": "rules/will/planning",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "planning.conceptual_only",
        "statement": "ExecutionTask.params dict MUST contain only conceptual parameters (file paths, action IDs, configuration values). Concrete Python code, implementation details, or code snippets MUST NOT appear in params. Natural language descriptions in the 'step' field are unrestricted.",
        "severity": "blocking",
        "policy": "rules/will/planning",
        "check_engine": "llm_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "planning.file_path_validation",
        "statement": "ExecutionTask.params.file_path MUST be a valid repository-relative path string, not code content. File paths MUST match pattern: ^(src|tests|docs)/[a-zA-Z0-9_/]+\\.py$",
        "severity": "blocking",
        "policy": "rules/will/planning",
        "check_engine": "regex_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    },
    {
      "rule": {
        "rule_id": "planning.trace_mandatory",
        "statement": "PlannerAgent MUST record decision trace for every execution plan created, including goal, step count, and planning strategy used.",
        "severity": "blocking",
        "policy": "rules/will/planning",
        "check_engine": "ast_gate",
        "implementable": true
      },
      "coverage_status": "enforced",
      "in_executed_ids": true
    }
  ],
  "executed_ids_list": [
    "architecture.api.must_route_through_will",
    "architecture.api.no_body_bypass",
    "architecture.api.no_direct_database_access",
    "architecture.body.no_rule_evaluation",
    "architecture.constitution_read_only",
    "architecture.layers.no_body_to_will",
    "architecture.layers.no_mind_execution",
    "architecture.max_file_size",
    "architecture.meta_read_only",
    "architecture.mind.no_body_invocation",
    "architecture.mind.no_database_access",
    "architecture.mind.no_filesystem_writes",
    "architecture.mind.no_will_invocation",
    "architecture.no_module_async_engine",
    "architecture.shared.no_strategic_decisions",
    "architecture.will.must_delegate_to_body",
    "architecture.will.no_direct_database_access",
    "architecture.will.no_filesystem_operations",
    "async.no_manual_loop_run",
    "autonomy.lanes.boundary_enforcement",
    "autonomy.reasoning.policy_alignment",
    "autonomy.tracing.mandatory",
    "data.integrity.vector_sync",
    "data.security.no_raw_secrets",
    "data.ssot.database_primacy",
    "governance.artifact_mutation.traceable",
    "governance.constitution.read_only",
    "governance.dangerous_execution_primitives",
    "governance.intent_meta.required",
    "governance.logic_mutation.governed",
    "governance.no_governance_bypass",
    "linkage.assign_ids",
    "linkage.duplicate_ids",
    "logic.di.no_global_session",
    "logic.logging.standard_only",
    "modernization.legacy_scars",
    "modularity.import_coupling",
    "modularity.refactor_score_threshold",
    "modularity.semantic_cohesion",
    "modularity.single_responsibility",
    "modularity.unix_philosophy",
    "planning.conceptual_only",
    "planning.file_path_validation",
    "planning.no_code_generation",
    "planning.trace_mandatory",
    "purity.docstrings.required",
    "purity.logic_conservation",
    "purity.no_dead_code",
    "purity.no_metadata_decorators",
    "purity.no_todo_placeholders",
    "purity.stable_id_anchor",
    "quality.security_audit",
    "quality.test_integrity",
    "quality.type_safety"
  ],
  "policy_metadata": {
    "rules/architecture/async_logic": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/core_safety": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/governance_basics": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/layer_separation": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/modernization": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/modularity": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/architecture/quality_gates": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/code/linkage": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/code/purity": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/data/governance": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/will/autonomy": {
      "title": "",
      "id": "",
      "format": "flat"
    },
    "rules/will/planning": {
      "title": "",
      "id": "",
      "format": "flat"
    }
  }
}

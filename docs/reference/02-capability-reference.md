# Capability Reference

This capability reference describes the **capabilities recognized within CORE**, how they are extracted, and how they are used within the autonomy and governance pipelines.

Unlike traditional systems, capabilities in CORE are:

* discovered dynamically from the source code,
* validated through the Knowledge Graph,
* aligned with `.intent/` governance domains,
* used for planning, reasoning, and audit coverage.

This reference reflects the *current 2025 implementation*.

---

# 1. What Is a Capability?

A capability in CORE is a **governed, meaningful unit of functionality** exposed by the system.

A capability is:

* a symbolic function,
* with a stable ID,
* assigned to a governance domain,
* used by planners and auditors,
* included in the Knowledge Graph.

### Purpose

Capabilities allow:

* Will (agents) to reason about what the system can do,
* Mind (governance) to validate coverage,
* Body (execution) to wire actions correctly.

---

# 2. How CORE Discovers Capabilities

Capabilities are discovered by the introspection pipeline under:

```
src/features/introspection/capability_discovery_service.py
```

The pipeline:

1. Scans source for functions and classes
2. Applies heuristics & patterns
3. Extracts capability IDs from metadata
4. Assigns domains (from `.intent/` rules)
5. Stores the results in the Knowledge Graph

---

# 3. Capability Identifier Format

Each capability has a stable identifier:

```
cap.<domain>.<symbol>
```

Examples:

```
cap.context.build
cap.introspection.symbol_index
cap.validation.syntax_check
```

These IDs appear in:

* audits,
* manifests,
* Knowledge Graph exports,
* plans generated by agents.

---

# 4. Capability Domains

Domains partition the system by responsibility.

Common domains in CORE:

* **context** — context building, context providers
* **capability** — capability extraction, indexing
* **validation** — formatter, linter, syntax tests
* **introspection** — symbol scanning, drift detection
* **knowledge** — vectorization, clustering
* **governance** — audit logic, policy checks
* **autonomy** — planners, coders, orchestration
* **storage** — file handlers, data providers
* **execution** — CLI wrappers, action execution

Domains enforce architectural boundaries and guide agent reasoning.

---

# 5. Examples of Real Capabilities

Below is a partial list of recognizable capabilities from the current system.

## 5.1. Context & Providers

```
cap.context.build
cap.context.load_providers
cap.context.serialize
```

## 5.2. Validation

```
cap.validation.black_format
cap.validation.ruff_lint
cap.validation.syntax_check
cap.validation.run_tests
```

## 5.3. Knowledge Graph

```
cap.knowledge.index_symbols
cap.knowledge.extract_capabilities
cap.knowledge.build_vectors
cap.knowledge.detect_drift
```

## 5.4. Governance

```
cap.governance.audit
cap.governance.policy_resolve
cap.governance.validate_boundaries
```

## 5.5. Autonomy

```
cap.autonomy.plan_feature
cap.autonomy.generate_code
cap.autonomy.explain_change
cap.autonomy.suggest_tests
```

---

# 6. How Capabilities Support Autonomy

Capabilities are consumed by:

* Planner Agent (Will)
* Self-correction engine
* Reasoning orchestrator

They enable:

* constraint-based plans,
* domain-aware generation,
* capability reuse,
* structured execution.

In Phase 2 (A2), capabilities become **first-class reasoning primitives**.

---

# 7. How Capabilities Support Governance

The Constitutional Audit uses capabilities to ensure:

* proper coverage (ID, header, import rules)
* correct domain placement
* no orphaned logic
* consistency across refactors

This ensures the project evolves safely.

---

# 8. Working With Capabilities

Developers can:

## 8.1. Search capabilities

```bash
poetry run core-admin search capability build
```

## 8.2. Regenerate capability documentation

```bash
poetry run core-admin manage database sync-knowledge
```

## 8.3. Inspect capability drift

```bash
poetry run core-admin inspect project
```

---

# 9. Future Extensions

Future phases will extend capabilities with:

* semantic metadata,
* richer dependency graphs,
* suggested refactors,
* autonomous domain classification.

These enhancements will support A3 and A4 autonomy.

---

# 10. Summary

Capabilities represent CORE’s functional map.
They are discovered automatically, enforced by governance, consumed by autonomy, and stored in the Knowledge Graph.

They form the backbone of CORE’s architecture, ensuring clarity, reasoning power, and safe evolution.

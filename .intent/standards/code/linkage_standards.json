{
  "id": "standard_code_linkage",
  "version": "1.1.0",
  "title": "Code Standard – Linkage and ID Management",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Core Maintainer",
    "responsible": [
      "Quality Lead"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "meta.policy",
  "purpose": "Defines how functions and methods are uniquely identified through ID comments. Enables tracing, auditing, debugging, and autonomous operations by providing stable identifiers for all executable logic.\n",
  "rules": [
    {
      "id": "linkage.assign_ids",
      "rationale": "Unique IDs enable tracing, auditing, debugging, and autonomous operations.",
      "enforcement": "error",
      "statement": "All public functions and methods MUST have unique UUID identifiers.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "id_anchor",
          "exclude_files": [
            "**/__init__.py",
            "**/test_*.py",
            "**/*_test.py",
            "tests/**/*.py"
          ]
        }
      }
    },
    {
      "id": "linkage.duplicate_ids",
      "rationale": "Duplicate IDs break tracing and state synchronization. This requires a global Knowledge Graph scan to detect collisions.",
      "enforcement": "error",
      "statement": "Function IDs MUST be globally unique across the entire codebase.",
      "check": {
        "engine": "knowledge_gate",
        "params": {
          "check_type": "duplicate_ids"
        }
      }
    },
    {
      "id": "linkage.capability.unassigned",
      "rationale": "Every public function must have a capability ID assigned in the knowledge graph for governance tracking and constitutional enforcement.",
      "enforcement": "error",
      "statement": "Public symbols MUST have capability IDs assigned in the knowledge graph (capability field must not be 'unassigned').",
      "check": {
        "engine": "knowledge_gate",
        "params": {
          "check_type": "capability_assignment",
          "exclude_patterns": [
            "tests/",
            "scripts/"
          ]
        }
      }
    }
  ],
  "id_format": {
    "standard": "UUID4",
    "pattern": "^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$",
    "placement": "Immediately before function definition as comment",
    "spacing": "No blank lines between ID comment and function",
    "examples": {
      "correct": "# ID: 550e8400-e29b-41d4-a716-446655440000\ndef process_data():\n    \"\"\"Process the data.\"\"\"\n    pass\n",
      "incorrect": "def process_data():\n    # ID: 550e8400-e29b-41d4-a716-446655440000  # ❌ Wrong location\n    pass\n\n# ID: not-a-uuid  # ❌ Invalid format\ndef process_data():\n    pass\n"
    }
  },
  "scope": {
    "requires_id": [
      "All public functions (not starting with _)",
      "All public methods in classes",
      "Module-level functions in src/"
    ],
    "exempt_from_id": [
      "Private functions (_function_name)",
      "Test functions (tests/)",
      "Magic methods (__init__, __str__, __repr__, etc.)",
      "Property getters/setters",
      "Context managers (__enter__, __exit__)"
    ]
  },
  "tooling": {
    "id_generation": {
      "command": "core-admin dev fix-ids",
      "description": "Automatically assign IDs to functions missing them",
      "behavior": [
        "Scans all Python files in src/",
        "Generates UUID4 for functions without IDs",
        "Writes IDs as comments before function definitions",
        "Skips private functions and test files"
      ]
    },
    "id_validation": {
      "command": "core-admin check linkage",
      "description": "Validate ID coverage and uniqueness",
      "checks": [
        "All public functions have IDs",
        "No duplicate IDs exist",
        "All IDs are valid UUID4 format"
      ]
    },
    "id_tracking": {
      "database": "symbols table in PostgreSQL",
      "purpose": "Track function IDs, names, locations, and metadata",
      "fields": [
        "id: UUID (primary key)",
        "name: function name",
        "file_path: source file",
        "line_number: definition line",
        "first_seen: timestamp",
        "last_seen: timestamp"
      ]
    }
  },
  "id_lifecycle": {
    "assignment": {
      "trigger": "Function creation",
      "method": "Automatic via core-admin dev fix-ids or manual insertion",
      "uniqueness": "Validated at commit time via CI checks"
    },
    "persistence": {
      "rule": "IDs MUST NOT change once assigned",
      "rationale": "Changing IDs breaks historical audit trails and references",
      "exception": "Only when function is completely deleted"
    },
    "refactoring": {
      "rename": "Preserve original ID",
      "move": "Preserve original ID",
      "split": "Original keeps ID, new functions get new IDs",
      "merge": "Keep one ID, deprecate others"
    }
  },
  "coverage": {
    "targets": {
      "public_functions": "100%",
      "private_functions": "0% (explicitly excluded)",
      "test_functions": "0% (explicitly excluded)"
    },
    "measurement": {
      "method": "AST scanning via governance checks",
      "frequency": "Every audit run",
      "reporting": "Coverage percentage in audit output"
    },
    "current_baseline": {
      "tracked_via": "linkage.assign_ids check",
      "improvement_strategy": "Run core-admin dev fix-ids regularly"
    }
  },
  "migration": {
    "from_no_ids": {
      "description": "Adding IDs to existing codebase",
      "steps": [
        "Run: core-admin dev fix-ids",
        "Review generated IDs",
        "Commit: git add . && git commit -m 'Add function IDs'",
        "Enable linkage checks in CI",
        "Monitor coverage trends"
      ]
    },
    "handling_conflicts": {
      "description": "Resolving duplicate IDs after merge",
      "steps": [
        "Audit detects duplicate IDs",
        "Run: core-admin dev fix-ids --fix-duplicates",
        "Verify all IDs are unique",
        "Commit corrections"
      ]
    }
  },
  "audit": {
    "automated_checks": [
      "id_coverage_check: Validates coverage percentage",
      "id_uniqueness_check: Detects duplicate IDs"
    ],
    "evidence_required": [
      "ID coverage meets 100% target for public functions",
      "No duplicate IDs exist",
      "All IDs are valid UUID4 format",
      "Symbol database synchronized with codebase"
    ],
    "manual_review": {
      "frequency": "quarterly",
      "scope": "Review ID consistency and coverage trends"
    }
  },
  "additionalProperties": false
}

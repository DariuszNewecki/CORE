{
  "id": "rules_structure_standard",
  "version": "2.0.0",
  "title": "Universal Rules Structure Standard",
  "type": "constitutional_standard",
  "status": "active",
  "owners": {
    "accountable": "Governance Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "rules.structure",
  "purpose": "Establishes the canonical structure for ALL .intent documents that define enforceable rules, auditable checks, or validatable constraints.\nThis standard ensures: - Consistent rule discovery across all document types - Parser-friendly structure that never breaks with new categories - Clear separation between metadata and enforcement content - Industry alignment with Kubernetes, AWS, and OPA patterns\n",
  "scope": {
    "applies_to": [
      "Constitutional documents (authority.json, boundaries.json, risk_classification.json)",
      "Policy standards (code_standards.json, logging_standards.json, data_governance.json)",
      "Architectural patterns (agent_patterns.json, workflow_patterns.json, service_patterns.json)",
      "Operational standards (operations.json, safety.json, observability.json)",
      "Schemas with validation rules (any schema defining checkable constraints)"
    ],
    "does_not_apply_to": [
      "Pure metadata documents (document that only describe, not enforce)",
      "Registry documents (lists without enforcement rules)",
      "Configuration files (runtime config without governance rules)",
      "Knowledge bases (informational content without checks)"
    ]
  },
  "canonical_structure": {
    "description": "Documents containing enforceable rules MUST use a single flat 'rules' array at the top level. All rules exist in this array regardless of their category, type, or enforcement level.\n",
    "schema_resolution": {
      "description": "CRITICAL: How schema_id is used in documents with enforceable rules. This prevents validator drift and parser confusion.\n",
      "rule": "The document's schema_id identifies the DOCUMENT STRUCTURE schema (e.g., policy.structure, pattern.structure).\nEach item in the rules[] array conforms to THIS standard (rules.structure) regardless of the document type.\n",
      "example": "{\n  \"id\": \"code_standards\",\n  \"schema_id\": \"policy.structure\",\n  \"rules\": [\n    {\n      \"id\": \"style.linter_required\",\n      \"statement\": \"...\",\n      \"enforcement\": \"error\"\n    }\n  ]\n}\n",
      "validation": "Validators MUST: 1. Validate document header against document's schema_id 2. Validate each rules[] item against rules.structure 3. Reject documents with schema_id mismatch\n"
    },
    "required_format": {
      "rules": {
        "type": "array",
        "description": "Flat array of ALL enforceable rules in this document",
        "required": true,
        "location": "Top-level field in document",
        "item_schema": {
          "description": "Each rule in the array MUST follow this schema",
          "required_fields": {
            "id": {
              "type": "string",
              "description": "Unique identifier for this rule within the constitutional scope",
              "pattern": "^[a-z][a-z0-9._-]*$",
              "examples": [
                "style.linter_required",
                "agent.compliance.no_write_intent",
                "safety.immutable_constitution",
                "di.constructor_injection_preferred"
              ],
              "notes": [
                "Must be globally unique across all .intent documents",
                "Use dot notation for hierarchical organization",
                "Lowercase with underscores, dots, or hyphens only"
              ]
            },
            "statement": {
              "type": "string",
              "description": "Clear, imperative declaration of what must be true",
              "max_length": 500,
              "examples": [
                "All changes MUST pass ruff (lint) before merge.",
                "Agents MUST NOT write directly to '.intent/charter/**'.",
                "Services SHOULD receive dependencies through __init__ constructor."
              ],
              "notes": [
                "Use MUST/SHOULD/MAY keywords (RFC 2119 style)",
                "Be specific and actionable",
                "Focus on the requirement, not the implementation"
              ]
            },
            "enforcement": {
              "type": "string",
              "description": "Severity/priority level for this rule",
              "allowed_values": [
                "error",
                "warn",
                "warning",
                "info"
              ],
              "examples": [
                "error",
                "warn"
              ],
              "notes": [
                "Use 'error' for constitutional requirements",
                "Use 'warn' for best practices",
                "Use 'info' for guidance/documentation"
              ]
            }
          },
          "recommended_fields": {
            "category": {
              "type": "string",
              "description": "High-level grouping for this rule",
              "pattern": "^[a-z][a-z0-9_]*$",
              "examples": [
                "style",
                "safety",
                "agent_governance",
                "dependency_injection",
                "naming",
                "capabilities"
              ],
              "notes": [
                "Use consistent categories across documents",
                "Categories are properties, not structure",
                "Parsers filter by category, don't navigate structure"
              ]
            },
            "subcategory": {
              "type": "string",
              "description": "Optional fine-grained grouping within category",
              "pattern": "^[a-z][a-z0-9_]*$",
              "examples": [
                "intent",
                "code",
                "compliance"
              ],
              "notes": [
                "Use when category alone is too broad",
                "Helps organize large rule sets"
              ]
            }
          },
          "optional_fields": {
            "scope": {
              "type": "string | array",
              "description": "Where this rule applies (paths, file patterns, contexts)",
              "examples": [
                "src/**/*.py",
                [
                  ".intent/charter/**",
                  ".intent/mind/**"
                ],
                [
                  "elevated_risk",
                  "critical_risk"
                ]
              ],
              "notes": [
                "Use glob patterns for file paths",
                "Can be single string or array of strings"
              ]
            },
            "details": {
              "type": "object",
              "description": "Additional context, examples, rationale, or configuration",
              "examples": [
                {
                  "example": "# src/module.py\n\"\"\"Module docstring\"\"\""
                },
                {
                  "rationale": "Prevents split-brain scenarios"
                },
                {
                  "exceptions": [
                    "Generated code",
                    "Test fixtures"
                  ]
                }
              ],
              "notes": [
                "Freeform object for rule-specific metadata",
                "Use for examples, rationale, exceptions, etc"
              ]
            },
            "rationale": {
              "type": "string",
              "description": "Why this rule exists (for human understanding)",
              "max_length": 1000,
              "examples": [
                "Files exceeding 400 lines violate single responsibility principle",
                "Prevents agents from modifying their own constraints"
              ]
            },
            "exceptions": {
              "type": "array",
              "description": "Documented exceptions to this rule",
              "items": {
                "type": "string"
              },
              "examples": [
                [
                  "Database model files (models.py)",
                  "Generated code with @generated marker"
                ]
              ]
            }
          }
        }
      }
    }
  },
  "deprecated_format": {
    "description": "The following nested structures are DEPRECATED and will be removed in version 3.0.0 of this standard.\n",
    "legacy_patterns": [
      {
        "section_name": "style_rules",
        "replacement": "rules array with category='style'",
        "deprecated_since": "v2.0.0",
        "removal_target": "v3.0.0"
      },
      {
        "section_name": "naming_conventions",
        "replacement": "rules array with category='naming', subcategory='code|intent'",
        "deprecated_since": "v2.0.0",
        "removal_target": "v3.0.0"
      },
      {
        "section_name": "capability_rules",
        "replacement": "rules array with category='capabilities'",
        "deprecated_since": "v2.0.0",
        "removal_target": "v3.0.0"
      },
      {
        "section_name": "agent_rules",
        "replacement": "rules array with category='agent_governance'",
        "deprecated_since": "v2.0.0",
        "removal_target": "v3.0.0"
      },
      {
        "section_name": "safety_rules",
        "replacement": "rules array with category='safety'",
        "deprecated_since": "v2.0.0",
        "removal_target": "v3.0.0"
      }
    ],
    "why_deprecated": [
      "Parsers must know every possible section name (fragile)",
      "Adding new categories breaks existing parsers",
      "Inconsistent: some sections are lists, some are nested dicts",
      "Not aligned with industry standards (Kubernetes, AWS, OPA)",
      "Harder to maintain and evolve"
    ]
  },
  "migration_timeline": {
    "v2_x": {
      "status": "Current - Backward Compatible",
      "description": "Both formats are supported. Parsers and auditors MUST handle both flat 'rules' array and legacy nested sections.\n",
      "policy_enforcement": [
        "New documents SHOULD use flat rules array",
        "Existing documents MAY continue using legacy format",
        "No warnings issued for legacy format"
      ]
    },
    "v3_0": {
      "status": "Future - Deprecation Warnings",
      "target_date": "2026-Q2",
      "description": "Legacy format is officially deprecated. Parsers MUST emit warnings when encountering nested sections.\n",
      "policy_enforcement": [
        "All NEW documents MUST use flat rules array",
        "Existing documents SHOULD migrate to new format",
        "Warnings issued for legacy format",
        "Tools provided to auto-migrate legacy documents"
      ]
    },
    "v4_0": {
      "status": "Future - Breaking Change",
      "target_date": "2026-Q4",
      "description": "Legacy format is removed. Only flat rules array supported.\n",
      "policy_enforcement": [
        "ALL documents MUST use flat rules array",
        "Legacy format rejected by validators",
        "Breaking change - major version bump"
      ]
    }
  },
  "migration_tools": {
    "description": "Tools to help migrate from legacy to new format",
    "auto_migration_script": {
      "path": "scripts/migrate_rules_format.py",
      "usage": "python3 scripts/migrate_rules_format.py --file POLICY.json",
      "capabilities": [
        "Detects legacy nested sections",
        "Extracts rules and adds category/subcategory properties",
        "Consolidates into single flat rules array",
        "Preserves all rule metadata and properties",
        "Creates backup before modifying"
      ]
    },
    "validation_check": {
      "command": "core-admin governance validate-structure",
      "description": "Checks all .intent documents for compliance with this standard"
    }
  },
  "industry_patterns": {
    "description": "This standard aligns with established patterns from major platforms that have proven effective at scale.\n",
    "kubernetes": {
      "pattern": "Flat resource definitions with labels/annotations for grouping",
      "example": "{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Pod\",\n  \"metadata\": {\n    \"labels\": {\n      \"app\": \"nginx\",\n      \"tier\": \"frontend\"\n    }\n  },\n  \"spec\": {\n    \"containers\": [\n      \"...\"\n    ]\n  }\n}\n",
      "lesson": "Labels (categories) are properties, not structural nesting"
    },
    "aws_iam": {
      "pattern": "Flat Statement array with Effect/Resource properties",
      "example": "{\n  \"Statement\": [\n    {\n      \"Effect\": \"Deny\",\n      \"Action\": \"s3:Delete\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n",
      "lesson": "Single Statement array, categorized by properties"
    },
    "opa_rego": {
      "pattern": "Flat rule definitions with metadata as properties",
      "example": "package kubernetes.admission\n\ndeny[msg] {\n  input.kind == \"Pod\"\n  not secure(input)\n  msg := \"Pod must be secure\"\n}\n",
      "lesson": "Rules are flat, context is in properties"
    }
  },
  "examples": {
    "minimal_policy": {
      "description": "Minimal valid policy with rules",
      "content": "{\n  \"id\": \"example_policy\",\n  \"version\": \"2.0.0\",\n  \"title\": \"Example Policy\",\n  \"type\": \"standard\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"Team Lead\"\n  },\n  \"review\": {\n    \"frequency\": \"12 months\"\n  },\n  \"schema_id\": \"policy.structure\",\n  \"rules\": [\n    {\n      \"id\": \"example.rule_one\",\n      \"statement\": \"All code MUST pass linting\",\n      \"enforcement\": \"error\"\n    },\n    {\n      \"id\": \"example.rule_two\",\n      \"statement\": \"Functions SHOULD have docstrings\",\n      \"enforcement\": \"warn\"\n    }\n  ]\n}\n"
    },
    "full_featured_rule": {
      "description": "Rule with all optional fields",
      "content": "{\n  \"id\": \"style.linter_required\",\n  \"category\": \"style\",\n  \"subcategory\": \"quality\",\n  \"statement\": \"All changes MUST pass ruff (lint) before merge.\",\n  \"enforcement\": \"error\",\n  \"scope\": [\n    \"src/**/*.py\",\n    \"tests/**/*.py\"\n  ],\n  \"rationale\": \"Linting catches common bugs and enforces consistent code style, reducing review burden and improving code quality.\",\n  \"exceptions\": [\n    \"Generated code with @generated marker\",\n    \"Third-party vendored code\"\n  ],\n  \"details\": {\n    \"fix_command\": \"ruff check --fix src/ tests/\",\n    \"documentation\": \"https://docs.astral.sh/ruff/\"\n  }\n}\n"
    },
    "migrated_policy": {
      "description": "Before and after migration from legacy format",
      "before": "{\n  \"style_rules\": [\n    {\n      \"id\": \"style.linter_required\",\n      \"statement\": \"...\"\n    }\n  ],\n  \"naming_conventions\": {\n    \"code\": [\n      {\n        \"id\": \"code.python_module_naming\",\n        \"statement\": \"...\"\n      }\n    ],\n    \"intent\": [\n      {\n        \"id\": \"intent.policy_file_naming\",\n        \"statement\": \"...\"\n      }\n    ]\n  }\n}\n",
      "after": "{\n  \"rules\": [\n    {\n      \"id\": \"style.linter_required\",\n      \"category\": \"style\",\n      \"statement\": \"...\"\n    },\n    {\n      \"id\": \"code.python_module_naming\",\n      \"category\": \"naming\",\n      \"subcategory\": \"code\",\n      \"statement\": \"...\"\n    },\n    {\n      \"id\": \"intent.policy_file_naming\",\n      \"category\": \"naming\",\n      \"subcategory\": \"intent\",\n      \"statement\": \"...\"\n    }\n  ]\n}\n"
    }
  },
  "parser_guidance": {
    "description": "How parsers and auditors should handle rules",
    "loading_rules": {
      "v2_backward_compatible": "# Support both formats during v2.x\nrules = []\n\n# Try new format first (preferred)\nif \"rules\" in document and isinstance(document[\"rules\"], list):\n    rules = document[\"rules\"]\n\n# Fallback to legacy format\nelse:\n    # Check all known legacy sections\n    for section in [\"style_rules\", \"agent_rules\", \"naming_conventions\"]:\n        if section in document:\n            if isinstance(document[section], list):\n                rules.extend(document[section])\n            elif isinstance(document[section], dict):\n                # Handle nested structure (like naming_conventions)\n                for subsection, subrules in document[section].items():\n                    if isinstance(subrules, list):\n                        rules.extend(subrules)\n\nreturn rules\n",
      "v3_with_warnings": "# Emit warnings for legacy format in v3.x\nif \"rules\" in document:\n    return document[\"rules\"]\n\n# Legacy format detected\nlogger.warning(\n    f\"Document {document_path} uses deprecated legacy format. \"\n    f\"Migrate to 'rules' array by 2026-Q4. \"\n    f\"See RULES-STRUCTURE.json for migration guide.\"\n)\n# ... then load from legacy sections\n",
      "v4_strict": "# Only accept new format in v4.x\nif \"rules\" not in document:\n    raise ValidationError(\n        f\"Document {document_path} missing required 'rules' array. \"\n        f\"Legacy formats removed in v4.0. \"\n        f\"See RULES-STRUCTURE.json migration guide.\"\n    )\nreturn document[\"rules\"]\n"
    },
    "filtering_by_category": {
      "example": "# Filter rules by category\nall_rules = document.get(\"rules\", [])\nstyle_rules = [r for r in all_rules if r.get(\"category\") == \"style\"]\n\n# Filter by category and subcategory\ncode_naming_rules = [\n    r for r in all_rules\n    if r.get(\"category\") == \"naming\"\n    and r.get(\"subcategory\") == \"code\"\n]\n"
    }
  },
  "validation_rules": {
    "document_level": [
      "Documents with enforceable content MUST have a 'rules' array",
      "The 'rules' field MUST be an array (not dict, not null)",
      "Empty rules array is valid (document may be informational)"
    ],
    "rule_level": [
      "Each rule MUST have: id, statement, enforcement",
      "Rule id MUST be unique within constitutional scope (all .intent docs)",
      "Rule id MUST match pattern: ^[a-z][a-z0-9._-]*$",
      "Statement MUST be non-empty string, max 500 characters",
      "Enforcement MUST be one of: error, warn, warning, info",
      "Category, if present, MUST match pattern: ^[a-z][a-z0-9_]*$"
    ],
    "cross_document": [
      "Rule IDs MUST be globally unique across all .intent documents",
      "Categories SHOULD be consistent across documents (use standard names)",
      "Referenced schemas in 'details' SHOULD exist"
    ]
  },
  "benefits": {
    "parser_robustness": [
      "Parsers never break when new categories are added",
      "Single code path for all rule types",
      "No special handling for nested structures"
    ],
    "maintainability": [
      "Easy to add new rules without structural changes",
      "Categories emerge naturally from usage patterns",
      "No coordination needed to add new rule types"
    ],
    "tooling": [
      "Coverage tools can count rules consistently",
      "Migration tools can normalize formats automatically",
      "Validation tools have single rule schema"
    ],
    "developer_experience": [
      "Clear, predictable structure",
      "Industry-standard pattern (familiar to developers)",
      "Self-documenting (categories visible in each rule)"
    ]
  }
}

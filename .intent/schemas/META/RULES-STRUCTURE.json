{
  "id": "rules_structure_standard",
  "version": "2.0.0",
  "title": "Universal Rules Structure Standard",
  "type": "constitutional_standard",
  "status": "active",
  "owners": {
    "accountable": "Governance Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "rules.structure",
  "purpose": "Establishes the canonical structure for ALL .intent documents that define enforceable rules, auditable checks, or validatable constraints.\nThis standard ensures: - Consistent rule discovery across all document types - Parser-friendly structure that never breaks with new categories - Clear separation between metadata and enforcement content - Industry alignment with Kubernetes, AWS, and OPA patterns\n",
  "scope": {
    "applies_to": [
      "Constitutional documents (authority.json, boundaries.json, risk_classification.json)",
      "Policy standards (code_standards.json, logging_standards.json, data_governance.json)",
      "Architectural patterns (agent_patterns.json, workflow_patterns.json, service_patterns.json)",
      "Operational standards (operations.json, safety.json, observability.json)",
      "Schemas with validation rules (any schema defining checkable constraints)"
    ],
    "does_not_apply_to": [
      "Pure metadata documents (document that only describe, not enforce)",
      "Registry documents (lists without enforcement rules)",
      "Configuration files (runtime config without governance rules)",
      "Knowledge bases (informational content without checks)"
    ]
  },
  "format_status": {
    "current_version": "v2.0.0",
    "status": "stable",
    "migration_completed": "2024-12-28",
    "description": "All CORE policies use v2 flat rules format. Legacy nested formats have been removed from the system.",
    "enforcement": "PolicyFormatCheck enforces v2 format at runtime, rejecting any legacy formats.",
    "parser_simplification": "All parsers updated to use single-path v2 format loading. Backward compatibility code removed."
  },
  "canonical_structure": {
    "description": "Documents containing enforceable rules MUST use a single flat 'rules' array at the top level. All rules exist in this array regardless of their category, type, or enforcement level.\n",
    "schema_resolution": {
      "description": "CRITICAL: How schema_id is used in documents with enforceable rules. This prevents validator drift and parser confusion.\n",
      "rule": "The document's schema_id identifies the DOCUMENT STRUCTURE schema (e.g., policy.structure, pattern.structure).\nEach item in the rules[] array conforms to THIS standard (rules.structure) regardless of the document type.\n",
      "example": "{\n  \"id\": \"code_standards\",\n  \"schema_id\": \"policy.structure\",\n  \"rules\": [\n    {\n      \"id\": \"style.linter_required\",\n      \"statement\": \"...\",\n      \"enforcement\": \"error\",\n      \"check\": { \"engine\": \"ast_gate\", \"params\": { \"plugin\": \"ruff\" } }\n    }\n  ]\n}\n",
      "validation": "Validators MUST: 1. Validate document header against document's schema_id 2. Validate each rules[] item against rules.structure 3. Reject documents with schema_id mismatch\n"
    },
    "required_format": {
      "rules": {
        "type": "array",
        "description": "Flat array of ALL enforceable rules in this document",
        "required": true,
        "location": "Top-level field in document",
        "item_schema": {
          "description": "Each rule in the array MUST follow this schema",
          "required_fields": {
            "id": {
              "type": "string",
              "description": "Unique identifier for this rule within the constitutional scope",
              "pattern": "^[a-z][a-z0-9._-]*$",
              "examples": [
                "style.linter_required",
                "agent.compliance.no_write_intent",
                "safety.immutable_constitution",
                "di.constructor_injection_preferred"
              ],
              "notes": [
                "Must be globally unique across all .intent documents",
                "Use dot notation for hierarchical organization",
                "Lowercase with underscores, dots, or hyphens only"
              ]
            },
            "statement": {
              "type": "string",
              "description": "Clear, imperative declaration of what must be true",
              "max_length": 500,
              "examples": [
                "All changes MUST pass ruff (lint) before merge.",
                "Agents MUST NOT write directly to '.intent/charter/**'.",
                "Services SHOULD receive dependencies through __init__ constructor."
              ],
              "notes": [
                "Use MUST/SHOULD/MAY keywords (RFC 2119 style)",
                "Be specific and actionable",
                "Focus on the requirement, not the implementation"
              ]
            },
            "enforcement": {
              "type": "string",
              "description": "Severity/priority level for this rule",
              "allowed_values": [
                "error",
                "warn",
                "warning",
                "info"
              ],
              "examples": [
                "error",
                "warn"
              ],
              "notes": [
                "Use 'error' for constitutional requirements",
                "Use 'warn' for best practices",
                "Use 'info' for guidance/documentation"
              ]
            },
            "check": {
              "type": "object",
              "description": "The mandatory machine-executable logic for this rule.",
              "required": [
                "engine"
              ],
              "properties": {
                "engine": {
                  "type": "string",
                  "enum": [
                    "ast_gate",
                    "regex_gate",
                    "glob_gate",
                    "python_handler",
                    "llm_gate"
                  ],
                  "description": "The engine in src/mind/logic/engines/ that executes the verification."
                },
                "params": {
                  "type": "object",
                  "description": "Key-value pairs for the engine (e.g. forbidden_calls, patterns, or handler_id)."
                }
              }
            }
          },
          "recommended_fields": {
            "category": {
              "type": "string",
              "description": "High-level grouping for this rule",
              "pattern": "^[a-z][a-z0-9_]*$",
              "examples": [
                "style",
                "safety",
                "agent_governance",
                "dependency_injection",
                "naming",
                "capabilities"
              ],
              "notes": [
                "Use consistent categories across documents",
                "Categories are properties, not structure",
                "Parsers filter by category, don't navigate structure"
              ]
            },
            "subcategory": {
              "type": "string",
              "description": "Optional fine-grained grouping within category",
              "pattern": "^[a-z][a-z0-9_]*$",
              "examples": [
                "intent",
                "code",
                "compliance"
              ],
              "notes": [
                "Use when category alone is too broad",
                "Helps organize large rule sets"
              ]
            }
          },
          "optional_fields": {
            "scope": {
              "type": "string | array",
              "description": "Where this rule applies (paths, file patterns, contexts)",
              "examples": [
                "src/**/*.py",
                [
                  ".intent/charter/**",
                  ".intent/mind/**"
                ],
                [
                  "elevated_risk",
                  "critical_risk"
                ]
              ],
              "notes": [
                "Use glob patterns for file paths",
                "Can be single string or array of strings"
              ]
            },
            "details": {
              "type": "object",
              "description": "Additional context, examples, rationale, or configuration",
              "examples": [
                {
                  "example": "# src/module.py\n\"\"\"Module docstring\"\"\""
                },
                {
                  "rationale": "Prevents split-brain scenarios"
                },
                {
                  "exceptions": [
                    "Generated code",
                    "Test fixtures"
                  ]
                }
              ],
              "notes": [
                "Freeform object for rule-specific metadata",
                "Use for examples, rationale, exceptions, etc"
              ]
            },
            "rationale": {
              "type": "string",
              "description": "Why this rule exists (for human understanding)",
              "max_length": 1000,
              "examples": [
                "Files exceeding 400 lines violate single responsibility principle",
                "Prevents agents from modifying their own constraints"
              ]
            },
            "exceptions": {
              "type": "array",
              "description": "Documented exceptions to this rule",
              "items": {
                "type": "string"
              },
              "examples": [
                [
                  "Database model files (models.py)",
                  "Generated code with @generated marker"
                ]
              ]
            }
          }
        }
      }
    }
  },
  "industry_patterns": {
    "description": "This standard aligns with established patterns from major platforms that have proven effective at scale.\n",
    "kubernetes": {
      "pattern": "Flat resource definitions with labels/annotations for grouping",
      "example": "{\n  \"apiVersion\": \"v1\",\n  \"kind\": \"Pod\",\n  \"metadata\": {\n    \"labels\": {\n      \"app\": \"nginx\",\n      \"tier\": \"frontend\"\n    }\n  },\n  \"spec\": {\n    \"containers\": [\n      \"...\"\n    ]\n  }\n}\n",
      "lesson": "Labels (categories) are properties, not structural nesting"
    },
    "aws_iam": {
      "pattern": "Flat Statement array with Effect/Resource properties",
      "example": "{\n  \"Statement\": [\n    {\n      \"Effect\": \"Deny\",\n      \"Action\": \"s3:Delete\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\n",
      "lesson": "Single Statement array, categorized by properties"
    },
    "opa_rego": {
      "pattern": "Flat rule definitions with metadata as properties",
      "example": "package kubernetes.admission\n\ndeny[msg] {\n  input.kind == \"Pod\"\n  not secure(input)\n  msg := \"Pod must be secure\"\n}\n",
      "lesson": "Rules are flat, context is in properties"
    }
  },
  "examples": {
    "minimal_policy": {
      "description": "Minimal valid policy with rules",
      "content": "{\n  \"id\": \"example_policy\",\n  \"version\": \"2.0.0\",\n  \"title\": \"Example Policy\",\n  \"type\": \"standard\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"Team Lead\"\n  },\n  \"review\": {\n    \"frequency\": \"12 months\"\n  },\n  \"schema_id\": \"policy.structure\",\n  \"rules\": [\n    {\n      \"id\": \"example.rule_one\",\n      \"statement\": \"All code MUST pass linting\",\n      \"enforcement\": \"error\"\n    },\n    {\n      \"id\": \"example.rule_two\",\n      \"statement\": \"Functions SHOULD have docstrings\",\n      \"enforcement\": \"warn\"\n    }\n  ]\n}\n"
    },
    "full_featured_rule": {
      "description": "Rule with all optional fields",
      "content": "{\n  \"id\": \"style.linter_required\",\n  \"category\": \"style\",\n  \"subcategory\": \"quality\",\n  \"statement\": \"All changes MUST pass ruff (lint) before merge.\",\n  \"enforcement\": \"error\",\n  \"scope\": [\n    \"src/**/*.py\",\n    \"tests/**/*.py\"\n  ],\n  \"rationale\": \"Linting catches common bugs and enforces consistent code style, reducing review burden and improving code quality.\",\n  \"exceptions\": [\n    \"Generated code with @generated marker\",\n    \"Third-party vendored code\"\n  ],\n  \"details\": {\n    \"fix_command\": \"ruff check --fix src/ tests/\",\n    \"documentation\": \"https://docs.astral.sh/ruff/\"\n  }\n}\n"
    },
    "category_filtering": {
      "description": "How to filter rules by category in code",
      "content": "# Load all rules from document\nall_rules = document.get('rules', [])\n\n# Filter by category\nstyle_rules = [r for r in all_rules if r.get('category') == 'style']\n\n# Filter by category and subcategory\ncode_naming_rules = [\n    r for r in all_rules\n    if r.get('category') == 'naming'\n    and r.get('subcategory') == 'code'\n]\n"
    }
  },
  "parser_guidance": {
    "description": "How parsers and auditors should handle v2 format",
    "loading_rules": {
      "v2_format": "# Load rules from v2 flat format (stable)\nrules = document.get('rules', [])\nif not isinstance(rules, list):\n    raise ValidationError('rules must be an array')\nreturn rules\n"
    },
    "filtering_by_category": {
      "example": "# Filter rules by category\nall_rules = document.get('rules', [])\nstyle_rules = [r for r in all_rules if r.get('category') == 'style']\n\n# Filter by category and subcategory\ncode_naming_rules = [\n    r for r in all_rules\n    if r.get('category') == 'naming'\n    and r.get('subcategory') == 'code'\n]\n"
    }
  },
  "validation_rules": {
    "document_level": [
      "Documents with enforceable content MUST have a 'rules' array",
      "The 'rules' field MUST be an array (not dict, not null)",
      "Empty rules array is valid (document may be informational)"
    ],
    "rule_level": [
      "Each rule MUST have: id, statement, enforcement",
      "Rule id MUST be unique within constitutional scope (all .intent docs)",
      "Rule id MUST match pattern: ^[a-z][a-z0-9._-]*$",
      "Statement MUST be non-empty string, max 500 characters",
      "Enforcement MUST be one of: error, warn, warning, info",
      "Category, if present, MUST match pattern: ^[a-z][a-z0-9_]*$"
    ],
    "cross_document": [
      "Rule IDs MUST be globally unique across all .intent documents",
      "Categories SHOULD be consistent across documents (use standard names)",
      "Referenced schemas in 'details' SHOULD exist"
    ]
  },
  "additionalProperties": false
}

{
  "id": "policy_structure_standard",
  "version": "2.0.0",
  "title": "Policy Document Structure Standard",
  "type": "constitutional_standard",
  "status": "active",
  "owners": {
    "accountable": "Governance Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "policy.structure",
  "purpose": "Establishes the canonical structure for policy documents that define governance standards, operational requirements, and architectural rules.\nPolicies are prescriptive documents that establish \"how things must be done\" and are enforced through constitutional auditing.\n",
  "scope": {
    "applies_to": [
      ".intent/charter/standards/**/*.json",
      "Any document of type: standard_*"
    ],
    "examples": [
      "code_standards.json - Code quality and style policies",
      "logging_standards.json - Logging requirements",
      "data_governance.json - Data handling policies",
      "operations.json - Operational procedures",
      "safety.json - Safety and security policies"
    ]
  },
  "canonical_structure": {
    "description": "All policy documents MUST follow this structure. This ensures consistent discovery, parsing, and enforcement.\n",
    "required_sections": {
      "header": {
        "description": "Standard document header (per GLOBAL-DOCUMENT-META-SCHEMA)",
        "required_fields": [
          "id",
          "version",
          "title",
          "type",
          "status",
          "owners",
          "review",
          "schema_id"
        ],
        "schema_id_usage": {
          "description": "CRITICAL: How to set schema_id for policy documents",
          "rule": "Policy documents use schema_id in TWO layers:\n1. DOCUMENT LEVEL: schema_id identifies the policy structure\n   Set to: \"policy.structure\" (this validates the document)\n\n2. RULES LEVEL: Each item in rules[] conforms to rules.structure\n   (This is implicit - you don't set it per rule)\n",
          "example": "{\n  \"id\": \"code_standards\",\n  \"schema_id\": \"policy.structure\",\n  \"rules\": [\n    {\n      \"id\": \"style.linter\",\n      \"statement\": \"...\",\n      \"enforcement\": \"error\"\n    }\n  ]\n}\n",
          "anti_pattern": "{\n  \"schema_id\": \"rules.structure\"\n}\n"
        },
        "notes": [
          "type SHOULD start with 'standard_' (e.g. standard_code, standard_operations)",
          "If document has no rules, schema_id can be policy.structure or pattern.structure"
        ]
      },
      "purpose": {
        "type": "string",
        "description": "Clear statement of what this policy governs and why it exists",
        "max_length": 1000,
        "required": true,
        "example": "Unified standards for code quality, style, naming, and refactoring patterns. Ensures consistent, maintainable, and safe code across the entire codebase.\n"
      },
      "rules": {
        "type": "array",
        "description": "Enforceable rules (MUST follow RULES-STRUCTURE.json)",
        "required": true,
        "reference": "See RULES-STRUCTURE.json for complete specification",
        "policy_specific_guidance": {
          "categories": {
            "description": "Policies SHOULD use consistent category names",
            "recommended_categories": {
              "code": [
                "style - Code formatting and conventions",
                "naming - File and symbol naming",
                "complexity - Size and complexity limits",
                "quality - Code health metrics"
              ],
              "operations": [
                "logging - Logging standards",
                "monitoring - Observability requirements",
                "deployment - Deployment procedures",
                "incident_response - IR protocols"
              ],
              "architecture": [
                "dependency_injection - DI patterns",
                "layer_separation - Architectural boundaries",
                "service_patterns - Service design",
                "data_flow - Data movement rules"
              ],
              "governance": [
                "agent_governance - AI agent constraints",
                "safety - Safety mechanisms",
                "audit - Audit requirements",
                "compliance - Compliance checks"
              ]
            }
          },
          "enforcement_levels": {
            "error": {
              "description": "Constitutional requirement - blocking violation",
              "when_to_use": [
                "Safety-critical requirements",
                "Architectural invariants",
                "Legal/compliance mandates"
              ],
              "examples": [
                "Agents MUST NOT modify constitution files",
                "All changes MUST pass linting",
                "Secrets MUST NOT be hardcoded"
              ]
            },
            "warn": {
              "description": "Best practice - should be followed but not blocking",
              "when_to_use": [
                "Code quality guidelines",
                "Recommended patterns",
                "Emerging standards"
              ],
              "examples": [
                "Functions SHOULD have docstrings",
                "Modules SHOULD not exceed 400 lines",
                "Use dependency injection where practical"
              ]
            },
            "info": {
              "description": "Guidance - informational only",
              "when_to_use": [
                "Documentation references",
                "Cross-references to other policies",
                "Aspirational goals"
              ],
              "examples": [
                "See dependency_injection.json for DI patterns",
                "Consider using asyncio for I/O operations"
              ]
            }
          }
        }
      }
    },
    "optional_sections": {
      "background": {
        "type": "string",
        "description": "Historical context or rationale for policy creation",
        "max_length": 2000
      },
      "definitions": {
        "type": "object",
        "description": "Key terms used in policy rules",
        "example": {
          "terms": {
            "constitutional_file": "Any file under .intent/charter/**",
            "dangerous_operation": "File deletion, database migration, schema change"
          }
        }
      },
      "reference_data": {
        "type": "object",
        "description": "Supporting data that informs but is not enforced",
        "examples": [
          "health_standards: {max_complexity: 15, max_nesting: 4}",
          "refactoring_patterns: [{id: extract_function, ...}]"
        ],
        "notes": [
          "Reference data provides context but is NOT scanned by checkers",
          "Put enforceable limits in rules array, not reference data"
        ]
      }
    }
  },
  "policy_categories": {
    "description": "Standard categories for organizing policies. These are not enforced structurally but help with discovery and understanding.\n",
    "code_policies": {
      "description": "Policies governing source code quality and structure",
      "examples": [
        "code_standards.json - Overall code quality",
        "code_purity.json - Functional purity requirements",
        "refactoring_standards.json - Safe refactoring practices"
      ],
      "typical_rule_categories": [
        "style",
        "naming",
        "complexity",
        "quality",
        "documentation"
      ]
    },
    "operations_policies": {
      "description": "Policies governing operational procedures",
      "examples": [
        "operations.json - General operational standards",
        "safety.json - Safety mechanisms and constraints",
        "observability.json - Monitoring and logging",
        "incident_response.json - IR procedures"
      ],
      "typical_rule_categories": [
        "logging",
        "monitoring",
        "deployment",
        "safety",
        "security"
      ]
    },
    "architecture_policies": {
      "description": "Policies governing system architecture",
      "examples": [
        "dependency_injection.json - DI requirements",
        "layer_contracts.json - Layer boundaries",
        "service_patterns.json - Service design"
      ],
      "typical_rule_categories": [
        "dependency_injection",
        "layer_separation",
        "service_patterns",
        "data_flow"
      ]
    },
    "governance_policies": {
      "description": "Policies governing AI agents and autonomy",
      "examples": [
        "agent_governance.json - Agent constraints",
        "code_execution.json - Dynamic code rules",
        "policy_integrity.json - Policy management"
      ],
      "typical_rule_categories": [
        "agent_governance",
        "autonomy",
        "validation",
        "audit"
      ]
    }
  },
  "enforcement": {
    "description": "How policy rules are discovered and enforced by the constitutional audit system.\n",
    "discovery": {
      "process": [
        "Auditor scans .intent/charter/standards/**/*.json",
        "Loads documents with schema_id='policy.structure'",
        "Extracts rules array from each policy",
        "Builds rule registry indexed by rule.id"
      ],
      "registration": {
        "description": "Each rule is registered with auditor by its id",
        "example": "style.linter_required â†’ Auditor.rule_registry['style.linter_required']"
      }
    },
    "checker_implementation": {
      "description": "Checkers in src/mind/governance/checks/ implement rule enforcement",
      "pattern": "class MyPolicyCheck(BaseCheck):\n    \"\"\"Enforces rules from my_policy.json\"\"\"\n\n    policy_rule_ids = [\n        \"my_policy.rule_one\",\n        \"my_policy.rule_two\",\n    ]\n\n    def __init__(self, context: AuditorContext):\n        super().__init__(context)\n\n        # Load policy rules (supports both old and new formats)\n        policy = context.policies.get(\"my_policy\", {})\n        all_rules = policy.get(\"rules\", [])\n\n        # Filter by category if needed\n        my_rules = [r for r in all_rules if r.get(\"category\") == \"my_category\"]\n\n        # Build lookup\n        self.rules_by_id = {r[\"id\"]: r for r in my_rules}\n\n    def execute(self) -> list[AuditFinding]:\n        findings = []\n        for rule_id, rule in self.rules_by_id.items():\n            # Check compliance with rule\n            if violation_detected:\n                findings.append(AuditFinding(\n                    check_id=rule_id,\n                    severity=AuditSeverity[rule[\"enforcement\"].upper()],\n                    message=f\"Violation of {rule_id}: {rule['statement']}\",\n                    ...\n                ))\n        return findings\n",
      "backward_compatibility": {
        "description": "During v2.x, checkers MUST support both formats",
        "pattern": "# Support both new (rules array) and old (nested sections)\nall_rules = policy.get(\"rules\", [])\n\nif not all_rules:\n    # Fallback to old format\n    all_rules = policy.get(\"style_rules\", [])\n    all_rules.extend(policy.get(\"naming_conventions\", {}).get(\"code\", []))\n"
      }
    },
    "coverage_tracking": {
      "description": "Enforcement coverage tracks which rules have active checkers",
      "metrics": [
        "Total rules declared across all policies",
        "Rules with active checkers (enforced)",
        "Rules without checkers (declared only)",
        "Enforcement rate per policy",
        "Enforcement rate per category"
      ],
      "reporting": {
        "command": "core-admin governance coverage",
        "formats": [
          "summary - Flat list of all rules",
          "hierarchical - Grouped by policy (progressive disclosure)",
          "json - Machine-readable export"
        ]
      }
    }
  },
  "examples": {
    "minimal_policy": {
      "description": "Simplest valid policy document",
      "content": "{\n  \"id\": \"example_policy\",\n  \"version\": \"1.0.0\",\n  \"title\": \"Example Policy\",\n  \"type\": \"standard_example\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"Policy Owner\",\n    \"responsible\": [\n      \"Team Lead\"\n    ]\n  },\n  \"review\": {\n    \"frequency\": \"12 months\"\n  },\n  \"schema_id\": \"policy.structure\",\n  \"purpose\": \"Demonstrates minimal valid policy structure.\",\n  \"rules\": [\n    {\n      \"id\": \"example.basic_rule\",\n      \"statement\": \"All code MUST pass basic validation\",\n      \"enforcement\": \"error\"\n    }\n  ]\n}\n"
    },
    "full_featured_policy": {
      "description": "Policy with all recommended sections",
      "content": "{\n  \"id\": \"code_quality_policy\",\n  \"version\": \"2.0.0\",\n  \"title\": \"Code Quality Policy\",\n  \"type\": \"standard_code\",\n  \"status\": \"active\",\n  \"owners\": {\n    \"accountable\": \"Code Quality Lead\",\n    \"responsible\": [\n      \"Core Maintainers\",\n      \"Tech Leads\"\n    ]\n  },\n  \"review\": {\n    \"frequency\": \"6 months\",\n    \"last_reviewed\": \"2025-12-01\",\n    \"next_review_due\": \"2026-06-01\"\n  },\n  \"schema_id\": \"policy.structure\",\n  \"purpose\": \"Establishes code quality standards to ensure maintainable, reliable, and consistent code across the entire codebase.\",\n  \"background\": \"Created in response to increased technical debt and inconsistent code quality across teams. Consolidates scattered guidelines into single authoritative policy.\",\n  \"definitions\": {\n    \"terms\": {\n      \"public_symbol\": \"Function or class not prefixed with underscore\",\n      \"critical_path\": \"Code that affects system safety or data integrity\"\n    }\n  },\n  \"rules\": [\n    {\n      \"id\": \"style.linter_required\",\n      \"category\": \"style\",\n      \"statement\": \"All code MUST pass ruff linting\",\n      \"enforcement\": \"error\",\n      \"scope\": [\n        \"src/**/*.py\",\n        \"tests/**/*.py\"\n      ],\n      \"rationale\": \"Catches bugs and enforces consistency\",\n      \"details\": {\n        \"fix_command\": \"ruff check --fix\"\n      }\n    },\n    {\n      \"id\": \"naming.module_naming\",\n      \"category\": \"naming\",\n      \"subcategory\": \"code\",\n      \"statement\": \"Python modules MUST use snake_case\",\n      \"enforcement\": \"error\",\n      \"scope\": \"src/**/*.py\",\n      \"exceptions\": [\n        \"__init__.py\"\n      ]\n    },\n    {\n      \"id\": \"complexity.max_function_lines\",\n      \"category\": \"complexity\",\n      \"statement\": \"Functions SHOULD NOT exceed 50 lines\",\n      \"enforcement\": \"warn\",\n      \"rationale\": \"Long functions are hard to test and understand\",\n      \"exceptions\": [\n        \"Main entry points orchestrating workflow\",\n        \"Generated code\"\n      ]\n    }\n  ],\n  \"health_standards\": {\n    \"max_cognitive_complexity\": 15,\n    \"max_nesting_depth\": 4,\n    \"recommended_test_coverage\": 75\n  }\n}\n"
    }
  },
  "migration_guide": {
    "description": "How to migrate existing policies to v2.0 format",
    "step_by_step": {
      "step_1": {
        "task": "Add schema_id field",
        "action": "Add `schema_id: \"policy.structure\"` to document header"
      },
      "step_2": {
        "task": "Create flat rules array",
        "action": "Add top-level `rules: []` array"
      },
      "step_3": {
        "task": "Move rules from nested sections",
        "action": "For each legacy section (style_rules, naming_conventions, etc):\n- Extract each rule\n- Add category property matching section name\n- Move to flat rules array\n\nExample:\n  FROM:\n    style_rules:\n      - id: style.linter\n  TO:\n    rules:\n      - id: style.linter\n        category: style\n"
      },
      "step_4": {
        "task": "Handle nested structures",
        "action": "For nested dicts like naming_conventions:\n  naming_conventions:\n    code:\n      - id: code.python_naming\n\n  Becomes:\n    rules:\n      - id: code.python_naming\n        category: naming\n        subcategory: code\n"
      },
      "step_5": {
        "task": "Update checkers (optional during v2.x)",
        "action": "Checkers can remain backward compatible during v2.x.\nUpdate when convenient to use new format directly.\n"
      },
      "step_6": {
        "task": "Remove legacy sections",
        "action": "Once rules are migrated, remove old nested sections"
      },
      "step_7": {
        "task": "Test",
        "action": "core-admin check audit\ncore-admin governance coverage --format hierarchical\n"
      }
    },
    "automation": {
      "script": "scripts/migrate_policy_format.py",
      "usage": "python3 scripts/migrate_policy_format.py --policy code_standards.json"
    }
  },
  "validation_checklist": {
    "header": [
      "[ ] Document has all required header fields",
      "[ ] type starts with 'standard_'",
      "[ ] schema_id is 'policy.structure'",
      "[ ] version follows semver (X.Y.Z)"
    ],
    "content": [
      "[ ] purpose field explains what policy governs",
      "[ ] rules is a flat array (not nested dict)",
      "[ ] Each rule has: id, statement, enforcement",
      "[ ] Rule IDs follow pattern: ^[a-z][a-z0-9._-]*$",
      "[ ] Rule IDs are globally unique",
      "[ ] Categories are consistent with other policies",
      "[ ] Enforcement levels are: error, warn, or info"
    ],
    "quality": [
      "[ ] Statements are clear and actionable",
      "[ ] High-severity rules have rationale",
      "[ ] Scope is defined where applicable",
      "[ ] Examples provided for complex rules",
      "[ ] Reference data clearly separated from enforceable rules"
    ]
  },
  "best_practices": {
    "rule_design": [
      "Make statements imperative and specific",
      "Use RFC 2119 keywords (MUST, SHOULD, MAY)",
      "One concern per rule (atomic)",
      "Provide rationale for error-level rules",
      "Document exceptions explicitly"
    ],
    "category_organization": [
      "Use consistent category names across policies",
      "Keep categories broad (5-10 per policy max)",
      "Use subcategories for fine-grained grouping",
      "Don't create single-rule categories"
    ],
    "enforcement_levels": [
      "Use error for constitutional requirements",
      "Use warn for best practices",
      "Use info for cross-references",
      "Be consistent within category"
    ],
    "maintenance": [
      "Review policy every 6-12 months",
      "Update version on any rule change",
      "Document breaking changes in commit messages",
      "Keep reference data minimal"
    ]
  }
}

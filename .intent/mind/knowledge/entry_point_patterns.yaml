# .intent/mind/knowledge/entry_point_patterns.yaml
id: knowledge_entry_point_patterns
version: "2.0.0-meta"
title: "CORE Entry Point Patterns - Architectural Layers"
type: "knowledge_entry_point_patterns"
status: active

owners:
  accountable: "Governance Lead"
  responsible:
    - "Core Maintainer"

review:
  frequency: "12 months"

schema_id: "knowledge.entry_point_patterns"

# === META PHILOSOPHY ===
#
# Don't enumerate every function type. Instead, define ARCHITECTURAL RULES:
#
# 1. Framework Integration Points - Called by external frameworks
# 2. Infrastructure Layer - Public APIs by design
# 3. Provider Interfaces - Implement external contracts
# 4. Registry Dispatched - Found and invoked dynamically
#
# Everything else MUST have a capability ID or be private (_prefix)

patterns:
  # ========================================================================
  # LAYER 1: FRAMEWORK INTEGRATION POINTS
  # ========================================================================
  # These are called BY frameworks/Python itself, not by our code

  - name: "python_magic_methods"
    description: "Python dunder methods invoked by interpreter"
    entry_point_type: "magic_method"
    match:
      type: "function"
      name_regex: "^__.+__$"

  - name: "cli_entry_points"
    description: "All public functions in body/cli/ are Typer commands"
    entry_point_type: "cli_command"
    match:
      module_path_contains: "body/cli/"
      type: "function"
      is_public_function: true

  - name: "http_handlers"
    description: "All functions in api/ are FastAPI routes"
    entry_point_type: "http_endpoint"
    match:
      module_path_contains: "api/"
      type: "function"
      is_public_function: true

  - name: "action_handlers"
    description: "ActionHandler.execute() called by registry"
    entry_point_type: "action_handler"
    match:
      module_path_contains: "body/actions/"
      name_regex: "\\.(execute|name)$"
      type: "function"

  - name: "governance_checks"
    description: "BaseCheck.execute() called by auditor"
    entry_point_type: "governance_check"
    match:
      module_path_contains: "mind/governance/checks/"
      name_regex: "^execute$"
      type: "function"

  - name: "visitor_pattern"
    description: "visit_* methods called by ast.NodeVisitor"
    entry_point_type: "visitor_method"
    match:
      name_regex: "^visit_"
      type: "function"

  # ========================================================================
  # LAYER 2: INFRASTRUCTURE PUBLIC APIS
  # ========================================================================
  # The entire shared/infrastructure/ layer is PUBLIC by architectural design

  - name: "infrastructure_public_api"
    description: |
      ALL public functions in shared/infrastructure/ are intentional APIs.
      This is the service layer - everything here is meant to be called.
    entry_point_type: "infrastructure_api"
    match:
      module_path_contains: "shared/infrastructure/"
      type: "function"
      is_public_function: true
    rationale: |
      Infrastructure layer provides services to features/core/api.
      If a function shouldn't be public, make it private (_prefix).
      If it's public here, it's part of the service contract.

  # ========================================================================
  # LAYER 3: PROVIDER INTERFACES
  # ========================================================================
  # Providers implement external contracts (LLM, DB, vector stores)

  - name: "provider_implementations"
    description: "Provider interface implementations"
    entry_point_type: "provider_method"
    match:
      module_path_contains: "/providers/"
      type: "function"
      is_public_function: true
    rationale: |
      Providers implement interfaces (BaseProvider, BaseLLM, etc).
      They're called polymorphically, not directly referenced.

  # ========================================================================
  # LAYER 4: PROPERTY ACCESSORS
  # ========================================================================
  # Functions that behave like properties (getters, not methods)

  - name: "utility_accessors"
    description: "Path utilities and config getters accessed as properties"
    entry_point_type: "accessor"
    match:
      module_path_contains: "shared/"
      name_regex: "^(get_|.*_(dir|path|root)$)"
      type: "function"
    rationale: |
      These provide attribute-like access to paths/config.
      Used as: settings.logs_dir(), not settings._logs_dir()

  # ========================================================================
  # LAYER 5: EXPLICIT CAPABILITIES
  # ========================================================================
  # Anything with # ID: tag is a tracked capability

  - name: "tagged_capabilities"
    description: "Functions with explicit capability IDs"
    entry_point_type: "capability"
    match:
      has_capability_tag: true

# === ENFORCEMENT RULES ===
enforcement:
  # If a symbol doesn't match ANY pattern above:
  # 1. It's either a capability (needs # ID: tag)
  # 2. Or it's a helper (needs _prefix)
  # 3. Or it's dead code (delete it)

  orphan_resolution:
    - "Add # ID: <uuid> if it's a feature capability"
    - "Add _prefix if it's an internal helper"
    - "Delete if it's unused"

# === COVERAGE METRICS ===
# Track effectiveness of architectural patterns
metrics:
  total_patterns: 10  # Down from 30+ specific patterns
  architectural_layers_covered: 5
  expected_orphan_reduction: "90%"  # From 92 to ~10

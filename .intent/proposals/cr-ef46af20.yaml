action: replace_file
content: "```python\n# src/core/cli/risk_gates.py\n\"\"\"\nEnforce risk-tier gates\
  \ defined in .intent/evaluation/score_policy.yaml.\n\nUsage examples (from repo\
  \ root):\n  # Provide context via CLI flags\n  python -m src.core.cli.risk_gates\
  \ check --risk-tier high --score 0.92 \\\n      --touches-critical-paths --checkpoint\
  \ --canary --approver-quorum\n\n  # Or use a simple review context file, then optionally\
  \ override via CLI flags\n  python -m src.core.cli.risk_gates check --context review_context.yaml\n\
  \"\"\"\nfrom __future__ import annotations\n\nimport ast\nimport sys\nfrom dataclasses\
  \ import dataclass\nfrom pathlib import Path\nfrom typing import Any, Dict, List,\
  \ Optional\n\nimport typer\nimport yaml\n\napp = typer.Typer(add_completion=False,\
  \ help=\"Apply risk-tier gates from score_policy.yaml.\")\n\n@dataclass\nclass ReviewContext:\n\
  \    \"\"\"Data class representing the review context for risk gate evaluation.\"\
  \"\"\n    risk_tier: str = \"low\"\n    score: float = 0.0\n    touches_critical_paths:\
  \ bool = False\n    checkpoint: bool = False\n    canary: bool = False\n    approver_quorum:\
  \ bool = False\n\n# ---- Safe condition evaluator (supports: names, bool ops, comparisons,\
  \ 'in') ----\n_ALLOWED_NODES = {\n    ast.Expression, ast.BoolOp, ast.BinOp, ast.UnaryOp,\
  \ ast.Compare, ast.Name, ast.Load,\n    ast.Constant, ast.List, ast.Tuple, ast.And,\
  \ ast.Or, ast.Not, ast.In, ast.Eq, ast.NotEq,\n}\n\ndef _safe_eval(expr: str, ctx:\
  \ Dict[str, Any]) -> bool:\n    \"\"\"\n    Safely evaluate a boolean expression\
  \ with restricted AST nodes and context variables.\n    \n    Args:\n        expr:\
  \ The boolean expression string to evaluate\n        ctx: Dictionary of context\
  \ variables available for the expression\n        \n    Returns:\n        bool:\
  \ The result of evaluating the expression\n        \n    Raises:\n        ValueError:\
  \ If the expression contains unsupported AST nodes or unknown identifiers\n    \"\
  \"\"\n    # Normalize booleans (true/false) commonly used in YAML-like strings.\n\
  \    expr = expr.replace(\" true\", \" True\").replace(\" false\", \" False\")\n\
  \    tree = ast.parse(expr, mode=\"eval\")\n    for node in ast.walk(tree):\n  \
  \      if type(node) not in _ALLOWED_NODES:\n            raise ValueError(f\"Unsupported\
  \ expression node: {type(node).__name__}\")\n        if isinstance(node, ast.Name)\
  \ and node.id not in ctx:\n            raise ValueError(f\"Unknown identifier in\
  \ condition: {node.id}\")\n    return bool(eval(compile(tree, \"<cond>\", \"eval\"\
  ), {\"__builtins__\": {}}, ctx))\n\ndef _load_yaml(file_path: str) -> Optional[Dict[str,\
  \ Any]]:\n    \"\"\"\n    Load YAML content from a file using the shared utility\
  \ function.\n    \n    Args:\n        file_path: Path to the YAML file to load\n\
  \        \n    Returns:\n        Optional[Dict[str, Any]]: Parsed YAML content as\
  \ dictionary, or None if file doesn't exist\n    \"\"\"\n    from shared.utils.yaml_loader\
  \ import load_yaml_file\n    return load_yaml_file(file_path)\n\ndef _merge(a: ReviewContext,\
  \ b: ReviewContext) -> ReviewContext:\n    \"\"\"\n    Merge two ReviewContext objects,\
  \ with CLI context (b) overriding file context (a).\n    \n    Args:\n        a:\
  \ File context (from YAML file)\n        b: CLI context (from command line flags)\n\
  \        \n    Returns:\n        ReviewContext: Merged context with CLI values taking\
  \ precedence\n    \"\"\"\n    # CLI flags override file context when provided (typer\
  \ passes defaults if not set).\n    return ReviewContext(\n        risk_tier=b.risk_tier\
  \ or a.risk_tier,\n        score=b.score if b.score != 0.0 else a.score,\n     \
  \   touches_critical_paths=b.touches_critical_paths or a.touches_critical_paths,\n\
  \        checkpoint=b.checkpoint or a.checkpoint,\n        canary=b.canary or a.canary,\n\
  \        approver_quorum=b.approver_quorum or a.approver_quorum,\n    )\n\n@app.command(\"\
  check\")\ndef check(\n    mind_path: Path = typer.Option(Path(\".intent\"), \"--mind-path\"\
  , help=\"Path to the .intent directory.\"),\n    context: Optional[Path] = typer.Option(None,\
  \ \"--context\", help=\"YAML with review context fields.\"),\n    risk_tier: str\
  \ = typer.Option(\"low\", \"--risk-tier\", case_sensitive=False, help=\"low|medium|high\"\
  ),\n    score: float = typer.Option(0.0, \"--score\", help=\"Governance audit score\
  \ (0..1)\"),\n    touches_critical_paths: bool = typer.Option(False, \"--touches-critical-paths/--no-touches-critical-paths\"\
  ),\n    checkpoint: bool = typer.Option(False, \"--checkpoint/--no-checkpoint\"\
  ),\n    canary: bool = typer.Option(False, \"--canary/--no-canary\"),\n    approver_quorum:\
  \ bool = typer.Option(False, \"--approver-quorum/--no-approver-quorum\"),\n) ->\
  \ None:\n    \"\"\"\n    Enforce the gates defined in evaluation/score_policy.yaml\
  \ using the given context.\n    Fails (exit 1) if any requirement is not satisfied.\n\
  \    \n    Args:\n        mind_path: Path to the .intent directory containing score_policy.yaml\n\
  \        context: Optional YAML file with review context fields\n        risk_tier:\
  \ Risk tier classification (low|medium|high)\n        score: Governance audit score\
  \ between 0 and 1\n        touches_critical_paths: Whether the change touches critical\
  \ paths\n        checkpoint: Whether checkpoint approval is provided\n        canary:\
  \ Whether canary deployment is enabled\n        approver_quorum: Whether approver\
  \ quorum is met\n    \"\"\"\n    base = mind_path\n    spath = base / \"evaluation\"\
  \ / \"score_policy.yaml\"\n    if not spath.exists():\n        typer.echo(f\"Missing\
  \ score policy: {spath}\", err=True)\n        raise typer.Exit(code=2)\n\n    policy\
  \ = _load_yaml(spath)\n    gates: Dict[str, Any] = policy.get(\"risk_tier_gates\"\
  , {})\n    conds: Dict[str, str] = policy.get(\"gate_conditions\", {})\n\n    file_ctx\
  \ = ReviewContext()\n    if context and context.exists():\n        raw = _load_yaml(context)\n\
  \        file_ctx = ReviewContext(\n            risk_tier=str(raw.get(\"risk_tier\"\
  , \"low\")).lower(),\n            score=float(raw.get(\"score\", 0.0)),\n      \
  \      touches_critical_paths=bool(raw.get(\"touches_critical_paths\", False)),\n\
  \            checkpoint=bool(raw.get(\"checkpoint\", False)),\n            canary=bool(raw.get(\"\
  canary\", False)),\n            approver_quorum=bool(raw.get(\"approver_quorum\"\
  , False)),\n        )\n\n    cli_ctx = ReviewContext(\n        risk_tier=risk_tier.lower(),\n\
  \        score=score,\n        touches_critical_paths=touches_critical_paths,\n\
  \        checkpoint=checkpoint,\n        canary=canary,\n        approver_quorum=approver_quorum,\n\
  \    )\n    ctx = _merge(file_ctx, cli_ctx)\n\n    violations: List[str] = []\n\n\
  \    # 1) Risk-tier specific min score + required flags\n    tier = gates.get(ctx.risk_tier,\
  \ {}) if isinstance(gates, dict) else {}\n    min_score = float(tier.get(\"min_score\"\
  , 0.0))\n    required_flags = set(tier.get(\"require\", []) if isinstance(tier.get(\"\
  require\", []), list) else [])\n\n    if ctx.score < min_score:\n        violations.append(f\"\
  score {ctx.score:.2f} < min_score {min_score:.2f} for tier '{ctx.risk_tier}'\")\n\
  \n    # 2) Gate conditions (declarative rules)\n    cond_env = {\n        \"risk_tier\"\
  : ctx.risk_tier,\n        \"touches_critical_paths\": ctx.touches_critical_paths,\n\
  \        \"checkpoint\": ctx.checkpoint,\n        \"canary\": ctx.canary,\n    \
  \    \"approver_quorum\": ctx.approver_quorum,\n        \"score\": ctx.score,\n\
  \    }\n\n    def require_if(cond_key: str, flag_name: str) -> None:\n        \"\
  \"\"\n        Evaluate a conditional expression and add the required flag if condition\
  \ is met.\n        \n        Args:\n            cond_key: Key for the condition\
  \ in the gate_conditions dictionary\n            flag_name: Name of the flag to\
  \ require if condition evaluates to True\n        \"\"\"\n        expr = conds.get(cond_key)\n\
  \        if not expr:\n            return\n        try:\n            needed = _safe_eval(expr,\
  \ cond_env)\n        except Exception as e:\n            violations.append(f\"Invalid\
  \ gate condition '{cond_key}': {e}\")\n            return\n        if needed:\n\
  \            required_flags.add(flag_name)\n\n    require_if(\"checkpoint_required_when\"\
  , \"checkpoint\")\n    require_if(\"canary_required_when\", \"canary\")\n    require_if(\"\
  approver_quorum_required_when\", \"approver_quorum\")\n\n    # 3) Check required\
  \ flags are present/true in context\n    for flag in sorted(required_flags):\n \
  \       if not bool(getattr(ctx, flag, False)):\n            violations.append(f\"\
  required '{flag}' is missing/false for tier '{ctx.risk_tier}'\")\n\n    if violations:\n\
  \        typer.echo(\"Risk gate violations:\", err=True)\n        for v in violations:\n\
  \            typer.echo(f\" - {v}\", err=True)\n        raise typer.Exit(code=1)\n\
  \n    typer.echo(\"Risk gates satisfied \u2713\")\n\nif __name__ == \"__main__\"\
  :\n    app()\n```"
justification: Replace entire file with comprehensive docstrings for all functions,
  following project conventions. Added module docstring, function docstrings with
  Args/Returns/Raises sections, and improved code clarity while maintaining original
  functionality.
target_path: src/core/cli/risk_gates.py

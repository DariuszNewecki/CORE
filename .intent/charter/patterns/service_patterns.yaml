# .intent/charter/patterns/service_patterns.yaml
id: service_patterns
version: "1.0.0"
title: "Service Architecture Patterns"
description: |
  Defines canonical patterns for all infrastructure services in CORE.
  Services manage stateful resources (DB, vectors, LLMs) and provide
  clean interfaces for business logic.

patterns:
  - pattern_id: "stateful_service"
    type: "infrastructure"
    purpose: "Manage long-lived stateful resources"

    applies_to:
      - "Database connections"
      - "Vector store clients"
      - "LLM API clients"
      - "File system watchers"

    lifecycle:
      initialization:
        - "Load configuration from environment/config files"
        - "Validate connection parameters"
        - "Establish connection with retry logic"
        - "Verify service health"
        - "Log successful initialization"

      usage:
        - "Provide clean, typed interface"
        - "Handle transient failures gracefully"
        - "Implement connection pooling where appropriate"
        - "Cache results when safe"

      shutdown:
        - "Flush pending operations"
        - "Close connections cleanly"
        - "Log shutdown completion"

    implementation_requirements:
      structure:
        - "Single class per service"
        - "Dependency injection via constructor"
        - "No global state or singletons"
        - "Async-first where I/O bound"

      error_handling:
        - "MUST raise specific exceptions (not generic Exception)"
        - "MUST log errors with context"
        - "SHOULD implement retry with backoff"
        - "SHOULD provide circuit breaker for external services"

      testing:
        - "MUST be mockable (interface-based)"
        - "MUST have unit tests with mocked dependencies"
        - "SHOULD have integration tests with real services"

    example_skeleton: |
      class DatabaseService:
          """Manages PostgreSQL connection and operations."""

          def __init__(self, config: DatabaseConfig):
              self._config = config
              self._connection = None
              self._initialized = False

          async def initialize(self) -> None:
              """Establish database connection with validation."""
              # Connect, validate, set _initialized = True

          async def execute_query(self, query: str, params: dict) -> List[dict]:
              """Execute parameterized query with error handling."""
              if not self._initialized:
                  raise ServiceNotInitializedError()
              # Execute with retries, return results

          async def shutdown(self) -> None:
              """Clean shutdown of database connection."""
              # Close connection, cleanup resources

  - pattern_id: "stateless_transformer"
    type: "pure_logic"
    purpose: "Transform data without side effects"

    applies_to:
      - "Validators"
      - "Parsers"
      - "Formatters"
      - "Calculators"

    guarantees:
      - "Pure functions - same input always produces same output"
      - "No hidden state"
      - "No I/O operations"
      - "Easily testable"

    implementation_requirements:
      structure:
        - "Static methods or pure functions preferred"
        - "No instance variables (if class-based)"
        - "Type hints for all inputs/outputs"

      naming:
        - "Verbs that describe transformation: parse_, validate_, format_"

      testing:
        - "Property-based testing recommended"
        - "100% code coverage achievable"

    example_skeleton: |
      class YAMLProcessor:
          """Pure YAML processing operations."""

          @staticmethod
          def parse_strict(content: str) -> dict:
              """Parse YAML with strict validation."""
              # Pure transformation, no side effects

          @staticmethod
          def validate_schema(data: dict, schema: dict) -> List[str]:
              """Validate data against schema, return violations."""
              # Pure validation, returns results

  - pattern_id: "repository_pattern"
    type: "data_access"
    purpose: "Abstract database operations behind domain interface"

    applies_to:
      - "Symbol repository"
      - "Policy repository"
      - "Audit log repository"
      - "Capability repository"

    structure:
      interface_layer:
        - "Define domain operations (save_symbol, find_by_id, etc.)"
        - "Return domain objects, not raw DB rows"
        - "Hide SQL/query details from callers"

      implementation_layer:
        - "Translate domain operations to SQL"
        - "Handle connection management"
        - "Map DB rows to domain objects"

    implementation_requirements:
      naming:
        - "End with 'Repository': SymbolRepository"
        - "Methods follow domain language, not SQL"

      methods:
        standard_operations:
          - "async def save(entity: DomainObject) -> None"
          - "async def find_by_id(id: str) -> Optional[DomainObject]"
          - "async def find_all(filters: dict) -> List[DomainObject]"
          - "async def delete(id: str) -> bool"

        query_methods:
          - "Use domain-specific names: find_orphaned_symbols()"
          - "Return domain objects, not dictionaries"

      error_handling:
        - "Raise domain exceptions, not DB exceptions"
        - "NotFoundError instead of SQLAlchemy NoResultFound"

    example_skeleton: |
      class SymbolRepository:
          """Repository for Symbol domain objects."""

          def __init__(self, db_service: DatabaseService):
              self._db = db_service

          async def save(self, symbol: Symbol) -> None:
              """Persist symbol to database."""
              # Translate Symbol -> SQL INSERT/UPDATE

          async def find_by_canonical_name(self, name: str) -> Optional[Symbol]:
              """Find symbol by canonical name."""
              # SQL query, map result -> Symbol object

          async def find_orphaned(self) -> List[Symbol]:
              """Find symbols without file references."""
              # Domain-specific query

  - pattern_id: "facade_pattern"
    type: "simplification"
    purpose: "Provide simplified interface to complex subsystem"

    applies_to:
      - "Cognitive orchestrator (hides multiple LLM clients)"
      - "Knowledge service (hides DB + Qdrant + vectorizer)"
      - "Audit service (hides multiple checkers)"

    guarantees:
      - "Single entry point for complex operations"
      - "Coordinates multiple services"
      - "Hides implementation complexity"

    implementation_requirements:
      structure:
        - "Composes multiple services"
        - "Provides high-level methods"
        - "Handles coordination logic"

      responsibilities:
        - "Service orchestration"
        - "Error aggregation"
        - "Transaction boundaries"

      anti_patterns:
        - "Don't reimplement service logic"
        - "Don't hold state beyond request scope"
        - "Don't become a god object"

    example_skeleton: |
      class KnowledgeService:
          """Facade for all knowledge graph operations."""

          def __init__(
              self,
              db_repo: SymbolRepository,
              vector_service: QdrantService,
              vectorizer: KnowledgeVectorizer
          ):
              self._db = db_repo
              self._vectors = vector_service
              self._vectorizer = vectorizer

          async def add_symbol(self, symbol: Symbol) -> None:
              """Add symbol to both DB and vector store."""
              # 1. Save to DB
              # 2. Generate embedding
              # 3. Store in Qdrant
              # Coordinate all three

          async def search_similar(self, query: str, limit: int) -> List[Symbol]:
              """Search symbols by semantic similarity."""
              # 1. Get embedding for query
              # 2. Vector search in Qdrant
              # 3. Hydrate from DB
              # Return complete Symbol objects

  - pattern_id: "observer_pattern"
    type: "event_driven"
    purpose: "Decouple event producers from consumers"

    applies_to:
      - "File system watchers"
      - "Constitutional monitors"
      - "Audit loggers"

    structure:
      - "Observable: emits events"
      - "Observer: receives and handles events"
      - "Event: data payload"

    implementation_requirements:
      - "Use async event handlers"
      - "Observers should not block"
      - "Failed observers shouldn't crash observable"

    example_skeleton: |
      class ConstitutionalMonitor:
          """Observable for constitutional violations."""

          def __init__(self):
              self._observers: List[Callable] = []

          def subscribe(self, handler: Callable[[ViolationEvent], None]) -> None:
              """Register violation handler."""
              self._observers.append(handler)

          async def _notify_violation(self, violation: ViolationEvent) -> None:
              """Notify all observers of violation."""
              for observer in self._observers:
                  try:
                      await observer(violation)
                  except Exception as e:
                      logger.error(f"Observer failed: {e}")

service_composition:
  dependency_injection:
    principle: "Services receive dependencies via constructor"
    benefits:
      - "Testable with mocks"
      - "Explicit dependencies"
      - "No hidden coupling"

    example: |
      # Good: Dependencies injected
      class AutonomousDeveloper:
          def __init__(
              self,
              planner: PlannerAgent,
              coder: CoderAgent,
              knowledge: KnowledgeService
          ):
              self._planner = planner
              self._coder = coder
              self._knowledge = knowledge

      # Bad: Creating dependencies internally
      class AutonomousDeveloper:
          def __init__(self):
              self._planner = PlannerAgent()  # Hard to test!
              self._coder = CoderAgent()      # Can't mock!

  service_registry:
    purpose: "Central registry for service instances"
    pattern: |
      class ServiceRegistry:
          """Central registry of initialized services."""

          def __init__(self):
              self._services: Dict[Type, Any] = {}

          def register(self, service_type: Type, instance: Any) -> None:
              """Register service instance."""
              self._services[service_type] = instance

          def get(self, service_type: Type[T]) -> T:
              """Get service by type."""
              return self._services[service_type]

    usage: "Use for application-level service wiring, not within services"

error_handling:
  exception_hierarchy:
    base: "CoreServiceError(Exception)"
    categories:
      - "ConfigurationError - invalid configuration"
      - "ConnectionError - service unavailable"
      - "ValidationError - invalid input"
      - "NotFoundError - resource doesn't exist"
      - "ConflictError - resource already exists"
      - "PermissionError - operation not allowed"

  retry_strategy:
    transient_errors:
      - "Network timeouts"
      - "Rate limits"
      - "Temporary unavailability"

    implementation: |
      async def execute_with_retry(
          operation: Callable,
          max_attempts: int = 3,
          backoff: float = 1.0
      ):
          for attempt in range(max_attempts):
              try:
                  return await operation()
              except TransientError as e:
                  if attempt == max_attempts - 1:
                      raise
                  await asyncio.sleep(backoff * (2 ** attempt))

testing_patterns:
  unit_tests:
    - "Mock all external dependencies"
    - "Test happy path and error cases"
    - "Verify error messages are actionable"

  integration_tests:
    - "Use test database/vector store"
    - "Clean state between tests"
    - "Test actual service interactions"

  fixtures:
    - "Provide factory functions for test data"
    - "Use pytest fixtures for service setup"

migration_checklist:
  audit_existing_services:
    - "List all service classes"
    - "Identify which pattern each should follow"
    - "Document pattern violations"

  refactor_priorities:
    1: "Services with global state (highest risk)"
    2: "Services without error handling"
    3: "Services with unclear responsibilities"
    4: "Services with poor test coverage"

  validation:
    - "Each service declares its pattern in docstring"
    - "Pattern checker validates implementation"
    - "Add to dev-sync checks"

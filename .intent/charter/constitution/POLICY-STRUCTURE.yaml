# .intent/charter/constitution/POLICY-STRUCTURE.yaml
#
# Policy Document Structure Standard
#
# Defines the specific structure and requirements for policy documents
# (standards/*.yaml files) that establish governance rules.
#
# This document builds on RULES-STRUCTURE.yaml (universal rules format)
# and adds policy-specific requirements.

id: policy_structure_standard
version: "2.0.0"
title: "Policy Document Structure Standard"
type: "constitutional_standard"
status: active

owners:
  accountable: "Governance Lead"
  responsible:
    - "Core Maintainer"

review:
  frequency: "12 months"

schema_id: "policy.structure"

# ============================================================================
# PURPOSE & SCOPE
# ============================================================================

purpose: >
  Establishes the canonical structure for policy documents that define
  governance standards, operational requirements, and architectural rules.

  Policies are prescriptive documents that establish "how things must be done"
  and are enforced through constitutional auditing.

scope:
  applies_to:
    - ".intent/charter/standards/**/*.yaml"
    - "Any document of type: standard_*"

  examples:
    - "code_standards.yaml - Code quality and style policies"
    - "logging_standards.yaml - Logging requirements"
    - "data_governance.yaml - Data handling policies"
    - "operations.yaml - Operational procedures"
    - "safety.yaml - Safety and security policies"

# ============================================================================
# POLICY DOCUMENT STRUCTURE
# ============================================================================

canonical_structure:
  description: >
    All policy documents MUST follow this structure. This ensures
    consistent discovery, parsing, and enforcement.

  required_sections:
    header:
      description: "Standard document header (per GLOBAL-DOCUMENT-META-SCHEMA)"
      required_fields:
        - id
        - version
        - title
        - type
        - status
        - owners
        - review
        - schema_id

      schema_id_usage:
        description: "CRITICAL: How to set schema_id for policy documents"

        rule: >
          Policy documents use schema_id in TWO layers:

          1. DOCUMENT LEVEL: schema_id identifies the policy structure
             Set to: "policy.structure" (this validates the document)

          2. RULES LEVEL: Each item in rules[] conforms to rules.structure
             (This is implicit - you don't set it per rule)

        example: |
          # In your policy YAML:
          id: code_standards
          schema_id: "policy.structure"  # ← Validates THIS document

          rules:
            - id: style.linter           # ← Conforms to rules.structure
              statement: "..."           #    (automatic)

        anti_pattern: |
          # WRONG - Don't do this:
          schema_id: "rules.structure"  # ← This is for rule items, not documents!

      notes:
        - "type SHOULD start with 'standard_' (e.g. standard_code, standard_operations)"
        - "If document has no rules, schema_id can be policy.structure or pattern.structure"

    purpose:
      type: string
      description: "Clear statement of what this policy governs and why it exists"
      max_length: 1000
      required: true
      example: >
        Unified standards for code quality, style, naming, and refactoring patterns.
        Ensures consistent, maintainable, and safe code across the entire codebase.

    rules:
      type: array
      description: "Enforceable rules (MUST follow RULES-STRUCTURE.yaml)"
      required: true
      reference: "See RULES-STRUCTURE.yaml for complete specification"

      policy_specific_guidance:
        categories:
          description: "Policies SHOULD use consistent category names"
          recommended_categories:
            code:
              - "style - Code formatting and conventions"
              - "naming - File and symbol naming"
              - "complexity - Size and complexity limits"
              - "quality - Code health metrics"

            operations:
              - "logging - Logging standards"
              - "monitoring - Observability requirements"
              - "deployment - Deployment procedures"
              - "incident_response - IR protocols"

            architecture:
              - "dependency_injection - DI patterns"
              - "layer_separation - Architectural boundaries"
              - "service_patterns - Service design"
              - "data_flow - Data movement rules"

            governance:
              - "agent_governance - AI agent constraints"
              - "safety - Safety mechanisms"
              - "audit - Audit requirements"
              - "compliance - Compliance checks"

        enforcement_levels:
          error:
            description: "Constitutional requirement - blocking violation"
            when_to_use:
              - "Safety-critical requirements"
              - "Architectural invariants"
              - "Legal/compliance mandates"
            examples:
              - "Agents MUST NOT modify constitution files"
              - "All changes MUST pass linting"
              - "Secrets MUST NOT be hardcoded"

          warn:
            description: "Best practice - should be followed but not blocking"
            when_to_use:
              - "Code quality guidelines"
              - "Recommended patterns"
              - "Emerging standards"
            examples:
              - "Functions SHOULD have docstrings"
              - "Modules SHOULD not exceed 400 lines"
              - "Use dependency injection where practical"

          info:
            description: "Guidance - informational only"
            when_to_use:
              - "Documentation references"
              - "Cross-references to other policies"
              - "Aspirational goals"
            examples:
              - "See dependency_injection.yaml for DI patterns"
              - "Consider using asyncio for I/O operations"

  optional_sections:
    background:
      type: string
      description: "Historical context or rationale for policy creation"
      max_length: 2000

    definitions:
      type: object
      description: "Key terms used in policy rules"
      example:
        terms:
          constitutional_file: "Any file under .intent/charter/**"
          dangerous_operation: "File deletion, database migration, schema change"

    reference_data:
      type: object
      description: "Supporting data that informs but is not enforced"
      examples:
        - "health_standards: {max_complexity: 15, max_nesting: 4}"
        - "refactoring_patterns: [{id: extract_function, ...}]"

      notes:
        - "Reference data provides context but is NOT scanned by checkers"
        - "Put enforceable limits in rules array, not reference data"

# ============================================================================
# POLICY CATEGORIES
# ============================================================================

policy_categories:
  description: >
    Standard categories for organizing policies. These are not enforced
    structurally but help with discovery and understanding.

  code_policies:
    description: "Policies governing source code quality and structure"
    examples:
      - "code_standards.yaml - Overall code quality"
      - "code_purity.yaml - Functional purity requirements"
      - "refactoring_standards.yaml - Safe refactoring practices"

    typical_rule_categories:
      - "style"
      - "naming"
      - "complexity"
      - "quality"
      - "documentation"

  operations_policies:
    description: "Policies governing operational procedures"
    examples:
      - "operations.yaml - General operational standards"
      - "safety.yaml - Safety mechanisms and constraints"
      - "observability.yaml - Monitoring and logging"
      - "incident_response.yaml - IR procedures"

    typical_rule_categories:
      - "logging"
      - "monitoring"
      - "deployment"
      - "safety"
      - "security"

  architecture_policies:
    description: "Policies governing system architecture"
    examples:
      - "dependency_injection.yaml - DI requirements"
      - "layer_contracts.yaml - Layer boundaries"
      - "service_patterns.yaml - Service design"

    typical_rule_categories:
      - "dependency_injection"
      - "layer_separation"
      - "service_patterns"
      - "data_flow"

  governance_policies:
    description: "Policies governing AI agents and autonomy"
    examples:
      - "agent_governance.yaml - Agent constraints"
      - "code_execution.yaml - Dynamic code rules"
      - "policy_integrity.yaml - Policy management"

    typical_rule_categories:
      - "agent_governance"
      - "autonomy"
      - "validation"
      - "audit"

# ============================================================================
# ENFORCEMENT GUIDANCE
# ============================================================================

enforcement:
  description: >
    How policy rules are discovered and enforced by the constitutional
    audit system.

  discovery:
    process:
      - "Auditor scans .intent/charter/standards/**/*.yaml"
      - "Loads documents with schema_id='rules.structure'"
      - "Extracts rules array from each policy"
      - "Builds rule registry indexed by rule.id"

    registration:
      description: "Each rule is registered with auditor by its id"
      example: "style.linter_required → Auditor.rule_registry['style.linter_required']"

  checker_implementation:
    description: "Checkers in src/mind/governance/checks/ implement rule enforcement"

    pattern: |
      class MyPolicyCheck(BaseCheck):
          """Enforces rules from my_policy.yaml"""

          policy_rule_ids = [
              "my_policy.rule_one",
              "my_policy.rule_two",
          ]

          def __init__(self, context: AuditorContext):
              super().__init__(context)

              # Load policy rules (supports both old and new formats)
              policy = context.policies.get("my_policy", {})
              all_rules = policy.get("rules", [])

              # Filter by category if needed
              my_rules = [r for r in all_rules if r.get("category") == "my_category"]

              # Build lookup
              self.rules_by_id = {r["id"]: r for r in my_rules}

          def execute(self) -> list[AuditFinding]:
              findings = []
              for rule_id, rule in self.rules_by_id.items():
                  # Check compliance with rule
                  if violation_detected:
                      findings.append(AuditFinding(
                          check_id=rule_id,
                          severity=AuditSeverity[rule["enforcement"].upper()],
                          message=f"Violation of {rule_id}: {rule['statement']}",
                          ...
                      ))
              return findings

    backward_compatibility:
      description: "During v2.x, checkers MUST support both formats"
      pattern: |
        # Support both new (rules array) and old (nested sections)
        all_rules = policy.get("rules", [])

        if not all_rules:
            # Fallback to old format
            all_rules = policy.get("style_rules", [])
            all_rules.extend(policy.get("naming_conventions", {}).get("code", []))

  coverage_tracking:
    description: "Enforcement coverage tracks which rules have active checkers"

    metrics:
      - "Total rules declared across all policies"
      - "Rules with active checkers (enforced)"
      - "Rules without checkers (declared only)"
      - "Enforcement rate per policy"
      - "Enforcement rate per category"

    reporting:
      command: "core-admin governance coverage"
      formats:
        - "summary - Flat list of all rules"
        - "hierarchical - Grouped by policy (progressive disclosure)"
        - "json - Machine-readable export"

# ============================================================================
# EXAMPLES
# ============================================================================

examples:
  minimal_policy:
    description: "Simplest valid policy document"
    content: |
      id: example_policy
      version: "1.0.0"
      title: "Example Policy"
      type: "standard_example"
      status: active

      owners:
        accountable: "Policy Owner"
        responsible:
          - "Team Lead"

      review:
        frequency: "12 months"

      schema_id: "rules.structure"

      purpose: >
        Demonstrates minimal valid policy structure.

      rules:
        - id: example.basic_rule
          statement: "All code MUST pass basic validation"
          enforcement: error

  full_featured_policy:
    description: "Policy with all recommended sections"
    content: |
      id: code_quality_policy
      version: "2.0.0"
      title: "Code Quality Policy"
      type: "standard_code"
      status: active

      owners:
        accountable: "Code Quality Lead"
        responsible:
          - "Core Maintainers"
          - "Tech Leads"

      review:
        frequency: "6 months"
        last_reviewed: "2025-12-01"
        next_review_due: "2026-06-01"

      schema_id: "rules.structure"

      purpose: >
        Establishes code quality standards to ensure maintainable,
        reliable, and consistent code across the entire codebase.

      background: >
        Created in response to increased technical debt and inconsistent
        code quality across teams. Consolidates scattered guidelines into
        single authoritative policy.

      definitions:
        terms:
          public_symbol: "Function or class not prefixed with underscore"
          critical_path: "Code that affects system safety or data integrity"

      rules:
        # Style rules
        - id: style.linter_required
          category: style
          statement: "All code MUST pass ruff linting"
          enforcement: error
          scope: ["src/**/*.py", "tests/**/*.py"]
          rationale: "Catches bugs and enforces consistency"
          details:
            fix_command: "ruff check --fix"

        # Naming rules
        - id: naming.module_naming
          category: naming
          subcategory: code
          statement: "Python modules MUST use snake_case"
          enforcement: error
          scope: "src/**/*.py"
          exceptions: ["__init__.py"]

        # Complexity rules
        - id: complexity.max_function_lines
          category: complexity
          statement: "Functions SHOULD NOT exceed 50 lines"
          enforcement: warn
          rationale: "Long functions are hard to test and understand"
          exceptions:
            - "Main entry points orchestrating workflow"
            - "Generated code"

      # Reference data (not enforced)
      health_standards:
        max_cognitive_complexity: 15
        max_nesting_depth: 4
        recommended_test_coverage: 75

# ============================================================================
# MIGRATION FROM V1 TO V2
# ============================================================================

migration_guide:
  description: "How to migrate existing policies to v2.0 format"

  step_by_step:
    step_1:
      task: "Add schema_id field"
      action: 'Add `schema_id: "rules.structure"` to document header'

    step_2:
      task: "Create flat rules array"
      action: "Add top-level `rules: []` array"

    step_3:
      task: "Move rules from nested sections"
      action: |
        For each legacy section (style_rules, naming_conventions, etc):
        - Extract each rule
        - Add category property matching section name
        - Move to flat rules array

        Example:
          FROM:
            style_rules:
              - id: style.linter
          TO:
            rules:
              - id: style.linter
                category: style

    step_4:
      task: "Handle nested structures"
      action: |
        For nested dicts like naming_conventions:
          naming_conventions:
            code:
              - id: code.python_naming

          Becomes:
            rules:
              - id: code.python_naming
                category: naming
                subcategory: code

    step_5:
      task: "Update checkers (optional during v2.x)"
      action: |
        Checkers can remain backward compatible during v2.x.
        Update when convenient to use new format directly.

    step_6:
      task: "Remove legacy sections"
      action: "Once rules are migrated, remove old nested sections"

    step_7:
      task: "Test"
      action: |
        core-admin check audit
        core-admin governance coverage --format hierarchical

  automation:
    script: "scripts/migrate_policy_format.py"
    usage: "python3 scripts/migrate_policy_format.py --policy code_standards.yaml"

# ============================================================================
# VALIDATION CHECKLIST
# ============================================================================

validation_checklist:
  header:
    - "[ ] Document has all required header fields"
    - "[ ] type starts with 'standard_'"
    - "[ ] schema_id is 'rules.structure'"
    - "[ ] version follows semver (X.Y.Z)"

  content:
    - "[ ] purpose field explains what policy governs"
    - "[ ] rules is a flat array (not nested dict)"
    - "[ ] Each rule has: id, statement, enforcement"
    - "[ ] Rule IDs follow pattern: ^[a-z][a-z0-9._-]*$"
    - "[ ] Rule IDs are globally unique"
    - "[ ] Categories are consistent with other policies"
    - "[ ] Enforcement levels are: error, warn, or info"

  quality:
    - "[ ] Statements are clear and actionable"
    - "[ ] High-severity rules have rationale"
    - "[ ] Scope is defined where applicable"
    - "[ ] Examples provided for complex rules"
    - "[ ] Reference data clearly separated from enforceable rules"

# ============================================================================
# BEST PRACTICES
# ============================================================================

best_practices:
  rule_design:
    - "Make statements imperative and specific"
    - "Use RFC 2119 keywords (MUST, SHOULD, MAY)"
    - "One concern per rule (atomic)"
    - "Provide rationale for error-level rules"
    - "Document exceptions explicitly"

  category_organization:
    - "Use consistent category names across policies"
    - "Keep categories broad (5-10 per policy max)"
    - "Use subcategory for fine-grained grouping"
    - "Don't create single-rule categories"

  enforcement_levels:
    - "Use error for constitutional requirements"
    - "Use warn for best practices"
    - "Use info for cross-references"
    - "Be consistent within category"

  maintenance:
    - "Review policy every 6-12 months"
    - "Update version on any rule change"
    - "Document breaking changes in commit messages"
    - "Keep reference data minimal"

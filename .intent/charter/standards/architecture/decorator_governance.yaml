# .intent/charter/policies/decorator_governance.yaml
#
# Constitutional Policy: Decorator Governance
#
# Defines WHEN and HOW decorators must be applied to make CORE.NG autonomous
# in generating correctly decorated code without human intervention.

policy_id: decorator_governance
version: "1.0.0"
status: active
category: code_generation
layer: mind

# =============================================================================
# PHILOSOPHY
# =============================================================================

philosophy: |
  Decorators in CORE serve two purposes:

  1. GOVERNANCE CONTRACTS (@core_command, @atomic_action)
     - Enable constitutional enforcement BEFORE execution
     - Required for the Will layer to validate safety
     - These are functional requirements, not pollution

  2. FRAMEWORK BINDINGS (@app.command, @pytest.fixture)
     - Enable framework wiring (Typer, FastAPI, Pytest)
     - Required for runtime registration
     - These are infrastructure necessities

  The Database stores WHAT decorators mean (metadata, relationships).
  The Source stores HOW decorators work (runtime behavior).

  For CORE.NG to autonomously generate correct code, it must know:
  - WHICH decorators are required for each function type
  - WHERE to place them (order matters)
  - WHAT parameters to use
  - WHY they exist (so it can reason about edge cases)

# =============================================================================
# DECORATOR WHITELIST
# =============================================================================

whitelisted_decorators:
  governance_contracts:
    - decorator: "@core_command"
      purpose: "Constitutional wrapper for CLI entry points"
      required_for: "All CLI command functions"
      parameters:
        - name: "dangerous"
          type: "bool"
          required: true
          values: [true, false]
          reasoning: |
            Declares whether command performs destructive operations.
            Used by IntentGuard to enforce approval workflows.
      metadata_storage: "core.symbol_decorators table (future)"

    - decorator: "@atomic_action"
      purpose: "Constitutional wrapper for autonomous operations"
      required_for: "All state-modifying service functions"
      parameters:
        - name: "action_id"
          type: "str"
          required: true
          example: "fix.ids"
        - name: "impact"
          type: "str"
          required: true
          values: ["read-only", "write-metadata", "write-code", "write-data"]
        - name: "policies"
          type: "list[str]"
          required: true
          example: ["naming_conventions", "structural_integrity"]
      metadata_storage: "core.actions table"

  framework_bindings:
    - decorator: "@app.command"
      framework: "Typer"
      purpose: "Register CLI command with Typer framework"
      required_for: "CLI entry points using Typer"

    - decorator: "@app.get|post|put|delete"
      framework: "FastAPI"
      purpose: "Register HTTP endpoint"
      required_for: "API route handlers"

    - decorator: "@pytest.fixture"
      framework: "Pytest"
      purpose: "Register test fixture"
      required_for: "Test helper functions"

    - decorator: "@dataclass"
      framework: "Python stdlib"
      purpose: "Generate dataclass methods"
      required_for: "Data container classes"

# =============================================================================
# DECORATOR APPLICATION RULES
# =============================================================================

application_rules:
  - rule_id: "cli_commands_require_core_decorator"
    statement: "All CLI command functions MUST use @core_command decorator"

    applies_to:
      - "Functions under src/body/cli/**/*.py"
      - "Functions decorated with @<app>.command()"
      - "Functions matching pattern: (run_|execute_|list_|show_|query_)*"

    required_decorator: "@core_command(dangerous=<bool>)"

    detection:
      check: "Function is CLI entry point AND lacks @core_command"
      indicators:
        - "Has @app.command() decorator"
        - "Module path contains 'body/cli'"
        - "Function name matches CLI verb pattern"

    generation:
      template: "@core_command(dangerous={is_dangerous})"
      parameters:
        is_dangerous:
          determine_by: "semantic analysis of function body"
          heuristics:
            - "Contains Path.write_text() → dangerous=True"
            - "Contains Path.unlink() → dangerous=True"
            - "Contains subprocess.run() → dangerous=True"
            - "Only reads data → dangerous=False"
            - "Only queries database → dangerous=False"
          default: false
          reasoning: "Conservative default: assume safe unless proven otherwise"

    fix:
      action: "Add @core_command decorator above framework decorator"
      verification: "Ensure decorator order: @core_command then @app.command()"

  - rule_id: "decorator_ordering"
    statement: "Decorators MUST appear in constitutional order"

    order:
      1: "Governance contracts (@core_command, @atomic_action)"
      2: "Framework bindings (@app.command, @pytest.fixture)"
      3: "Type hints (@dataclass, @property)"

    reasoning: |
      Governance must wrap framework registration to ensure constitutional
      checks happen BEFORE the framework dispatches execution.

    violation_example: |
      # WRONG - framework decorator first
      @app.command()
      @core_command(dangerous=False)
      def my_command(): ...

    correct_example: |
      # CORRECT - governance decorator first
      @core_command(dangerous=False)
      @app.command()
      def my_command(): ...

    fix:
      action: "Reorder decorators according to constitutional precedence"

  - rule_id: "no_duplicate_decorators"
    statement: "Functions MUST NOT have duplicate decorators"

    check: "Scan for @decorator appearing multiple times on same function"

    fix:
      action: "Remove duplicate, keep first occurrence"
      special_case: |
        If parameters differ, merge intelligently:
        @core_command(dangerous=True)
        @core_command(dangerous=False)
        → Keep dangerous=True (more restrictive)

# =============================================================================
# AUTONOMOUS GENERATION GUIDELINES
# =============================================================================

autonomous_generation:
  decision_tree:
    - condition: "Generating CLI command function"
      actions:
        1: "Determine if dangerous (analyze function body)"
        2: "Apply @core_command(dangerous=<bool>)"
        3: "Apply @app.command() for framework binding"
        4: "Verify decorator order"

    - condition: "Generating service method that modifies state"
      actions:
        1: "Determine action_id from function purpose"
        2: "Determine impact level (write-metadata, write-code, etc)"
        3: "Identify applicable constitutional policies"
        4: "Apply @atomic_action(action_id, impact, policies)"

    - condition: "Generating read-only service method"
      actions:
        1: "No governance decorator needed"
        2: "Apply framework decorators only if required"

    - condition: "Generating test fixture"
      actions:
        1: "Apply @pytest.fixture if shared across tests"
        2: "No governance decorator needed (tests are exempt)"

  parameter_inference:
    dangerous_parameter:
      analyze:
        - "Parse function AST"
        - "Check for file writes (Path.write_text, open with 'w')"
        - "Check for deletions (Path.unlink, os.remove)"
        - "Check for shell commands (subprocess, os.system)"
        - "Check for database writes (INSERT, UPDATE, DELETE)"

      conservative_default: false

      reasoning: |
        When in doubt, mark as safe (dangerous=False) and let constitutional
        audits catch cases where human approval should be required.

    action_id_parameter:
      pattern: "<verb>.<noun>"
      examples:
        - "fix.ids"
        - "check.imports"
        - "sync.vectors"

      generation:
        verb: "Infer from function name (fix_, check_, sync_, etc)"
        noun: "Infer from function purpose"

    impact_parameter:
      determine_by: "AST analysis of function body"
      mapping:
        - "No writes → read-only"
        - "Writes comments/IDs → write-metadata"
        - "Modifies code structure → write-code"
        - "Database operations → write-data"

# =============================================================================
# STORAGE STRATEGY
# =============================================================================

storage_strategy:
  current_state:
    location: "Source files (.py)"
    reason: "Python requires decorators at runtime for framework registration"

  future_state:
    metadata_storage: |
      core.symbol_decorators table will store:
      - Which decorators a symbol requires
      - What parameters to use
      - Why they're needed (constitutional justification)

    generation_workflow: |
      1. CORE queries: "What decorators does symbol X need?"
      2. DB returns: [@core_command(dangerous=False), @app.command()]
      3. CORE generates source with decorators
      4. Python executes decorated code

    benefit: |
      CORE can reason about decorator requirements semantically,
      update them without touching source, and evolve patterns
      without breaking existing code.

# =============================================================================
# MIGRATION PATH
# =============================================================================

migration:
  phase_1_current:
    state: "Decorators in source, policies in .intent/"
    capability: "CORE can detect violations, suggest fixes"
    limitation: "Cannot autonomously generate new decorated functions"

  phase_2_enhanced_policies:
    state: "Add this policy to .intent/"
    capability: "CORE can autonomously generate correct decorators"
    limitation: "Still requires source modification for changes"

  phase_3_db_storage:
    state: "Add core.symbol_decorators table"
    capability: "CORE queries DB for decorator requirements"
    benefit: "Decorator rules updatable without code changes"

  phase_4_autonomous:
    state: "CORE.NG generates all code from DB + intent"
    capability: "Full autonomous code generation"
    goal: "Last programmer you'll ever need"

# =============================================================================
# ENFORCEMENT
# =============================================================================

enforcement:
  audits:
    - id: "missing_core_command"
      check: "CLI functions lack @core_command"
      severity: "error"
      auto_fix: true
      fix_action: "Add @core_command(dangerous=False) decorator"

    - id: "wrong_decorator_order"
      check: "Framework decorator appears before governance decorator"
      severity: "error"
      auto_fix: true
      fix_action: "Reorder decorators"

    - id: "unlisted_decorator"
      check: "Decorator not in whitelist"
      severity: "warning"
      auto_fix: false
      fix_action: "Manual review required"

  constitutional_compliance:
    principle: "All decorators must serve constitutional or framework purposes"
    violation: "Decorators that only store metadata (use DB instead)"
    exemption: "None - this is foundational to SSOT architecture"

# =============================================================================
# EXAMPLES
# =============================================================================

examples:
  correct_cli_command: |
    @core_command(dangerous=False)
    @check_app.command("audit")
    def audit(
        fix: bool = False,
        scope: str = "all"
    ) -> None:
        """Run constitutional compliance audit."""
        # implementation

  correct_dangerous_command: |
    @core_command(dangerous=True)
    @admin_app.command("reset-db")
    def reset_database() -> None:
        """Drop and recreate all tables."""
        # implementation

  correct_atomic_action: |
    @atomic_action(
        action_id="fix.ids",
        impact="write-metadata",
        policies=["symbol_identification"]
    )
    def assign_stable_ids() -> ActionResult:
        """Assign UUIDs to untagged symbols."""
        # implementation

  wrong_decorator_order: |
    # VIOLATION: Framework decorator before governance
    @check_app.command("audit")
    @core_command(dangerous=False)
    def audit() -> None:
        ...

  forbidden_metadata_decorator: |
    # VIOLATION: Metadata belongs in database
    @capability(name="audit", owner="team-a")
    @core_command(dangerous=False)
    @check_app.command("audit")
    def audit() -> None:
        ...

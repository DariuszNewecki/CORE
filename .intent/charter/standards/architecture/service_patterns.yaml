# .intent/charter/standards/architecture/service_patterns.yaml
id: standard_architecture_service_patterns
version: "1.0.0"
title: "Architecture Standard â€“ Service Patterns"
type: "standard_architecture"
status: active

owners:
  accountable: "Architecture Owner"
  responsible:
    - "Core Maintainer"

review:
  frequency: "12 months"

schema_id: "standard.architecture.service_patterns"

description: |
  Defines canonical patterns for all infrastructure and body-layer services in CORE.
  Services manage stateful resources (DB, vectors, LLMs) and provide
  clean interfaces for business logic.

  This pattern file has two dimensions:
  - Architectural patterns: how different kinds of services are structured
    (stateful services, repositories, facades, observers, etc.).
  - Behavioral contract: how ALL services must behave (headless, safe-by-default,
    consistent result contracts) so they can be orchestrated by workflows and agents.

# =============================================================================
# CROSS-CUTTING SERVICE CONTRACT (APPLIES TO ALL SERVICES)
# =============================================================================

service_contract:
  headless:
    description: >
      Services are part of the Body layer and MUST be headless. They MUST NOT
      render terminal UI or depend on interactive input. All user-facing UX
      belongs to workflows/CLI (Will layer).
    rules:
      - "No use of rich.Console or other terminal UI libraries in services."
      - "No print() calls in services."
      - "No input() or interactive prompts in services."
      - "Services communicate via return values, logging, and exceptions only."

  safety:
    description: >
      Mutating behavior must be explicit and safe-by-default. This operationalizes
      the 'write_defaults_false' immutable principle at the service level.
    rules:
      - "Any parameter that controls side effects MUST default to False (e.g. write=False)."
      - "Services SHOULD support dry-run behavior where feasible."
      - "Read-only operations MUST be clearly distinguishable from write operations."
      - "Services MUST NOT perform writes without an explicit, intentional flag."

  results:
    description: >
      Services MUST return predictable, structured results. High-level operations
      that participate in workflows use ActionResult. Low-level helpers may return
      plain types but MUST remain headless and easily wrappable.
    types:
      atomic_action_service:
        description: >
          High-level operations that are directly orchestrated by workflows/agents
          and appear in audit trails MUST return ActionResult.
        contract:
          - "Return type: shared.action_types.ActionResult."
          - "action_id identifies the operation semantically (e.g. 'fix.headers', 'sync.vectors')."
          - "ok indicates success/failure."
          - "data contains structured, JSON-serializable fields."
          - "duration_sec captures execution time when meaningful."
          - "impact indicates side-effect level (read-only/write-metadata/write-code/write-data) when applicable."

      helper_service:
        description: >
          Narrow supporting operations MAY return plain Python types (dict, list,
          domain objects) but MUST remain headless and deterministic where possible.
        contract:
          - "No terminal UI."
          - "Errors communicated via exceptions or sentinel values, NOT via UI."
          - "Can be wrapped by an atomic_action_service that returns ActionResult."

  logging:
    description: >
      Services use the shared logger for observability. Logging is for operators
      and debugging, not interactive UX.
    rules:
      - "Use shared.logger.getLogger(__name__) for logging."
      - "INFO: high-level progress or key events."
      - "DEBUG: detailed, per-item information that may be noisy."
      - "WARNING / ERROR: unexpected failures, misconfigurations, or degraded behavior."
      - "Avoid WARNING/ERROR inside tight loops; prefer DEBUG to prevent log spam."

# =============================================================================
# UI BOUNDARY (ALIGNS WITH workflow_patterns.ui_contract)
# =============================================================================

ui_boundary:
  description: >
    Reinforces that services MUST be headless. All terminal UI (Rich progress bars,
    spinners, banners, summaries) belongs to the workflow/CLI layer as defined in
    workflow_patterns.yaml (ui_contract).
  forbidden_in_services:
    - "from rich.console import Console"
    - "from rich.progress import Progress"
    - "print(...)"          # except in one-off scripts, never in services
    - "Prompting for user input (input(), Confirm, etc.)"

  allowed_in_services:
    - "Logging via shared.logger"
    - "Raising exceptions or returning ActionResult/values"
    - "Pure computations and data transformations"

  orchestration_responsibility:
    - "Workflows/CLI own progress bars, spinners, banners, and summaries."
    - "Services may expose progress via structured data (e.g. counts), not via UI."
    - "Any new Rich-based UI MUST live in workflow/CLI modules, not in services."

# =============================================================================
# DRY-RUN & WRITE SEMANTICS
# =============================================================================

write_semantics:
  description: >
    To support safe autonomy and reversible behavior, services must be explicit
    about write behavior and support dry-run where practical.
  rules:
    parameters:
      - "Any mutating service SHOULD accept write: bool = False."
      - "Services MAY also accept dry_run: bool, but MUST keep semantics consistent (dry_run == not write)."
      - "Read-only services SHOULD omit write/dry_run parameters entirely."

    behavior:
      - "When write=False, services MUST NOT perform irreversible operations."
      - "When write=False, services SHOULD still compute and return what WOULD happen where feasible."
      - "When write=True, services perform the actual mutation and report impact in ActionResult or return data."

  example_atomic_action: |
    async def sync_vectors_action(
        qdrant_service: QdrantService,
        write: bool = False,
    ) -> ActionResult:
        dry_run = not write
        ...

# =============================================================================
# ARCHITECTURAL SERVICE PATTERNS (YOUR ORIGINAL CONTENT)
# =============================================================================

patterns:
  - pattern_id: "stateful_service"
    type: "infrastructure"
    purpose: "Manage long-lived stateful resources"

    applies_to:
      - "Database connections"
      - "Vector store clients"
      - "LLM API clients"
      - "File system watchers"

    lifecycle:
      initialization:
        - "Load configuration from environment/config files"
        - "Validate connection parameters"
        - "Establish connection with retry logic"
        - "Verify service health"
        - "Log successful initialization"

      usage:
        - "Provide clean, typed interface"
        - "Handle transient failures gracefully"
        - "Implement connection pooling where appropriate"
        - "Cache results when safe"

      shutdown:
        - "Flush pending operations"
        - "Close connections cleanly"
        - "Log shutdown completion"

    implementation_requirements:
      structure:
        - "Single class per service"
        - "Dependency injection via constructor"
        - "No global state or singletons"
        - "Async-first where I/O bound"

      error_handling:
        - "MUST raise specific exceptions (not generic Exception)"
        - "MUST log errors with context"
        - "SHOULD implement retry with backoff"
        - "SHOULD provide circuit breaker for external services"

      testing:
        - "MUST be mockable (interface-based)"
        - "MUST have unit tests with mocked dependencies"
        - "SHOULD have integration tests with real services"

    example_skeleton: |
      class DatabaseService:
          """Manages PostgreSQL connection and operations."""

          def __init__(self, config: DatabaseConfig):
              self._config = config
              self._connection = None
              self._initialized = False

          async def initialize(self) -> None:
              """Establish database connection with validation."""
              # Connect, validate, set _initialized = True

          async def execute_query(self, query: str, params: dict) -> List[dict]:
              """Execute parameterized query with error handling."""
              if not self._initialized:
                  raise ServiceNotInitializedError()
              # Execute with retries, return results

          async def shutdown(self) -> None:
              """Clean shutdown of database connection."""
              # Close connection, cleanup resources

  - pattern_id: "stateless_transformer"
    type: "pure_logic"
    purpose: "Transform data without side effects"

    applies_to:
      - "Validators"
      - "Parsers"
      - "Formatters"
      - "Calculators"

    guarantees:
      - "Pure functions - same input always produces same output"
      - "No hidden state"
      - "No I/O operations"
      - "Easily testable"

    implementation_requirements:
      structure:
        - "Static methods or pure functions preferred"
        - "No instance variables (if class-based)"
        - "Type hints for all inputs/outputs"

      naming:
        - "Verbs that describe transformation: parse_, validate_, format_"

      testing:
        - "Property-based testing recommended"
        - "100% code coverage achievable"

    example_skeleton: |
      class YAMLProcessor:
          """Pure YAML processing operations."""

          @staticmethod
          def parse_strict(content: str) -> dict:
              """Parse YAML with strict validation."""
              # Pure transformation, no side effects

          @staticmethod
          def validate_schema(data: dict, schema: dict) -> List[str]:
              """Validate data against schema, return violations."""
              # Pure validation, returns results

  - pattern_id: "repository_pattern"
    type: "data_access"
    purpose: "Abstract database operations behind domain interface"

    applies_to:
      - "Symbol repository"
      - "Policy repository"
      - "Audit log repository"
      - "Capability repository"

    structure:
      interface_layer:
        - "Define domain operations (save_symbol, find_by_id, etc.)"
        - "Return domain objects, not raw DB rows"
        - "Hide SQL/query details from callers"

      implementation_layer:
        - "Translate domain operations to SQL"
        - "Handle connection management"
        - "Map DB rows to domain objects"

    implementation_requirements:
      naming:
        - "End with 'Repository': SymbolRepository"
        - "Methods follow domain language, not SQL"

      methods:
        standard_operations:
          - "async def save(entity: DomainObject) -> None"
          - "async def find_by_id(id: str) -> Optional[DomainObject]"
          - "async def find_all(filters: dict) -> List[DomainObject]"
          - "async def delete(id: str) -> bool"

        query_methods:
          - "Use domain-specific names: find_orphaned_symbols()"
          - "Return domain objects, not dictionaries"

      error_handling:
        - "Raise domain exceptions, not DB exceptions"
        - "NotFoundError instead of SQLAlchemy NoResultFound"

    example_skeleton: |
      class SymbolRepository:
          """Repository for Symbol domain objects."""

          def __init__(self, db_service: DatabaseService):
              self._db = db_service

          async def save(self, symbol: Symbol) -> None:
              """Persist symbol to database."""
              # Translate Symbol -> SQL INSERT/UPDATE

          async def find_by_canonical_name(self, name: str) -> Optional[Symbol]:
              """Find symbol by canonical name."""
              # SQL query, map result -> Symbol object

          async def find_orphaned(self) -> List[Symbol]:
              """Find symbols without file references."""
              # Domain-specific query

  - pattern_id: "facade_pattern"
    type: "simplification"
    purpose: "Provide simplified interface to complex subsystem"

    applies_to:
      - "Cognitive orchestrator (hides multiple LLM clients)"
      - "Knowledge service (hides DB + Qdrant + vectorizer)"
      - "Audit service (hides multiple checkers)"

    guarantees:
      - "Single entry point for complex operations"
      - "Coordinates multiple services"
      - "Hides implementation complexity"

    implementation_requirements:
      structure:
        - "Composes multiple services"
        - "Provides high-level methods"
        - "Handles coordination logic"

      responsibilities:
        - "Service orchestration"
        - "Error aggregation"
        - "Transaction boundaries"

      anti_patterns:
        - "Don't reimplement service logic"
        - "Don't hold state beyond request scope"
        - "Don't become a god object"

    example_skeleton: |
      class KnowledgeService:
          """Facade for all knowledge graph operations."""

          def __init__(
              self,
              db_repo: SymbolRepository,
              vector_service: QdrantService,
              vectorizer: KnowledgeVectorizer
          ):
              self._db = db_repo
              self._vectors = vector_service
              self._vectorizer = vectorizer

          async def add_symbol(self, symbol: Symbol) -> None:
              """Add symbol to both DB and vector store."""
              # 1. Save to DB
              # 2. Generate embedding
              # 3. Store in Qdrant
              # Coordinate all three

          async def search_similar(self, query: str, limit: int) -> List[Symbol]:
              """Search symbols by semantic similarity."""
              # 1. Get embedding for query
              # 2. Vector search in Qdrant
              # 3. Hydrate from DB
              # Return complete Symbol objects

  - pattern_id: "observer_pattern"
    type: "event_driven"
    purpose: "Decouple event producers from consumers"

    applies_to:
      - "File system watchers"
      - "Constitutional monitors"
      - "Audit loggers"

    structure:
      - "Observable: emits events"
      - "Observer: receives and handles events"
      - "Event: data payload"

    implementation_requirements:
      - "Use async event handlers"
      - "Observers should not block"
      - "Failed observers shouldn't crash observable"

    example_skeleton: |
      class ConstitutionalMonitor:
          """Observable for constitutional violations."""

          def __init__(self):
              self._observers: List[Callable] = []

          def subscribe(self, handler: Callable[[ViolationEvent], None]) -> None:
              """Register violation handler."""
              self._observers.append(handler)

          async def _notify_violation(self, violation: ViolationEvent) -> None:
              """Notify all observers of violation."""
              for observer in self._observers:
                  try:
                      await observer(violation)
                  except Exception as e:
                      logger.error(f"Observer failed: {e}")

# =============================================================================
# SERVICE COMPOSITION & DI
# =============================================================================

service_composition:
  dependency_injection:
    principle: "Services receive dependencies via constructor"
    benefits:
      - "Testable with mocks"
      - "Explicit dependencies"
      - "No hidden coupling"

    example: |
      # Good: Dependencies injected
      class AutonomousDeveloper:
          def __init__(
              self,
              planner: PlannerAgent,
              coder: CoderAgent,
              knowledge: KnowledgeService
          ):
              self._planner = planner
              self._coder = coder
              self._knowledge = knowledge

      # Bad: Creating dependencies internally
      class AutonomousDeveloper:
          def __init__(self):
              self._planner = PlannerAgent()  # Hard to test!
              self._coder = CoderAgent()      # Can't mock!

  service_registry:
    purpose: "Central registry for service instances"
    pattern: |
      class ServiceRegistry:
          """Central registry of initialized services."""

          def __init__(self):
              self._services: Dict[Type, Any] = {}

          def register(self, service_type: Type, instance: Any) -> None:
              """Register service instance."""
              self._services[service_type] = instance

          def get(self, service_type: Type[T]) -> T:
              """Get service by type."""
              return self._services[service_type]

    usage: "Use for application-level service wiring, not within services"

# =============================================================================
# ERROR HANDLING
# =============================================================================

error_handling:
  exception_hierarchy:
    base: "CoreServiceError(Exception)"
    categories:
      - "ConfigurationError - invalid configuration"
      - "ConnectionError - service unavailable"
      - "ValidationError - invalid input"
      - "NotFoundError - resource doesn't exist"
      - "ConflictError - resource already exists"
      - "PermissionError - operation not allowed"

  retry_strategy:
    transient_errors:
      - "Network timeouts"
      - "Rate limits"
      - "Temporary unavailability"

    implementation: |
      async def execute_with_retry(
          operation: Callable,
          max_attempts: int = 3,
          backoff: float = 1.0
      ):
          for attempt in range(max_attempts):
              try:
                  return await operation()
              except TransientError as e:
                  if attempt == max_attempts - 1:
                      raise
                  await asyncio.sleep(backoff * (2 ** attempt))

# =============================================================================
# TESTING PATTERNS
# =============================================================================

testing_patterns:
  unit_tests:
    - "Mock all external dependencies"
    - "Test happy path and error cases"
    - "Verify error messages are actionable"

  integration_tests:
    - "Use test database/vector store"
    - "Clean state between tests"
    - "Test actual service interactions"

  fixtures:
    - "Provide factory functions for test data"
    - "Use pytest fixtures for service setup"

# =============================================================================
# VALIDATION & MIGRATION
# =============================================================================

validation_rules:
  - rule: "service_must_be_headless"
    description: >
      Service modules in features/*_service.py and services/*
      MUST NOT import rich.Console or use print-based terminal output.
    severity: "error"
    enforcement: "static analysis + pattern checks"

  - rule: "atomic_actions_return_actionresult"
    description: >
      Atomic action services that participate in workflows MUST
      return ActionResult, not ad-hoc dicts or tuples.
    severity: "error"
    enforcement: "type hints + pattern checks"

  - rule: "write_default_false"
    description: >
      Any service with a write or modify parameter MUST default it to False.
      This rule operationalizes the immutable 'write_defaults_false' principle.
    severity: "error"
    enforcement: "static analysis"

  - rule: "no_ui_imports_in_services"
    description: >
      Service modules MUST NOT import terminal UI components (Rich, click, etc.).
    severity: "error"
    enforcement: "linting + IntentGuard checks"

  - rule: "service_module_naming"
    description: >
      Domain services SHOULD live in features/<domain>/*_service.py to make
      architecture navigable and introspectable by CORE itself.
    severity: "warning"
    enforcement: "naming convention checks"

migration_checklist:
  audit_existing_services:
    - "List all service classes and *_service.py modules."
    - "Identify which architectural pattern each should follow."
    - "Identify which ones are atomic_action_services vs helper_services."
    - "Detect any UI usage (Rich/print) in services."

  refactor_priorities:
    1: "Services with global state (highest risk)"
    2: "Services that emit terminal UI (Rich/print)"
    3: "Services without proper error handling"
    4: "Services with unclear responsibilities"
    5: "Services with poor or no test coverage"

  validation:
    - "Each service can be mapped to a pattern in this file."
    - "Pattern checker validates implementation and headless behavior."
    - "Add service-pattern validation to dev-sync / audit checks."

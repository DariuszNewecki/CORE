# .intent/charter/standards/architecture/layer_contracts.yaml
id: standard_architecture_layer_contracts
version: "1.0.0"
title: "Architecture Standard — Layer Contracts & Symbol Governance"
type: "standard_architecture"
status: active

owners:
  accountable: "Governance Lead"
  responsible:
    - "Core Maintainer"

review:
  frequency: "6 months"

schema_id: "standard.architecture.layer_contracts"

description: |
  Defines architectural layer boundaries and symbol governance rules for CORE's
  layered architecture. Establishes which symbols require capability IDs based on
  their architectural role, not just their visibility.

  CORE's architecture has distinct layers:
  - Features (body/features/): Business capabilities - MUST have IDs
  - Infrastructure (shared/infrastructure/): Service APIs - EXEMPT from IDs
  - CLI Commands (body/cli/): Framework entry points - EXEMPT from IDs
  - API Routes (api/): HTTP endpoints - EXEMPT from IDs
  - Providers (*/providers/): Interface implementations - EXEMPT from IDs

  This standard operationalizes the constitutional principle that capability tracking
  applies to business logic, not architectural infrastructure.

# =============================================================================
# LAYER DEFINITIONS
# =============================================================================

architectural_layers:
  - name: "infrastructure_layer"
    path: "shared/infrastructure/"
    purpose: "Cross-cutting services (DB, LLM, vectors, storage, context)"
    symbol_governance: "public_api"
    rationale: |
      The infrastructure layer provides foundational services to all features.
      Public functions here are intentional service APIs, governed by provider
      interfaces and architectural contracts, not individual capability tracking.

  - name: "provider_layer"
    path: "*/providers/"
    purpose: "External system integrations (LLM providers, DB adapters)"
    symbol_governance: "interface_implementation"
    rationale: |
      Providers implement external contracts (Anthropic, OpenAI, SQLAlchemy).
      They're discovered and invoked polymorphically through interfaces,
      not called directly. Interface compliance is the governance mechanism.

  - name: "cli_commands"
    path: "body/cli/"
    purpose: "Command-line interface entry points"
    symbol_governance: "framework_entrypoint"
    rationale: |
      CLI commands are registered with Typer framework and invoked by name.
      The framework provides the governance (command registration, help text).

  - name: "http_routes"
    path: "api/"
    purpose: "HTTP API endpoints"
    symbol_governance: "framework_entrypoint"
    rationale: |
      FastAPI routes are registered via decorators and invoked by URL path.
      The framework provides the governance (route registration, OpenAPI schema).

  - name: "governance_checks"
    path: "mind/governance/checks/"
    purpose: "Constitutional enforcement checks"
    symbol_governance: "registry_dispatched"
    rationale: |
      Governance checks inherit from BaseCheck and are discovered by the auditor.
      The execute() method is the contract; discovery handles invocation.

  - name: "feature_capabilities"
    path: "features/"
    purpose: "Business domain capabilities"
    symbol_governance: "capability_required"
    rationale: |
      Features implement business logic and domain operations.
      These MUST have capability IDs for traceability and governance.

# =============================================================================
# SYMBOL GOVERNANCE RULES
# =============================================================================

symbol_governance_rules:
  # -------------------------------------------------------------------------
  # EXEMPTION: Infrastructure Service APIs
  # -------------------------------------------------------------------------
  - id: architecture.infrastructure_service_apis
    statement: |
      Public functions in shared/infrastructure/** are architectural service APIs
      and are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "shared.infrastructure"
      is_public_function: true
      type: "function"

    rationale: |
      Infrastructure provides cross-cutting services (database, LLM, vectors, storage).
      These are provider implementations and service contracts, not business capabilities.
      They are governed by:
      - Provider interface contracts
      - Service pattern standards
      - Integration tests

      Examples:
      - shared/infrastructure/llm/providers/anthropic.py::chat_completion
      - shared/infrastructure/database/session_manager.py::get_db_session
      - shared/infrastructure/vector/vector_index_service.py::query

    scope:
      - "shared/infrastructure/**/*.py"

    applies_to:
      - "All public functions providing infrastructure services"
      - "Database session management"
      - "LLM provider implementations"
      - "Vector store operations"
      - "Context service APIs"
      - "Secret management"
      - "Git operations"
      - "Storage handlers"

  # -------------------------------------------------------------------------
  # EXEMPTION: Provider Interface Implementations
  # -------------------------------------------------------------------------
  - id: architecture.provider_implementations
    statement: |
      Functions in */providers/** that implement external provider interfaces
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "/providers/"
      is_public_function: true
      type: "function"

    rationale: |
      Provider implementations satisfy external contracts (LLM APIs, DB drivers).
      They are invoked polymorphically through base classes/protocols, not directly.
      Interface compliance is verified through type checking and integration tests.

      Examples:
      - infrastructure/llm/providers/anthropic.py::chat_completion
      - infrastructure/llm/providers/openai.py::chat_completion
      - infrastructure/llm/providers/ollama.py::chat_completion

    scope:
      - "**/providers/**/*.py"

  # -------------------------------------------------------------------------
  # EXEMPTION: CLI Framework Entry Points
  # -------------------------------------------------------------------------
  - id: architecture.cli_framework_entrypoints
    statement: |
      Public functions in body/cli/** that are registered with Typer framework
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "body.cli"
      is_public_function: true
      type: "function"

    rationale: |
      CLI commands are framework entry points, not capabilities.
      They are:
      - Registered with @app.command() decorators
      - Invoked by command name via Typer
      - Governed by CLI standards (help text, argument validation)

      The underlying business logic they call DOES require capability IDs.

    scope:
      - "body/cli/**/*.py"

    note: |
      CLI commands typically delegate to feature capabilities.
      The delegation target (e.g., features/introspection/analyze.py::analyze_code)
      MUST have a capability ID, even if the CLI wrapper does not.

  # -------------------------------------------------------------------------
  # EXEMPTION: HTTP API Endpoints
  # -------------------------------------------------------------------------
  - id: architecture.http_framework_entrypoints
    statement: |
      Functions in api/** that are FastAPI route handlers
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "api"
      is_public_function: true
      type: "function"

    rationale: |
      HTTP endpoints are framework entry points, governed by:
      - FastAPI route registration (@router.get, @router.post)
      - OpenAPI schema generation
      - Request/response validation

      Like CLI commands, they delegate to capabilities that DO require IDs.

    scope:
      - "api/**/*.py"

  # -------------------------------------------------------------------------
  # EXEMPTION: Registry-Dispatched Methods
  # -------------------------------------------------------------------------
  - id: architecture.registry_dispatched_methods
    statement: |
      Methods discovered and invoked by registries (governance checks, action handlers)
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: ["mind.governance.checks", "body.actions"]
      name_regex: "^execute$"
      type: "function"

    rationale: |
      Registry-dispatched methods follow framework contracts:
      - GovernanceCheck.execute() -> discovered by auditor registry
      - ActionHandler.execute() -> discovered by action registry

      The class itself may have a capability ID, but the execute() method
      is part of the contract, not a standalone capability.

    scope:
      - "mind/governance/checks/**/*.py"
      - "body/actions/**/*.py"

  # -------------------------------------------------------------------------
  # EXEMPTION: Property-like Accessors
  # -------------------------------------------------------------------------
  - id: architecture.property_accessors
    statement: |
      Functions that provide property-like access to configuration or paths
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: ["shared.config", "shared.path_resolver", "mind.governance.audit_context"]
      type: "function"

    rationale: |
      These functions provide attribute-style access to configuration values
      or filesystem paths. They are accessors, not capabilities:
      - settings.paths() -> configuration accessor
      - path_resolver.pattern() -> path accessor
      - audit_context.mind_path -> property accessor

      They have no business logic, just data access.

    scope:
      - "shared/config*.py"
      - "shared/path_*.py"

  # -------------------------------------------------------------------------
  # EXEMPTION: Python Magic Methods
  # -------------------------------------------------------------------------
  - id: architecture.python_magic_methods
    statement: |
      Python __dunder__ methods are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      name_regex: "^__.+__$"
      type: "function"

    rationale: |
      Magic methods are called by Python runtime, not by application code:
      - __init__, __str__, __repr__ -> object lifecycle
      - __enter__, __exit__ -> context managers
      - __call__, __iter__ -> protocol implementations

      They are infrastructure for Python's object model, not capabilities.

  # -------------------------------------------------------------------------
  # EXEMPTION: AST Visitor Pattern Methods
  # -------------------------------------------------------------------------
  - id: architecture.visitor_pattern_methods
    statement: |
      Methods following the Visitor pattern (visit_*) are EXEMPT from capability IDs.

    enforcement: exemption

    match_criteria:
      name_regex: "^visit_"
      type: "function"

    rationale: |
      Visitor pattern methods are called by framework (ast.NodeVisitor):
      - visit_FunctionDef() -> called when AST walker encounters function
      - visit_ClassDef() -> called when AST walker encounters class

      The visitor class itself may be a capability, but individual visit_* methods
      are dispatched by the walker, not standalone capabilities.

  # -------------------------------------------------------------------------
  # EXEMPTION: Mind Enforcement Commands
  # -------------------------------------------------------------------------
  - id: architecture.mind_enforcement_commands
    statement: |
      Public functions in mind/enforcement/** are CLI-like enforcement commands
      and are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "mind.enforcement"
      type: "function"
      is_public_function: true

    rationale: |
      Mind enforcement modules contain CLI-style commands for governance operations:
      - register_guard, list_audits, log_audit

      These are command-style functions, similar to CLI commands, invoked by name
      rather than as tracked capabilities.

  # -------------------------------------------------------------------------
  # EXEMPTION: Agent Helper Methods
  # -------------------------------------------------------------------------
  - id: architecture.agent_helper_methods
    statement: |
      Helper methods in will/agents/** that format or transform data
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "will.agents"
      name_regex: "^format_"
      type: "function"
      is_public_function: true

    rationale: |
      Agent helper methods like format_governance_response() are pure transformations
      called by the agent, not standalone capabilities.

  # -------------------------------------------------------------------------
  # EXEMPTION: Check Helper Properties
  # -------------------------------------------------------------------------
  - id: architecture.check_helper_properties
    statement: |
      Helper properties in governance checks (like exemption_rules property)
      are EXEMPT from capability ID requirements.

    enforcement: exemption

    match_criteria:
      module_path_contains: "mind.governance.checks"
      type: "function"
      is_public_function: true

    rationale: |
      Governance checks may expose helper properties for lazy loading or configuration.
      These are infrastructure for the check itself, not standalone capabilities.

  # -------------------------------------------------------------------------
  # REQUIRED: Feature Capabilities
  # -------------------------------------------------------------------------
  - id: architecture.feature_capabilities_required
    statement: |
      Public functions in features/** that implement business logic
      MUST have capability IDs.

    enforcement: error

    match_criteria:
      module_path_contains: "features/"
      is_public_function: true
      type: "function"
      has_capability_tag: false

    rationale: |
      Features implement business domain logic and operations.
      These are the governed capabilities that require:
      - Unique capability ID (# ID: <uuid>)
      - Docstring explaining purpose
      - Assignment to a domain in manifests

      Features are what CORE exists to govern and evolve.

    scope:
      - "features/**/*.py"

    note: |
      If a feature function is a pure helper, make it private (_prefix).
      Only public feature APIs require capability IDs.

# =============================================================================
# ENFORCEMENT STRATEGY
# =============================================================================

enforcement:
  description: |
    How the OrphanedLogicCheck should apply these rules.

  algorithm:
    step_1: "Load all symbol_governance_rules from this standard"
    step_2: "For each public symbol without a capability ID:"
    step_3: "  Check if symbol matches any EXEMPTION rule criteria"
    step_4: "  If exemption matches -> no finding (allowed)"
    step_5: "  If no exemption matches -> ERROR finding (orphaned logic)"

  implementation_notes:
    - "OrphanedLogicCheck MUST read from this policy, not hardcode exemptions"
    - "Use MindService to load this standard at runtime"
    - "Match criteria should be evaluated using the same logic as entry_point_patterns"
    - "Exemption rules take precedence over error rules"

# =============================================================================
# MIGRATION PATH
# =============================================================================

migration:
  description: |
    How to evolve from hardcoded exemptions to policy-driven governance.

  phases:
    phase_1:
      name: "Deploy Policy"
      tasks:
        - "Add this standard to .intent/charter/standards/architecture/"
        - "Update meta.yaml to include this file"
        - "Validate schema compliance"

    phase_2:
      name: "Update OrphanedLogicCheck"
      tasks:
        - "Remove hardcoded _is_infrastructure_symbol() logic"
        - "Replace with policy reader: context.mind.get_standard('layer_contracts')"
        - "Implement match_criteria evaluation using same logic as entry_point_patterns"

    phase_3:
      name: "Verify Coverage"
      tasks:
        - "Run audit with verbose mode"
        - "Confirm 92 orphans → ~10 orphans"
        - "Review remaining orphans for proper categorization"

    phase_4:
      name: "Document Pattern"
      tasks:
        - "Update ARCHITECTURE.md to explain layer contracts"
        - "Add this as example of policy-driven enforcement"
        - "Use as template for other architectural rules"

# =============================================================================
# METRICS
# =============================================================================

metrics:
  baseline_orphans: 92
  target_orphans: 10
  exemption_rules: 10
  coverage_target: "90% of infrastructure symbols covered by exemptions"

success_criteria:
  - "Audit runs without hardcoded exemptions in Python"
  - "All infrastructure APIs properly exempted via policy"
  - "Only genuine orphans (dead code, missing IDs) flagged as errors"
  - "Policy can be updated without code changes"

# .intent/charter/patterns/atomic_actions.yaml
#
# Constitutional Pattern: Atomic Actions
#
# Defines the fundamental building blocks of CORE's operational model.
# All autonomous operations, whether checks, fixes, or transformations,
# are constitutional atomic actions that compose into workflows.
#
# This pattern establishes:
# - The universal contract for all actions
# - How actions compose into workflows
# - Constitutional governance of execution
# - The Mind-Body-Will boundary for operations

pattern_id: atomic_actions
version: "1.0.1"
status: foundational
category: orchestration
layer: mind

# =============================================================================
# PHILOSOPHICAL FOUNDATION
# =============================================================================

philosophy: |
  CORE is not a collection of commands - it is a constitutional system of
  composable atomic actions.

  An atomic action is the fundamental unit of autonomous operation:
  - It does ONE thing
  - It returns structured results
  - It respects constitutional constraints
  - It composes with other actions

  This pattern establishes that EVERY operation in CORE - whether reading
  (audit checks), writing (fixes), or transforming (sync) - is an atomic
  action governed by the same constitutional principles.

  Workflows are not scripts - they are constitutional orchestrations of
  atomic actions toward a declared goal, with governance at every step.

# =============================================================================
# THE ATOMIC ACTION CONTRACT
# =============================================================================

atomic_action:
  definition: |
    An atomic action is an indivisible unit of work that:
    1. Has a clear, singular purpose
    2. Returns a structured ActionResult
    3. Respects constitutional boundaries
    4. Composes with other actions
    5. Logs to the activity stream

  universal_contract:
    input:
      - name: "Action has a unique identifier"
        example: ["fix.ids", "check.imports", "sync.vectors"]

      - name: "Action declares its intent"
        example: "Assign stable IDs to public symbols"

      - name: "Action specifies its impact"
        values: ["read-only", "write-metadata", "write-code", "write-data"]

      - name: "Action declares constitutional policies it validates"
        example: ["naming_conventions", "structural_integrity"]

    output:
      - name: "ActionResult with standard structure"
        required_fields:
          - action_id: "Unique identifier for this action"
          - ok: "Boolean success indicator"
          - data: "Action-specific structured data"
          - duration_sec: "Execution time"
          - impact: "What changed (if anything)"

        optional_fields:
          - logs: "Debug trace messages"
          - warnings: "Non-fatal issues encountered"
          - suggestions: "Recommended follow-up actions"

    lifecycle:
      - start: "Action announces intent via activity logging"
      - validate: "Action validates preconditions"
      - execute: "Action performs its singular purpose"
      - verify: "Action validates postconditions"
      - report: "Action returns structured ActionResult"
      - complete: "Action logs completion to activity stream"

    ui_contract:
      owner: "workflow_orchestrator_or_cli"
      action_may_print: false
      description: >
        Atomic actions are HEADLESS. They MUST NOT perform any terminal I/O
        (no print(), logging to stdout/stderr, or Rich Console/Progress
        rendering). All UI concerns (spinners, progress bars, status lines)
        are owned exclusively by the calling workflow or CLI layer, which
        consumes ActionResult objects and decides how to present them.

  examples:
    read_action:
      action_id: "check.imports"
      intent: "Verify import grouping follows constitutional conventions"
      impact: "read-only"
      policies: ["import_organization"]
      returns:
        findings_count: "Number of violations found"
        violations: "List of specific violations"
        severity: "Highest severity level"

    write_action:
      action_id: "fix.ids"
      intent: "Assign stable UUIDs to untagged public symbols"
      impact: "write-metadata"
      policies: ["symbol_identification"]
      returns:
        ids_assigned: "Count of IDs added"
        files_modified: "List of files changed"
        symbols_tagged: "List of symbols now identified"

    transform_action:
      action_id: "sync.knowledge"
      intent: "Synchronize filesystem symbols to database"
      impact: "write-data"
      policies: ["knowledge_integrity"]
      returns:
        symbols_synced: "Count of symbols synchronized"
        symbols_added: "Count of new symbols"
        symbols_updated: "Count of updated symbols"

# =============================================================================
# WORKFLOW ORCHESTRATION
# =============================================================================

workflow_orchestration:
  definition: |
    A workflow is a constitutionally governed composition of atomic actions
    organized into phases to achieve a declared goal.

    Workflows are NOT scripts - they are governance structures that:
    - Declare intent upfront
    - Organize actions into logical phases
    - Enforce constitutional constraints
    - Report comprehensive results
    - Enable autonomous decision-making

  workflow_contract:
    declaration:
      - workflow_id: "Unique workflow identifier"
      - goal: "High-level objective (what success means)"
      - phases: "Logical groupings of related actions"
      - abort_policy: "When to stop on failures"
      - retry_policy: "How to handle transient failures"

    execution:
      - activity_logging: "All workflows use ActivityRun context"
      - phase_organization: "Actions grouped into coherent phases"
      - result_collection: "All ActionResults captured"
      - governance_hooks: "Constitutional validation at each phase"

    reporting:
      - phase_summary: "Results per phase"
      - action_details: "Individual action outcomes"
      - timing_data: "Performance metrics"
      - overall_status: "Workflow success/failure"
      - recommendations: "Suggested next steps"

  examples:
    audit_workflow:
      workflow_id: "check.audit"
      goal: "Verify complete constitutional compliance"
      phases:
        - name: "Knowledge Graph"
          actions: ["build.knowledge_graph"]
        - name: "Constitutional Checks"
          actions: ["check.imports", "check.naming", "check.structure"]
      abort_policy: "continue_on_check_failure"

    sync_workflow:
      workflow_id: "dev.sync"
      goal: "Synchronize development environment to compliant state"
      phases:
        - name: "Code Fixers"
          actions: ["fix.ids", "fix.headers", "fix.docstrings"]
        - name: "Database Sync"
          actions: ["sync.vectors", "sync.knowledge"]
      abort_policy: "stop_on_critical_failure"

# =============================================================================
# CONSTITUTIONAL GOVERNANCE
# =============================================================================

constitutional_governance:
  principles:
    - name: "Every action is governed"
      description: |
        No action executes outside constitutional oversight.
        All actions validate against declared policies.

    - name: "Composition preserves governance"
      description: |
        When actions compose into workflows, constitutional
        constraints propagate and compound.

    - name: "Failures are constitutional events"
      description: |
        Action failures are not exceptions - they are
        constitutional states that trigger governance decisions.

    - name: "Autonomy requires governance"
      description: |
        Higher autonomy levels (A3, A4) require MORE governance,
        not less. Atomic actions enable scalable oversight.

  enforcement:
    pre_execution:
      - "Validate action has required constitutional metadata"
      - "Check action's declared policies exist"
      - "Verify action's impact level is authorized"

    during_execution:
      - "Log all state changes to activity stream"
      - "Monitor for policy violations"
      - "Enforce resource limits and timeouts"

    post_execution:
      - "Validate ActionResult structure"
      - "Verify postconditions met"
      - "Store results for governance review"
      - "Trigger follow-up actions if needed"

# =============================================================================
# MIGRATION PATH
# =============================================================================

migration:
  current_state:
    - "Some commands return CommandResult (fix.ids, fix.headers)"
    - "Some checks return AuditCheckResult (check.imports, etc)"
    - "Two separate reporter systems (Audit vs DevSync)"
    - "No unified action abstraction"

  target_state:
    - "All operations return ActionResult (universal contract)"
    - "Unified WorkflowReporter (base + specialized)"
    - "Constitutional validation on all actions"
    - "Enable A3 autonomous orchestration"

  phases:
    phase_1_unification:
      - "Create ActionResult (merge CommandResult + AuditCheckResult)"
      - "Create base WorkflowReporter"
      - "Migrate 2-3 actions to prove pattern"

    phase_2_migration:
      - "Migrate all fix.* commands to ActionResult"
      - "Migrate all check.* commands to ActionResult"
      - "Update reporters to use WorkflowReporter"

    phase_3_governance:
      - "Add constitutional validation hooks"
      - "Implement policy enforcement"
      - "Enable autonomous workflow composition"

    phase_4_autonomy:
      - "Self-healing workflows (failures trigger fixes)"
      - "Autonomous goal planning (A3)"
      - "Self-modification workflows (A4)"

# =============================================================================
# ARCHITECTURAL BOUNDARIES
# =============================================================================

mind_body_will:
  mind_layer:
    responsibilities:
      - "Define what constitutes a valid action"
      - "Declare constitutional policies"
      - "Specify composition rules"
      - "Establish governance criteria"

    artifacts:
      - "This pattern definition"
      - "Policy YAML files in .intent/"
      - "Architectural decision records"

  body_layer:
    responsibilities:
      - "Implement atomic actions"
      - "Execute workflows"
      - "Return structured results"
      - "Respect constitutional constraints"

    artifacts:
      - "Python functions returning ActionResult"
      - "CLI commands (thin wrappers)"
      - "Service implementations"

  will_layer:
    responsibilities:
      - "Decide WHEN to execute actions"
      - "Orchestrate action sequences"
      - "Handle failures and retries"
      - "Make autonomous decisions (A3+)"

    artifacts:
      - "Workflow orchestrators"
      - "Autonomous planning agents"
      - "Decision engines"

# =============================================================================
# VALIDATION RULES
# =============================================================================

validation_rules:
  - rule: "action_must_return_result"
    description: "Every atomic action MUST return an ActionResult"
    severity: "error"
    enforcement: "compile-time type checking"

  - rule: "result_must_be_structured"
    description: "ActionResult.data MUST be a dictionary of typed values"
    severity: "error"
    enforcement: "runtime validation"

  - rule: "workflow_must_declare_intent"
    description: "Every workflow MUST declare its goal and abort policy"
    severity: "error"
    enforcement: "workflow registration"

  - rule: "actions_compose_transitively"
    description: "If A→B and B→C are valid, then A→C MUST be valid"
    severity: "warning"
    enforcement: "static analysis"

  - rule: "governance_never_bypassed"
    description: "No action can skip constitutional validation"
    severity: "critical"
    enforcement: "architectural invariant"

  - rule: "action_must_be_headless"
    description: >
      Atomic actions MUST NOT perform terminal I/O (print, Rich Console/Progress,
      direct writes to stdout/stderr). All UI rendering is the responsibility
      of the calling workflow/CLI layer, which consumes ActionResult objects.
    severity: "error"
    enforcement: "static analysis and linting"

# =============================================================================
# FUTURE EXTENSIONS
# =============================================================================

future_work:
  a3_autonomy:
    - "Actions declare capabilities they provide"
    - "Workflows auto-compose from capability requirements"
    - "Goal planner generates workflow DAGs"
    - "Self-healing on action failures"

  a4_self_modification:
    - "Actions can modify other actions"
    - "Workflows can modify workflows"
    - "Constitutional amendments through governance"
    - "Full self-improvement cycle"

  distributed_execution:
    - "Actions execute across multiple nodes"
    - "Workflow coordination via event bus"
    - "Distributed constitutional validation"
    - "Consensus on governance decisions"

# =============================================================================
# REFERENCES
# =============================================================================

references:
  related_patterns:
    - command_patterns.yaml
    - workflow_patterns.yaml
    - agent_patterns.yaml

  related_docs:
    - docs/architecture/ATOMIC_ACTIONS.md
    - docs/patterns/WORKFLOW_ORCHESTRATION.md

  foundational_commits:
    - "908477d: Introduce CommandResult pattern"
    - "Current: Implement DevSyncReporter workflow orchestration"

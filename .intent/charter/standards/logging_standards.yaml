# .intent/charter/policies/logging_standards.yaml
#
# Constitutional Policy: Logging Standards
# This policy defines the immutable rules for all logging behavior in CORE.

id: logging_standards
version: "1.0.0"
title: "Logging Standards and Consistency Policy"
category: code_quality
severity: error

description: >
  This policy establishes the single source of truth for all logging behavior
  in CORE. Consistency and clarity in logs are critical for debugging,
  auditing, and maintaining system reliability. All code MUST comply with
  these standards without exception.

principles:
  consistency:
    statement: "Every log entry MUST follow the same format regardless of context"
    rationale: "Mixed logging formats make debugging impossible and violate system clarity"

  clarity:
    statement: "Log messages MUST be informative, timestamped, and include context"
    rationale: "Logs serve as the audit trail - ambiguity defeats their purpose"

  single_system:
    statement: "Only ONE logging mechanism may be used throughout the codebase"
    rationale: "Multiple logging systems create confusion and inconsistent output"

rules:
  # === RULE 1: SINGLE LOGGING SYSTEM ===
  single_logging_system:
    id: "LOG-001"
    severity: "error"
    statement: "All logging MUST use Python's standard logging module via shared.logger.getLogger()"

    allowed:
      - "import logging"
      - "from shared.logger import getLogger"
      - "logger = getLogger(__name__)"
      - "logger.info('message')"
      - "logger.debug('message')"
      - "logger.warning('message')"
      - "logger.error('message')"
      - "logger.exception('message')  # for errors with traceback"

    forbidden:
      - "print() for operational messages"
      - "console.print() for operational messages"
      - "console.status() for progress indication"
      - "Rich Progress bars for progress indication"
      - "Rich spinners for status indication"
      - "Direct sys.stdout/stderr writes"
      - "Multiple logger instances with different configurations"

    exceptions:
      - "Rich Console may be used ONLY in CLI command entry points for user-facing prompts/questions"
      - "print() allowed ONLY in standalone scripts that are not part of core system"
      - "Example: Interactive CLI menus that require user input"

    rationale: >
      Using multiple output mechanisms creates timestamp inconsistencies,
      format fragmentation, and makes log analysis impossible. The standard
      logging module provides all necessary functionality.

  # === RULE 2: LOG LEVEL DISCIPLINE ===
  log_level_usage:
    id: "LOG-002"
    severity: "error"
    statement: "Log levels MUST be used according to their semantic meaning"

    levels:
      DEBUG:
        purpose: "Internal implementation details, variable states, execution flow"
        when: "Information useful only during development/debugging"
        examples:
          - "logger.debug('Processing file: %s', filepath)"
          - "logger.debug('Cache hit: %s', cache_key)"
          - "logger.debug('Loaded %d records from database', count)"

      INFO:
        purpose: "Significant operational events, workflow milestones, user actions"
        when: "Information valuable to operators and audit trails"
        examples:
          - "logger.info('Starting vector synchronization')"
          - "logger.info('Code formatting complete: %d files changed', count)"
          - "logger.info('Constitutional audit passed')"

      WARNING:
        purpose: "Unexpected situations that don't prevent operation"
        when: "Something unusual happened but system recovered"
        examples:
          - "logger.warning('API timeout, retrying (attempt %d/%d)', attempt, max_attempts)"
          - "logger.warning('Cache miss for key: %s', key)"
          - "logger.warning('Configuration value missing, using default')"

      ERROR:
        purpose: "Operation failed but system continues"
        when: "An error occurred that affects current operation"
        examples:
          - "logger.error('Failed to vectorize symbol: %s', symbol_path)"
          - "logger.error('Database connection failed, operation aborted')"
          - "logger.error('Constitutional check failed: %s', check_name)"

      CRITICAL:
        purpose: "System integrity compromised, human intervention required"
        when: "Fatal errors that require immediate attention"
        examples:
          - "logger.critical('Database corruption detected')"
          - "logger.critical('Constitutional violation in production')"

    forbidden_patterns:
      - "Using INFO for debug information"
      - "Using ERROR for warnings"
      - "Using DEBUG for important milestones"
      - "Mixing log levels inconsistently for same event type"

  # === RULE 3: MESSAGE FORMAT ===
  message_format:
    id: "LOG-003"
    severity: "error"
    statement: "Log messages MUST be clear, concise, and use consistent formatting"

    requirements:
      structure:
        - "Use imperative or past tense: 'Starting sync' or 'Sync started'"
        - "Include relevant context via % formatting: logger.info('Processed %d items', count)"
        - "Never use f-strings or .format() - use % formatting for lazy evaluation"

      content:
        - "Start with action/subject, not preamble"
        - "Include quantifiable information when relevant"
        - "Use consistent terminology across codebase"

      examples:
        good:
          - "logger.info('Vector synchronization started')"
          - "logger.info('Processed %d/%d symbols', completed, total)"
          - "logger.debug('Database query executed in %.2fs', elapsed)"

        bad:
          - "logger.info('Now we are going to sync vectors')"  # Too verbose
          - "logger.info(f'Processing {symbol}')"  # f-string (eager evaluation)
          - "logger.info('Done!')"  # Not specific enough

    emoji_usage:
      allowed: "Optional emoji prefixes for visual markers in INFO level only"
      examples:
        - "logger.info('✓ Code formatting complete')"
        - "logger.error('✗ Constitutional audit failed')"
        - "logger.warning('⚠ Connection timeout, retrying')"
      restrictions:
        - "Maximum one emoji per message"
        - "Use consistently across similar messages"
        - "Never use animated spinners or progress indicators"

  # === RULE 4: PROGRESS INDICATION ===
  progress_indication:
    id: "LOG-004"
    severity: "error"
    statement: "Progress for long operations MUST be logged at appropriate intervals"

    requirements:
      - "Log start of operation at INFO level"
      - "Log significant milestones at INFO level"
      - "Log progress in DEBUG level at reasonable intervals"
      - "Log completion with summary at INFO level"

    pattern:
      start: "logger.info('Starting operation: %s', operation_name)"
      progress: "logger.debug('Progress: %d/%d items processed', current, total)"
      milestone: "logger.info('Milestone: %s complete', milestone_name)"
      completion: "logger.info('Operation complete: %d items processed', total)"

    example: |
      logger.info('Starting code vectorization: %d symbols', len(symbols))
      for i, symbol in enumerate(symbols):
          process_symbol(symbol)
          if i % 10 == 0:
              logger.debug('Vectorization progress: %d/%d', i+1, len(symbols))
      logger.info('Code vectorization complete: %d symbols processed', len(symbols))

    forbidden:
      - "Rich Progress bars"
      - "Animated spinners"
      - "Console status indicators"
      - "Overwriting previous log lines"

  # === RULE 5: STRUCTURED LOGGING ===
  structured_logging:
    id: "LOG-005"
    severity: "warning"
    statement: "Complex operations SHOULD include structured context"

    technique: "Use extra parameter for machine-readable context"

    example: |
      logger.info(
          'Code generation complete',
          extra={
              'module': module_name,
              'lines_generated': line_count,
              'duration_ms': elapsed_ms,
              'success': True
          }
      )

    benefits:
      - "Enables log aggregation and analysis"
      - "Supports automated monitoring"
      - "Facilitates debugging without string parsing"

  # === RULE 6: ERROR LOGGING ===
  error_logging:
    id: "LOG-006"
    severity: "error"
    statement: "Errors MUST be logged with full context and stack traces"

    pattern: |
      try:
          risky_operation()
      except SpecificException as e:
          logger.error('Operation failed: %s', operation_name, exc_info=True)
          # or
          logger.exception('Operation failed: %s', operation_name)

    requirements:
      - "Always use exc_info=True or logger.exception() for errors"
      - "Include operation context in error message"
      - "Log at ERROR level for recoverable errors"
      - "Log at CRITICAL level for fatal errors"
      - "Never silently catch and ignore exceptions"

    forbidden:
      - "Logging error message without stack trace"
      - "Using print() for error messages"
      - "Catching Exception without logging"

enforcement:
  mechanisms:
    - "Constitutional audit checks for forbidden logging patterns"
    - "Pre-commit hooks reject non-compliant logging"
    - "CI/CD pipeline validates log format consistency"

  detection:
    forbidden_imports:
      - "from rich.console import Console  # except in CLI entry points"
      - "from rich.progress import Progress"
      - "from rich import print as rprint"

    forbidden_patterns:
      - "console.print("
      - "console.status("
      - "Progress("
      - "print()  # except in scripts/"

  remediation:
    - "Automated fixes via 'core-admin dev fix-logging'"
    - "All non-compliant code flagged in constitutional audit"
    - "Pull requests must pass logging validation"

migration:
  phase_1:
    title: "Identify violations"
    command: "core-admin audit logging"
    output: "Report of all logging violations"

  phase_2:
    title: "Automated fixes"
    command: "core-admin fix logging --write"
    changes:
      - "Replace console.print with logger.info"
      - "Remove Rich spinners and progress bars"
      - "Convert print() to appropriate logger calls"
      - "Standardize log message formats"

  phase_3:
    title: "Validation"
    command: "core-admin check ci audit"
    requirement: "Zero logging violations"

examples:
  workflow_logging:
    description: "Complete workflow showing proper logging"
    code: |
      from shared.logger import getLogger

      logger = getLogger(__name__)

      async def dev_sync_workflow(repo_path: str) -> dict:
          """Execute development synchronization workflow."""
          logger.info('Starting dev sync workflow', extra={'repo': repo_path})

          try:
              # Header audit
              logger.info('Starting constitutional header audit')
              violations = await audit_headers()
              logger.info('Header audit complete: %d violations', len(violations))

              # Code formatting
              logger.info('Formatting code with Black')
              files_changed = await format_code()
              logger.info('Code formatting complete: %d files changed', files_changed)

              # Linting
              logger.info('Running Ruff linter')
              issues = await run_linter()
              logger.info('Linting complete: %d issues found', len(issues))

              # Vector sync
              logger.info('Starting vector synchronization')
              result = await sync_vectors()
              logger.info('Vector sync complete: %d vectors updated', result['updated'])

              logger.info('Dev sync workflow complete', extra={'success': True})
              return {'status': 'success', 'files_changed': files_changed}

          except Exception as e:
              logger.exception('Dev sync workflow failed')
              return {'status': 'failed', 'error': str(e)}

  progress_logging:
    description: "Long operation with progress indication"
    code: |
      logger.info('Starting symbol vectorization: %d symbols', len(symbols))

      for i, symbol in enumerate(symbols):
          logger.debug('Processing symbol: %s', symbol.path)

          try:
              vector = await vectorize(symbol)
              await store_vector(vector)

              # Log progress every 10 items
              if (i + 1) % 10 == 0:
                  logger.debug('Vectorization progress: %d/%d', i+1, len(symbols))

          except Exception as e:
              logger.error('Failed to vectorize symbol: %s', symbol.path, exc_info=True)

      logger.info('Symbol vectorization complete: %d/%d succeeded',
                  successful_count, len(symbols))

metadata:
  status: "proposed"
  author: "constitutional-governance"
  requires_quorum: "standard"
  related_policies:
    - "code_quality_standards"
    - "docstring_requirements"
    - "test_coverage_requirements"
  supersedes: []
  effective_date: "2025-12-05"

references:
  - "Python logging documentation: https://docs.python.org/3/library/logging.html"
  - "CORE architectural principles: immutable_principles.yaml"
  - "Code quality patterns: .intent/charter/patterns/"

# .intent/charter/policies/code_standards.yaml
policy_id: "aaa0a228-125d-4013-bfed-c1b58cec0f66" # From original code_style_policy
id: code_standards
version: "2.2.1" # Version bump for simplified header-only rule
title: "Comprehensive Code Quality & Standards"
status: active
purpose: >
  Unified standards for code quality, style, naming, and refactoring patterns.
  Ensures consistent, maintainable, and safe code across the entire codebase.

# === CODE STYLE & FORMATTING ===
style_rules:
  - id: style.linter_required
    statement: "All changes MUST pass ruff (lint) before merge."
    enforcement: error
  - id: style.formatter_required
    statement: "All changes MUST be formatted by black; CI runs black --check."
    enforcement: error
  - id: style.docstrings_public_apis
    statement: "Public APIs MUST have docstrings summarizing intent and parameters."
    enforcement: warn
  - id: style.universal_helper_first
    statement: "Before creating new helpers, check shared.universal. Reuse or extend instead of duplicating."
    enforcement: warn
  - id: style.capability_id_placement
    statement: >
      Primary public symbols that represent distinct capabilities MUST have '# ID: <uuid>'
      tags directly above their definition. Private helpers MUST NOT receive capability IDs.
    enforcement: warn
  - id: style.import_order
    statement: "Imports MUST follow grouping/order and avoid unused imports (enforced by linter)."
    enforcement: warn
  - id: style.fail_on_style_in_ci
    statement: "CI MUST fail on style or lint violations (no auto-fixing in CI)."
    enforcement: error

# === FILE HEADER (PATH COMMENT) ===
file_header_rules:
  - id: layout.src_module_header
    statement: >
      Every Python module under 'src/' MUST start with a single file path comment
      that exactly matches its repo-root path, e.g. '# src/body/cli/admin_cli.py'.
      No other content may appear before this comment except optional leading
      blank lines.
    enforcement: error
    scope:
      - "src/**/*.py"
    details:
      example: "# src/body/cli/admin_cli.py"
      behavior:
        - "If a correct header exists as the first non-empty line, do nothing."
        - "If a header exists but is incorrect, replace it."
        - "If no header exists, insert a new one as the first non-empty line."

import_structure_rules:
  - id: layout.import_grouping
    statement: >
      Imports MUST be grouped in the canonical order: future imports, standard library,
      third-party packages, then internal modules. Mixed groups or interleaving are forbidden.
    enforcement: warn
    scope:
      - "src/**/*.py"
      - "tests/**/*.py"
    details:
      groups:
        - name: future
          examples:
            - "from __future__ import annotations"
        - name: stdlib
          examples:
            - "import os"
            - "from pathlib import Path"
        - name: third_party
          examples:
            - "import qdrant_client"
            - "import sqlalchemy"
            - "import typer"
        - name: internal
          examples:
            - "from shared.logger import getLogger"
            - "from services.git_service import GitService"
            - "from mind.governance.audit_context import AuditorContext"
            - "from will.orchestration.cognitive_service import CognitiveService"

# === CODE HEALTH & COMPLEXITY ===
health_standards:
  max_cognitive_complexity: 15
  max_nesting_depth: 4
  max_line_length: 120
  max_module_lloc: 300
  max_function_lloc: 80
  outlier_standard_deviations: 2.0
  enforce_dead_public_symbols: true

# === SYMBOL METADATA & CAPABILITIES ===
symbol_metadata_rules:
  - id: symbols.public_capability_id_and_docstring
    statement: >
      Public symbols that represent a capability (primary functions/classes not starting
      with '_') MUST have an '# ID: <uuid>' comment directly above the definition and
      MUST provide a meaningful docstring describing behavior and guarantees.
    enforcement: error
    scope:
      - "src/**/*.py"
    details:
      id_comment_format: "^#\\s*ID:\\s*[0-9a-fA-F-]{36}$"
      public_symbol_criteria:
        - "Name does not start with '_'"
        - "Exported as part of module's capability surface (e.g. referenced in manifests or used externally)."
      docstring_requirements:
        - "Summarize the behavior and main responsibilities."
        - "Document side-effects or external interactions when non-trivial."
  - id: symbols.private_helpers_no_id_required
    statement: >
      Private helpers (functions/classes starting with '_') MUST NOT receive capability
      IDs. They MAY have docstrings where non-trivial but are not required to.
    enforcement: warn
    scope:
      - "src/**/*.py"
    details:
      private_symbol_criteria:
        - "Name starts with '_'"
      rationale: >
        Capability IDs are reserved for traceable, externally meaningful symbols.
        Helper functions should not pollute the capability graph.

# === CAPABILITY LINTING ===
capability_rules:
  - id: caps.meaningful_description
    statement: "Capability descriptions MUST be specific and non-placeholder."
    enforcement: error
  - id: caps.owner_required
    statement: "Active capabilities MUST have an assigned owner (agent/team)."
    enforcement: error
  - id: caps.no_placeholder_text
    statement: "Descriptions such as 'TBD' or 'N/A' are forbidden."
    enforcement: error
  - id: caps.id_format
    statement: "Source code linkers MUST use the form '# ID: <uuid>'."
    enforcement: error

# === DEPENDENCY INJECTION ===
dependency_injection:
  - id: di.no_direct_instantiation
    statement: "Services and features MUST NOT directly instantiate other major services. Dependencies MUST be injected via the constructor."
    enforcement: error
    scope:
      - "src/features/**/*.py"
      - "src/services/**/*.py"
    # === START OF FIXED EXCLUSIONS ===
    # We are telling the auditor that this rule does not apply to test files,
    # and certain entrypoints like the admin CLI, which are allowed to wire up
    # the system manually.
    exclusions:
      - "src/body/cli/admin_cli.py"
      - "src/features/governance/runtime_validator.py"
      - "tests/**/*.py"
    # === END OF FIXED EXCLUSIONS ===
    forbidden_instantiations:
      - "CognitiveService"
      - "GitService"
      - "ConstitutionalAuditor"
      - "QdrantService"
      - "ActionRegistry"
      - "PlanExecutor"
      - "SelfHealingAdvisor"
      - "CapabilityInvoker"
      - "CoderAgent"
  - id: di.no_global_session_import
    statement: "Modules within 'features' and 'services' MUST NOT directly import `get_session`. The database session MUST be injected."
    enforcement: error
    scope:
      - "src/features/**/*.py"
      - "src/services/repositories/**/*.py"
    forbidden_imports:
      - "services.database.session_manager.get_session"
      - "services.repositories.db.engine.get_session"
  - id: di.constructor_injection_preferred
    statement: "Services SHOULD receive their dependencies through the `__init__` constructor, with type hints."
    enforcement: warn

# === NAMING CONVENTIONS (REFACTORED) ===
# This section is now fully self-contained. The auditor reads the scope and pattern from here.

naming_conventions:
  intent:
    - id: "intent.policy_file_naming"
      description: "All charter policy files must use snake_case and end with '.yaml'."
      enforcement: error
      scope: ".intent/charter/policies/*.yaml"
      pattern: "^[a-z0-9_]+\\.yaml$"
    - id: "intent.policy_schema_naming"
      description: "Schemas for policy files must end with '_policy_schema.json'."
      enforcement: error
      scope: ".intent/charter/schemas/*_policy_schema.json"
      pattern: "^[a-z0-9_]+_policy_schema\\.json$"
    - id: "intent.artifact_schema_naming"
      description: "Schemas for non-policy artifacts must end with '_schema.[json|yaml]'."
      enforcement: error
      scope: ".intent/charter/schemas/*"
      pattern: "^[a-z0-9_]+_schema\\.(json|yaml)$"
      exclusions:
        - "*_policy_schema.json"
    - id: "intent.prompt_file_naming"
      description: "All prompt files must use snake_case and end with '.prompt'."
      enforcement: error
      scope: ".intent/mind/prompts/*.prompt"
      pattern: "^[a-z0-9_]+\\.prompt$"
    - id: "intent.proposal_file_naming"
      description: "All proposal files must follow the 'cr-*.yaml' naming convention."
      enforcement: warn
      scope: ".intent/proposals/*.yaml"
      pattern: "^cr-[a-zA-Z0-9_-]+\\.yaml$"
      exclusions:
        - "README.md"
  code:
    - id: "code.python_module_naming"
      description: "All Python source files must use snake_case naming."
      enforcement: error
      scope: "src/**/*.py"
      pattern: "^[a-z0-9_]+\\.py$"
      exclusions:
        - "__init__.py"
    - id: "code.python_test_module_naming"
      description: "All Python test files must be prefixed with 'test_'."
      enforcement: error
      scope: "tests/**/*.py"
      pattern: "^test_[a-z0-9_]+\\.py$"
      exclusions:
        - "__init__.py"
        - "conftest.py"

# === REFACTORING PATTERNS ===
refactoring_patterns:
  - id: extract_function
    description: "Move coherent logic into new function with clear name and docstring."
    guardrails:
      - must_keep_behavior: true
      - add_unit_tests: true
      - run_audit: true
  - id: extract_module
    description: "Move related functions/classes into new module; update imports and domain boundaries."
    guardrails:
      - must_keep_behavior: true
      - update_import_map: true
      - run_audit: true
  - id: introduce_facade
    description: "Add a facade/API layer to hide complexity behind a small, stable surface."
    guardrails:
      - document_contract: true
      - avoid_breaking_changes: true
      - run_audit: true

refactoring_rules:
  - id: refactor.requires_tests
    statement: "Any refactor that changes public behavior MUST include tests or proof of equivalence."
    enforcement: error
  - id: refactor.update_capabilities
    statement: "When moving symbols, update capability tags and manifests accordingly."
    enforcement: warn
  - id: refactor.audit_after
    statement: "A constitutional audit MUST run after refactors before merge."
    enforcement: error

# === AUDIT HOOKS ===
audit_checks:
  - id: header_compliance
    description: >
      Verify that every src module has a correct file header comment in line with
      file_header_rules.layout.src_module_header (path comment matching repo-root path).
    scope:
      - "src/**/*.py"
    severity: error
    policy_ref:
      policy: code_standards
      rule: layout.src_module_header
    auto_fix:
      tool: "fix_header"
      prompt_path: ".intent/mind/prompts/fix_header.prompt"
      mode: "suggest_or_write"

# .intent/charter/policies/code_purity.yaml
policy_id: "73394e37-41db-4391-93e8-6ced1a61735f"
id: code_purity
version: "1.2.0"
title: "Code Purity and Pollution Prevention"
status: active
purpose: >
  Define the strict boundary between Code (Logic/Safety) and Database (Metadata/State).
  Ensures the codebase remains clean, readable, and free of "Split-Brain" metadata configuration.

core_principle: |
  Source code is for LOGIC and RUNTIME CONTRACTS.
  Descriptive metadata (Ownership, Relationships, Status) belongs in the Knowledge Graph (DB).

# =============================================================================
# 1. GOVERNANCE CONTRACTS (REQUIRED INFRASTRUCTURE)
# =============================================================================
# These decorators are functional requirements for the runtime engine.
# They are NOT considered pollution.

governance_contracts:
  - type: "atomic_action_binding"
    format: "@atomic_action(action_id='...', impact='...', policies=[...])"
    justification: |
      Required for the 'Will' layer (IntentGuard) to validate safety *before* execution.
      Defines the blast radius (impact) and laws (policies) governing the function.
      Without this, the function is invisible to the governance engine.
    enforcement: "error"

  - type: "framework_bindings"
    format: "@app.get(...), @command(...), @pytest.fixture(...)"
    justification: "Required for framework wiring (FastAPI, Typer, Pytest)."
    enforcement: "allowed"

# =============================================================================
# 2. STRUCTURAL ANCHORS (NECESSARY EVILS)
# =============================================================================
# These are strictly for maintaining link integrity between Code and DB.

structural_anchors:
  - type: "stable_id"
    format: "# ID: <uuid>"
    location: "Immediately above function/class definition"
    justification: |
      The database schema uses UUIDs (core.symbols.id) as primary keys.
      Code refactoring (renaming/moving files) breaks these links unless a
      stable ID anchor is present in the source.
    enforcement: "error"

# =============================================================================
# 3. FORBIDDEN POLLUTION (STRICTLY BANNED)
# =============================================================================
# These violate the SSOT principle by duplicating data that belongs in the DB.

forbidden_pollution:
  - type: "descriptive_decorators"
    examples:
      - "@capability(name='...', owner='TeamA')"
      - "@meta(status='active', domain='core')"
      - "@owner('user@example.com')"
    reason: |
      Database Schema 'core.capabilities' already stores owner, domain, and status.
      Storing this in code creates a sync hazard (Split-Brain).
    alternative: "Use 'core-admin manage database' or 'fix docstrings' to update metadata."
    enforcement: "error"

  - type: "inline_configuration"
    examples:
      - "CONFIG = {'timeout': 300, 'retry': 3}"
      - "API_KEY = 'sk-...'"
    reason: |
      Database Schema 'core.runtime_settings' (and SecretsService) is the SSOT for config.
      Hardcoding config prevents dynamic runtime adjustment and creates security risks.
    alternative: "Load via ConfigService (backed by core.runtime_settings)."
    enforcement: "warning"

# =============================================================================
# METADATA STRATEGY (The Separation of Concerns)
# =============================================================================

metadata_strategy:
  source_code:
    contains: "Logic, Flow Control, Runtime Safety Contracts (@atomic_action)"
    role: "The Body (Execution)"

  database:
    contains: "Ownership, Capability Definitions, Relationships, Execution History"
    schema_ref: "001_consolidated_schema.sql"
    role: "The Mind (Memory & Context)"

  docstrings:
    contains: "Human-readable intent, usage examples, reasoning"
    role: "Explanation"

# =============================================================================
# ENFORCEMENT
# =============================================================================

enforcement:
  - id: "no_descriptive_pollution"
    check: "Scan for decorators containing static metadata keys (owner, status, domain)"
    violation: "Descriptive metadata found in source code"
    fix: "Move metadata to Database via 'manage database sync'"

  - id: "safety_contract_required"
    check: "Public state-modifying functions must have @atomic_action"
    violation: "Ungoverned execution path detected"
    fix: "Apply @atomic_action decorator"

philosophy: |
  If the data describes *what* the code is (e.g., "This is an active capability owned by Bob"),
  it lives in the Database.

  If the data describes *how* the code behaves safely (e.g., "This writes data and checks policy X"),
  it lives in the Code (Decorator).

workflow_type: refactor_modularity
description: >
  Split monolithic modules into cohesive units to improve architectural health.
  Focuses on preserving behavior while improving structure.

phases:
  - interpret
  - planning
  - code_generation
  - canary_validation
  - style_check
  - execution

success_criteria:
  syntax_valid: true # Code must parse (AST validation)
  logic_preserved: true # Size check: new code â‰¥ 40% of original
  style_violations: 0 # No formatting/linting errors
  # canary_passes: advisory       # Test failures logged but don't block
  # existing_tests_pass: advisory # Same - tests expect old API structure

write_required: true
dangerous: true
timeout_minutes: 30

# Workflow-specific configuration
goal_template: "Refactor {file_path} to improve modularity score from {current_score} to below {target_score}"

pre_workflow_checks:
  - file_exists
  # - modularity_score_exceeds_threshold  # TODO: Implement when metrics available
  - no_active_refactoring

post_workflow_actions:
  - recalculate_modularity_score # TODO: Store result in execution phase data
  - update_architectural_metrics
  - flag_for_coverage_remediation # New modules need tests

notes: >
  This workflow does NOT generate tests.
  New code starts with 0% coverage.
  Coverage remediation is a separate workflow.

  SUCCESS CRITERIA (UNIX Philosophy - Do One Thing Well):

  Refactoring job: Make code modular (even if tests break)
  - Code must be syntactically valid (can import/parse)
  - Logic must be preserved (no mass deletion)
  - Style must be clean (constitutional compliance)

  Testing job: Comes AFTER via coverage_remediation workflow
  - Old tests expect old API structure
  - Refactoring changes APIs (expected)
  - Generate new tests for new structure later

  CANARY'S ROLE: Advisory sensor, not gatekeeper
  - Reports what broke (valuable data)
  - Logs failures for human review
  - Does NOT block refactoring progress

  Rationale: "Working ugly code > No code because tests broke"
  Better to have modular code that needs new tests than
  monolithic code that passes old tests.

  The interpret phase converts the user's natural language goal into
  a structured refactoring task before planning begins.

workflow_type: refactor_modularity
description: >
  Split monolithic modules into cohesive units to improve architectural health.
  Focuses on preserving behavior while improving structure.

phases:
  - interpret
  - planning
  - code_generation
  - canary_validation
  - style_check
  - execution

success_criteria:
  canary_passes: true
  style_violations: 0
  existing_tests_pass: true
  # modularity_score_improvement: "> 10"  # TODO: Implement metric calculation in post_workflow_actions

write_required: true
dangerous: true
timeout_minutes: 30

# Workflow-specific configuration
goal_template: "Refactor {file_path} to improve modularity score from {current_score} to below {target_score}"

pre_workflow_checks:
  - file_exists
  # - modularity_score_exceeds_threshold  # TODO: Implement when metrics available
  - no_active_refactoring

post_workflow_actions:
  - recalculate_modularity_score # TODO: Store result in execution phase data
  - update_architectural_metrics
  - flag_for_coverage_remediation # New modules need tests

notes: >
  This workflow does NOT generate tests.
  New code starts with 0% coverage.
  Coverage remediation is a separate workflow.

  Success = Code works (canary) + Passes style + Better structure
  Missing tests are addressed by fix coverage workflow later.

  The interpret phase converts the user's natural language goal into
  a structured refactoring task before planning begins.

  IMPORTANT: modularity_score_improvement criterion is commented out because
  the metric calculation infrastructure is not yet implemented. Once
  post_workflow_actions can calculate and return metrics, this criterion
  can be re-enabled. For now, success is based on:
  - Existing tests still pass (behavior preserved)
  - No style violations (code quality maintained)
  - No phase failures (all transformations successful)

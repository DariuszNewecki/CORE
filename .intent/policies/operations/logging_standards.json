{
  "id": "standard_logging",
  "version": "2.0.0",
  "title": "Operations Standard \u2013 Logging & Observability",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Platform SRE",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "meta.policy",
  "purpose": "Establishes the single source of truth for logging behavior in CORE. Consistency and clarity are critical for debugging, auditing, and reliability. All code MUST comply with these standards without exception.\n",
  "rules": [
    {
      "id": "logging.single_logging_system",
      "category": "logging",
      "rationale": "Using multiple operational output mechanisms creates timestamp inconsistencies and format fragmentation. The standard logging module provides the required features and integrates with centralized observability.\n",
      "enforcement": "error",
      "statement": "All operational logging MUST use Python's standard logging via shared.logger.getLogger().",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: All operational logging MUST use Python's standard logging via shared.logger.getLogger()."
        }
      }
    },
    {
      "id": "logging.log_level_usage",
      "category": "logging",
      "rationale": "Strengthens system governance regarding logging.log_level_usage.",
      "enforcement": "error",
      "statement": "Log levels MUST be used according to their semantic meaning.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Log levels MUST be used according to their semantic meaning."
        }
      }
    },
    {
      "id": "logging.message_format",
      "category": "logging",
      "rationale": "Strengthens system governance regarding logging.message_format.",
      "enforcement": "error",
      "statement": "Operational log messages MUST be clear, concise, and consistently formatted.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Operational log messages MUST be clear, concise, and consistently formatted."
        }
      }
    },
    {
      "id": "logging.progress_indication",
      "category": "logging",
      "rationale": "Strengthens system governance regarding logging.progress_indication.",
      "enforcement": "error",
      "statement": "Progress for long operations MUST be logged at appropriate intervals (operational logging).",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Progress for long operations MUST be logged at appropriate intervals (operational logging)."
        }
      }
    },
    {
      "id": "logging.structured_logging",
      "category": "logging",
      "rationale": "Use extra parameter for machine-readable context (must be JSON-serializable).",
      "enforcement": "warning",
      "statement": "Complex operations SHOULD include structured context.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Complex operations SHOULD include structured context."
        }
      }
    },
    {
      "id": "logging.error_logging",
      "category": "logging",
      "rationale": "Strengthens system governance regarding logging.error_logging.",
      "enforcement": "error",
      "statement": "Errors MUST be logged with full context and stack traces.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Errors MUST be logged with full context and stack traces."
        }
      }
    },
    {
      "id": "logging.cli_command_output",
      "category": "logging",
      "rationale": "CLI commands have a contract: they must be able to emit machine-readable results to stdout. Operational logs must remain consistent and parseable as logs. Mixing these channels breaks both.\n",
      "enforcement": "error",
      "statement": "CLI commands MUST separate command output from operational logging.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: CLI commands MUST separate command output from operational logging."
        }
      }
    }
  ],
  "logging_principles": {
    "consistency": "Every log entry MUST follow the same format regardless of context",
    "clarity": "Log messages MUST be informative, timestamped, and include context",
    "single_system": "Only ONE operational logging mechanism may be used throughout the codebase"
  },
  "log_levels": {
    "DEBUG": {
      "purpose": "Internal implementation details, variable states, execution flow",
      "when": "Information useful only during development/debugging"
    },
    "INFO": {
      "purpose": "Significant operational events, workflow milestones, user actions",
      "when": "Information valuable to operators and audit trails"
    },
    "WARNING": {
      "purpose": "Unexpected situations that don't prevent operation",
      "when": "Something unusual happened but system recovered"
    },
    "ERROR": {
      "purpose": "Operation failed but system continues",
      "when": "An error occurred that affects current operation"
    },
    "CRITICAL": {
      "purpose": "System integrity compromised, human intervention required",
      "when": "Fatal errors that require immediate attention"
    }
  },
  "allowed_patterns": {
    "imports": [
      "import logging",
      "from shared.logger import getLogger"
    ],
    "usage": [
      "logger = getLogger(__name__)",
      "logger.info('message')",
      "logger.debug('message')",
      "logger.warning('message')",
      "logger.error('message', exc_info=True)",
      "logger.exception('message')"
    ],
    "cli_output": [
      "typer.echo(json.dumps(data))",
      "typer.echo(yaml.dump(data))",
      "console.print() in CLI entry points for human-readable output"
    ]
  },
  "forbidden_patterns": {
    "operational_logging": [
      "print() for operational messages",
      "console.print() for operational messages",
      "console.status() for progress indication",
      "Rich Progress bars",
      "Rich spinners",
      "sys.stdout.write/sys.stderr.write for operational messages"
    ],
    "formatting": [
      "f-strings in log messages",
      ".format() in log messages"
    ],
    "error_handling": [
      "Logging errors without exc_info=True",
      "Silent exception catching"
    ]
  },
  "message_format_rules": {
    "structure": [
      "Use imperative or past tense: 'Starting sync' or 'Sync started'",
      "Include context via % formatting: logger.info('Processed %d items', count)",
      "Never use f-strings or .format() - use % formatting for lazy evaluation"
    ],
    "content": [
      "Start with action/subject, not preamble",
      "Include quantifiable information when relevant",
      "Use consistent terminology across codebase"
    ]
  },
  "emoji_usage": {
    "allowed": "Optional emoji prefixes for visual markers in INFO level only",
    "restrictions": [
      "Maximum one emoji per message",
      "Use consistently across similar messages",
      "Never use animated spinners or progress indicators"
    ]
  },
  "progress_pattern": {
    "start": "logger.info('Starting operation: %s', operation_name)",
    "progress": "logger.debug('Progress: %d/%d items processed', current, total)",
    "milestone": "logger.info('Milestone: %s complete', milestone_name)",
    "completion": "logger.info('Operation complete: %d items processed', total)"
  },
  "structured_logging_requirements": [
    "extra values MUST be JSON-serializable (no objects, callables, exceptions)",
    "Do not include secrets or PII in extra"
  ],
  "error_logging_requirements": [
    "Always use exc_info=True or logger.exception() for errors",
    "Include operation context in error message",
    "Log at ERROR level for recoverable errors",
    "Log at CRITICAL level for fatal errors",
    "Never silently catch and ignore exceptions"
  ],
  "cli_output_separation": {
    "command_output": "The primary result of a CLI command (human-readable or structured), intended for stdout consumption.",
    "operational_logging": "Observability/audit/debug information intended for logs, not for command result consumption.",
    "requirements": [
      "Structured output MUST be written to stdout using typer.echo()",
      "Structured command output MUST NOT be emitted through logger.*",
      "Human-readable CLI output MAY use rich Console in CLI command entry points",
      "Operational events MUST use logger.* and MUST NOT be mixed into structured stdout output"
    ]
  },
  "examples": {
    "workflow_logging": "from shared.logger import getLogger\n\nlogger = getLogger(__name__)\n\nasync def dev_sync_workflow(repo_path: str) -> dict:\n    logger.info('Starting dev sync workflow', extra={'repo': repo_path})\n    \n    try:\n        logger.info('Starting constitutional header audit')\n        violations = await audit_headers()\n        logger.info('Header audit complete: %d violations', len(violations))\n        \n        logger.info('Formatting code with Black')\n        files_changed = await format_code()\n        logger.info('Code formatting complete: %d files changed', files_changed)\n        \n        logger.info('Dev sync workflow complete', extra={'success': True})\n        return {'status': 'success', 'files_changed': files_changed}\n    \n    except Exception:\n        logger.exception('Dev sync workflow failed')\n        return {'status': 'failed'}\n",
    "cli_structured_output": "import json\nimport typer\nfrom shared.logger import getLogger\n\nlogger = getLogger(__name__)\n\ndef command(format: str = \"json\") -> None:\n    data = {\"status\": \"ok\"}\n    logger.info('Command executed')\n    \n    if format == \"json\":\n        typer.echo(json.dumps(data))\n    else:\n        typer.echo(\"status=ok\")\n",
    "progress_indication": "logger.info('Starting code vectorization: %d symbols', len(symbols))\nfor i, symbol in enumerate(symbols):\n    process_symbol(symbol)\n    if i % 10 == 0:\n        logger.debug('Vectorization progress: %d/%d', i + 1, len(symbols))\nlogger.info('Code vectorization complete: %d symbols processed', len(symbols))\n"
  },
  "metadata": {
    "status": "active",
    "author": "constitutional-governance",
    "requires_quorum": "standard",
    "related_policies": [
      "code_quality_standards",
      "docstring_requirements",
      "test_coverage_requirements"
    ],
    "supersedes": [],
    "effective_date": "2025-12-18",
    "migration_notes": "Converted from legacy nested format to flat rules structure v2.0.0"
  },
  "references": [
    "Python logging documentation: https://docs.python.org/3/library/logging.html",
    "CORE architectural principles: immutable_principles.yaml",
    "Code quality patterns: .intent/charter/patterns/"
  ],
  "additionalProperties": false
}

{
  "id": "standard_architecture_service_rules",
  "version": "1.0.0",
  "title": "Architecture Standard \u2013 Service Patterns",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Architecture Owner",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "meta.policy",
  "description": "Defines canonical patterns for all infrastructure and body-layer services in CORE.\nServices manage stateful resources (DB, vectors, LLMs) and provide\nclean interfaces for business logic.\n\nThis pattern file has two dimensions:\n- Architectural patterns: how different kinds of services are structured\n  (stateful services, repositories, facades, observers, etc.).\n- Behavioral contract: how ALL services must behave (headless, safe-by-default,\n  consistent result contracts) so they can be orchestrated by workflows and agents.\n",
  "service_contract": {
    "headless": {
      "description": "Services are part of the Body layer and MUST be headless. They MUST NOT render terminal UI or depend on interactive input. All user-facing UX belongs to workflows/CLI (Will layer).\n",
      "rules": [
        "No use of rich.Console or other terminal UI libraries in services.",
        "No print() calls in services.",
        "No input() or interactive prompts in services.",
        "Services communicate via return values, logging, and exceptions only."
      ]
    },
    "safety": {
      "description": "Mutating behavior must be explicit and safe-by-default. This operationalizes the 'write_defaults_false' immutable principle at the service level.\n",
      "rules": [
        "Any parameter that controls side effects MUST default to False (e.g. write=False).",
        "Services SHOULD support dry-run behavior where feasible.",
        "Read-only operations MUST be clearly distinguishable from write operations.",
        "Services MUST NOT perform writes without an explicit, intentional flag."
      ]
    },
    "results": {
      "description": "Services MUST return predictable, structured results. High-level operations that participate in workflows use ActionResult. Low-level helpers may return plain types but MUST remain headless and easily wrappable.\n",
      "types": {
        "atomic_action_service": {
          "description": "High-level operations that are directly orchestrated by workflows/agents and appear in audit trails MUST return ActionResult.\n",
          "contract": [
            "Return type: shared.action_types.ActionResult.",
            "action_id identifies the operation semantically (e.g. 'fix.headers', 'sync.vectors').",
            "ok indicates success/failure.",
            "data contains structured, JSON-serializable fields.",
            "duration_sec captures execution time when meaningful.",
            "impact indicates side-effect level (read-only/write-metadata/write-code/write-data) when applicable."
          ]
        },
        "helper_service": {
          "description": "Narrow supporting operations MAY return plain Python types (dict, list, domain objects) but MUST remain headless and deterministic where possible.\n",
          "contract": [
            "No terminal UI.",
            "Errors communicated via exceptions or sentinel values, NOT via UI.",
            "Can be wrapped by an atomic_action_service that returns ActionResult."
          ]
        }
      }
    },
    "logging": {
      "description": "Services use the shared logger for observability. Logging is for operators and debugging, not interactive UX.\n",
      "rules": [
        "Use shared.logger.getLogger(__name__) for logging.",
        "INFO: high-level progress or key events.",
        "DEBUG: detailed, per-item information that may be noisy.",
        "WARNING / ERROR: unexpected failures, misconfigurations, or degraded behavior.",
        "Avoid WARNING/ERROR inside tight loops; prefer DEBUG to prevent log spam."
      ]
    }
  },
  "ui_boundary": {
    "description": "Reinforces that services MUST be headless. All terminal UI (Rich progress bars, spinners, banners, summaries) belongs to the workflow/CLI layer as defined in workflow_patterns.yaml (ui_contract).\n",
    "forbidden_in_services": [
      "from rich.console import Console",
      "from rich.progress import Progress",
      "print(...)",
      "Prompting for user input (input(), Confirm, etc.)"
    ],
    "allowed_in_services": [
      "Logging via shared.logger",
      "Raising exceptions or returning ActionResult/values",
      "Pure computations and data transformations"
    ],
    "orchestration_responsibility": [
      "Workflows/CLI own progress bars, spinners, banners, and summaries.",
      "Services may expose progress via structured data (e.g. counts), not via UI.",
      "Any new Rich-based UI MUST live in workflow/CLI modules, not in services."
    ]
  },
  "service_composition": {
    "dependency_injection": {
      "principle": "Services receive dependencies via constructor",
      "benefits": [
        "Testable with mocks",
        "Explicit dependencies",
        "No hidden coupling"
      ],
      "example": "# Good: Dependencies injected\nclass AutonomousDeveloper:\n    def __init__(\n        self,\n        planner: PlannerAgent,\n        coder: CoderAgent,\n        knowledge: KnowledgeService\n    ):\n        self._planner = planner\n        self._coder = coder\n        self._knowledge = knowledge\n\n# Bad: Creating dependencies internally\nclass AutonomousDeveloper:\n    def __init__(self):\n        self._planner = PlannerAgent()  # Hard to test!\n        self._coder = CoderAgent()      # Can't mock!\n"
    },
    "service_registry": {
      "purpose": "Central registry for service instances",
      "pattern": "class ServiceRegistry:\n    \"\"\"Central registry of initialized services.\"\"\"\n\n    def __init__(self):\n        self._services: Dict[Type, Any] = {}\n\n    def register(self, service_type: Type, instance: Any) -> None:\n        \"\"\"Register service instance.\"\"\"\n        self._services[service_type] = instance\n\n    def get(self, service_type: Type[T]) -> T:\n        \"\"\"Get service by type.\"\"\"\n        return self._services[service_type]\n",
      "usage": "Use for application-level service wiring, not within services"
    }
  },
  "testing_patterns": {
    "unit_tests": [
      "Mock all external dependencies",
      "Test happy path and error cases",
      "Verify error messages are actionable"
    ],
    "integration_tests": [
      "Use test database/vector store",
      "Clean state between tests",
      "Test actual service interactions"
    ],
    "fixtures": [
      "Provide factory functions for test data",
      "Use pytest fixtures for service setup"
    ]
  },
  "rules": [
    {
      "rule_id": "service_must_be_headless",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_0",
      "enforcement": "error",
      "statement": "Service modules in features/*_service.py and services/* MUST NOT import rich.Console or use print-based terminal output.\n",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "rule_id": "atomic_actions_return_actionresult",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_1",
      "enforcement": "error",
      "statement": "Atomic action services that participate in workflows MUST return ActionResult, not ad-hoc dicts or tuples.\n",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Atomic action services that participate in workflows MUST return ActionResult, not ad-hoc dicts or tuples.\n"
        }
      }
    },
    {
      "rule_id": "write_default_false",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_2",
      "enforcement": "error",
      "statement": "Any service with a write or modify parameter MUST default it to False. This rule operationalizes the immutable 'write_defaults_false' principle.\n",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Any service with a write or modify parameter MUST default it to False. This rule operationalizes the immutable 'write_defaults_false' principle.\n"
        }
      }
    },
    {
      "rule_id": "no_ui_imports_in_services",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_3",
      "enforcement": "error",
      "statement": "Service modules MUST NOT import terminal UI components (Rich, click, etc.).\n",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "rule_id": "service_module_naming",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_4",
      "enforcement": "warning",
      "statement": "Domain services SHOULD live in features/<domain>/*_service.py to make architecture navigable and introspectable by CORE itself.\n",
      "check": {
        "engine": "glob_gate",
        "params": {
          "check_type": "path_restriction"
        }
      }
    },
    {
      "id": "standard_architecture_service_rules.pattern.stateful_service",
      "category": "architectural_pattern",
      "statement": "Must follow the stateful_service pattern structure.",
      "enforcement": "error",
      "rationale": "Manage long-lived stateful resources",
      "check": {
        "engine": "llm_gate",
        "params": {}
      }
    },
    {
      "id": "standard_architecture_service_rules.pattern.stateless_transformer",
      "category": "architectural_pattern",
      "statement": "Must follow the stateless_transformer pattern structure.",
      "enforcement": "error",
      "rationale": "Transform data without side effects",
      "check": {
        "engine": "llm_gate",
        "params": {}
      }
    },
    {
      "id": "standard_architecture_service_rules.pattern.repository_pattern",
      "category": "architectural_pattern",
      "statement": "Must follow the repository_pattern pattern structure.",
      "enforcement": "error",
      "rationale": "Abstract database operations behind domain interface",
      "check": {
        "engine": "llm_gate",
        "params": {}
      }
    },
    {
      "id": "standard_architecture_service_rules.pattern.facade_pattern",
      "category": "architectural_pattern",
      "statement": "Must follow the facade_pattern pattern structure.",
      "enforcement": "error",
      "rationale": "Provide simplified interface to complex subsystem",
      "check": {
        "engine": "llm_gate",
        "params": {}
      }
    },
    {
      "id": "standard_architecture_service_rules.pattern.observer_pattern",
      "category": "architectural_pattern",
      "statement": "Must follow the observer_pattern pattern structure.",
      "enforcement": "error",
      "rationale": "Decouple event producers from consumers",
      "check": {
        "engine": "llm_gate",
        "params": {}
      }
    }
  ],
  "migration_checklist": {
    "audit_existing_services": [
      "List all service classes and *_service.py modules.",
      "Identify which architectural pattern each should follow.",
      "Identify which ones are atomic_action_services vs helper_services.",
      "Detect any UI usage (Rich/print) in services."
    ],
    "refactor_priorities": {
      "1": "Services with global state (highest risk)",
      "2": "Services that emit terminal UI (Rich/print)",
      "3": "Services without proper error handling",
      "4": "Services with unclear responsibilities",
      "5": "Services with poor or no test coverage"
    },
    "validation": [
      "Each service can be mapped to a pattern in this file.",
      "Pattern checker validates implementation and headless behavior.",
      "Add service-pattern validation to dev-sync / audit checks."
    ]
  },
  "additionalProperties": false
}

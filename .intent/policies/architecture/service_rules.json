{
  "id": "standard_architecture_service_rules",
  "version": "1.0.0",
  "title": "Architecture Standard \u2013 Service Patterns",
  "type": "standard_architecture",
  "status": "active",
  "owners": {
    "accountable": "Architecture Owner",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "policy.structure",
  "description": "Defines canonical patterns for all infrastructure and body-layer services in CORE.\nServices manage stateful resources (DB, vectors, LLMs) and provide\nclean interfaces for business logic.\n\nThis pattern file has two dimensions:\n- Architectural patterns: how different kinds of services are structured\n  (stateful services, repositories, facades, observers, etc.).\n- Behavioral contract: how ALL services must behave (headless, safe-by-default,\n  consistent result contracts) so they can be orchestrated by workflows and agents.\n",
  "service_contract": {
    "headless": {
      "description": "Services are part of the Body layer and MUST be headless. They MUST NOT render terminal UI or depend on interactive input. All user-facing UX belongs to workflows/CLI (Will layer).\n",
      "rules": [
        "No use of rich.Console or other terminal UI libraries in services.",
        "No print() calls in services.",
        "No input() or interactive prompts in services.",
        "Services communicate via return values, logging, and exceptions only."
      ]
    },
    "safety": {
      "description": "Mutating behavior must be explicit and safe-by-default. This operationalizes the 'write_defaults_false' immutable principle at the service level.\n",
      "rules": [
        "Any parameter that controls side effects MUST default to False (e.g. write=False).",
        "Services SHOULD support dry-run behavior where feasible.",
        "Read-only operations MUST be clearly distinguishable from write operations.",
        "Services MUST NOT perform writes without an explicit, intentional flag."
      ]
    },
    "results": {
      "description": "Services MUST return predictable, structured results. High-level operations that participate in workflows use ActionResult. Low-level helpers may return plain types but MUST remain headless and easily wrappable.\n",
      "types": {
        "atomic_action_service": {
          "description": "High-level operations that are directly orchestrated by workflows/agents and appear in audit trails MUST return ActionResult.\n",
          "contract": [
            "Return type: shared.action_types.ActionResult.",
            "action_id identifies the operation semantically (e.g. 'fix.headers', 'sync.vectors').",
            "ok indicates success/failure.",
            "data contains structured, JSON-serializable fields.",
            "duration_sec captures execution time when meaningful.",
            "impact indicates side-effect level (read-only/write-metadata/write-code/write-data) when applicable."
          ]
        },
        "helper_service": {
          "description": "Narrow supporting operations MAY return plain Python types (dict, list, domain objects) but MUST remain headless and deterministic where possible.\n",
          "contract": [
            "No terminal UI.",
            "Errors communicated via exceptions or sentinel values, NOT via UI.",
            "Can be wrapped by an atomic_action_service that returns ActionResult."
          ]
        }
      }
    },
    "logging": {
      "description": "Services use the shared logger for observability. Logging is for operators and debugging, not interactive UX.\n",
      "rules": [
        "Use shared.logger.getLogger(__name__) for logging.",
        "INFO: high-level progress or key events.",
        "DEBUG: detailed, per-item information that may be noisy.",
        "WARNING / ERROR: unexpected failures, misconfigurations, or degraded behavior.",
        "Avoid WARNING/ERROR inside tight loops; prefer DEBUG to prevent log spam."
      ]
    }
  },
  "ui_boundary": {
    "description": "Reinforces that services MUST be headless. All terminal UI (Rich progress bars, spinners, banners, summaries) belongs to the workflow/CLI layer as defined in workflow_patterns.yaml (ui_contract).\n",
    "forbidden_in_services": [
      "from rich.console import Console",
      "from rich.progress import Progress",
      "print(...)",
      "Prompting for user input (input(), Confirm, etc.)"
    ],
    "allowed_in_services": [
      "Logging via shared.logger",
      "Raising exceptions or returning ActionResult/values",
      "Pure computations and data transformations"
    ],
    "orchestration_responsibility": [
      "Workflows/CLI own progress bars, spinners, banners, and summaries.",
      "Services may expose progress via structured data (e.g. counts), not via UI.",
      "Any new Rich-based UI MUST live in workflow/CLI modules, not in services."
    ]
  },
  "write_semantics": {
    "description": "To support safe autonomy and reversible behavior, services must be explicit about write behavior and support dry-run where practical.\n",
    "rules": {
      "parameters": [
        "Any mutating service SHOULD accept write: bool = False.",
        "Services MAY also accept dry_run: bool, but MUST keep semantics consistent (dry_run == not write).",
        "Read-only services SHOULD omit write/dry_run parameters entirely."
      ],
      "behavior": [
        "When write=False, services MUST NOT perform irreversible operations.",
        "When write=False, services SHOULD still compute and return what WOULD happen where feasible.",
        "When write=True, services perform the actual mutation and report impact in ActionResult or return data."
      ]
    },
    "example_atomic_action": "async def sync_vectors_action(\n    qdrant_service: QdrantService,\n    write: bool = False,\n) -> ActionResult:\n    dry_run = not write\n    ...\n"
  },
  "patterns": [
    {
      "pattern_id": "stateful_service",
      "type": "infrastructure",
      "purpose": "Manage long-lived stateful resources",
      "applies_to": [
        "Database connections",
        "Vector store clients",
        "LLM API clients",
        "File system watchers"
      ],
      "lifecycle": {
        "initialization": [
          "Load configuration from environment/config files",
          "Validate connection parameters",
          "Establish connection with retry logic",
          "Verify service health",
          "Log successful initialization"
        ],
        "usage": [
          "Provide clean, typed interface",
          "Handle transient failures gracefully",
          "Implement connection pooling where appropriate",
          "Cache results when safe"
        ],
        "shutdown": [
          "Flush pending operations",
          "Close connections cleanly",
          "Log shutdown completion"
        ]
      },
      "implementation_requirements": {
        "structure": [
          "Single class per service",
          "Dependency injection via constructor",
          "No global state or singletons",
          "Async-first where I/O bound"
        ],
        "error_handling": [
          "MUST raise specific exceptions (not generic Exception)",
          "MUST log errors with context",
          "SHOULD implement retry with backoff",
          "SHOULD provide circuit breaker for external services"
        ],
        "testing": [
          "MUST be mockable (interface-based)",
          "MUST have unit tests with mocked dependencies",
          "SHOULD have integration tests with real services"
        ]
      },
      "example_skeleton": "class DatabaseService:\n    \"\"\"Manages PostgreSQL connection and operations.\"\"\"\n\n    def __init__(self, config: DatabaseConfig):\n        self._config = config\n        self._connection = None\n        self._initialized = False\n\n    async def initialize(self) -> None:\n        \"\"\"Establish database connection with validation.\"\"\"\n        # Connect, validate, set _initialized = True\n\n    async def execute_query(self, query: str, params: dict) -> List[dict]:\n        \"\"\"Execute parameterized query with error handling.\"\"\"\n        if not self._initialized:\n            raise ServiceNotInitializedError()\n        # Execute with retries, return results\n\n    async def shutdown(self) -> None:\n        \"\"\"Clean shutdown of database connection.\"\"\"\n        # Close connection, cleanup resources\n"
    },
    {
      "pattern_id": "stateless_transformer",
      "type": "pure_logic",
      "purpose": "Transform data without side effects",
      "applies_to": [
        "Validators",
        "Parsers",
        "Formatters",
        "Calculators"
      ],
      "guarantees": [
        "Pure functions - same input always produces same output",
        "No hidden state",
        "No I/O operations",
        "Easily testable"
      ],
      "implementation_requirements": {
        "structure": [
          "Static methods or pure functions preferred",
          "No instance variables (if class-based)",
          "Type hints for all inputs/outputs"
        ],
        "naming": [
          "Verbs that describe transformation: parse_, validate_, format_"
        ],
        "testing": [
          "Property-based testing recommended",
          "100% code coverage achievable"
        ]
      },
      "example_skeleton": "class YAMLProcessor:\n    \"\"\"Pure YAML processing operations.\"\"\"\n\n    @staticmethod\n    def parse_strict(content: str) -> dict:\n        \"\"\"Parse YAML with strict validation.\"\"\"\n        # Pure transformation, no side effects\n\n    @staticmethod\n    def validate_schema(data: dict, schema: dict) -> List[str]:\n        \"\"\"Validate data against schema, return violations.\"\"\"\n        # Pure validation, returns results\n"
    },
    {
      "pattern_id": "repository_pattern",
      "type": "data_access",
      "purpose": "Abstract database operations behind domain interface",
      "applies_to": [
        "Symbol repository",
        "Policy repository",
        "Audit log repository",
        "Capability repository"
      ],
      "structure": {
        "interface_layer": [
          "Define domain operations (save_symbol, find_by_id, etc.)",
          "Return domain objects, not raw DB rows",
          "Hide SQL/query details from callers"
        ],
        "implementation_layer": [
          "Translate domain operations to SQL",
          "Handle connection management",
          "Map DB rows to domain objects"
        ]
      },
      "implementation_requirements": {
        "naming": [
          "End with 'Repository': SymbolRepository",
          "Methods follow domain language, not SQL"
        ],
        "methods": {
          "standard_operations": [
            "async def save(entity: DomainObject) -> None",
            "async def find_by_id(id: str) -> Optional[DomainObject]",
            "async def find_all(filters: dict) -> List[DomainObject]",
            "async def delete(id: str) -> bool"
          ],
          "query_methods": [
            "Use domain-specific names: find_orphaned_symbols()",
            "Return domain objects, not dictionaries"
          ]
        },
        "error_handling": [
          "Raise domain exceptions, not DB exceptions",
          "NotFoundError instead of SQLAlchemy NoResultFound"
        ]
      },
      "example_skeleton": "class SymbolRepository:\n    \"\"\"Repository for Symbol domain objects.\"\"\"\n\n    def __init__(self, db_service: DatabaseService):\n        self._db = db_service\n\n    async def save(self, symbol: Symbol) -> None:\n        \"\"\"Persist symbol to database.\"\"\"\n        # Translate Symbol -> SQL INSERT/UPDATE\n\n    async def find_by_canonical_name(self, name: str) -> Optional[Symbol]:\n        \"\"\"Find symbol by canonical name.\"\"\"\n        # SQL query, map result -> Symbol object\n\n    async def find_orphaned(self) -> List[Symbol]:\n        \"\"\"Find symbols without file references.\"\"\"\n        # Domain-specific query\n"
    },
    {
      "pattern_id": "facade_pattern",
      "type": "simplification",
      "purpose": "Provide simplified interface to complex subsystem",
      "applies_to": [
        "Cognitive orchestrator (hides multiple LLM clients)",
        "Knowledge service (hides DB + Qdrant + vectorizer)",
        "Audit service (hides multiple checkers)"
      ],
      "guarantees": [
        "Single entry point for complex operations",
        "Coordinates multiple services",
        "Hides implementation complexity"
      ],
      "implementation_requirements": {
        "structure": [
          "Composes multiple services",
          "Provides high-level methods",
          "Handles coordination logic"
        ],
        "responsibilities": [
          "Service orchestration",
          "Error aggregation",
          "Transaction boundaries"
        ],
        "anti_patterns": [
          "Don't reimplement service logic",
          "Don't hold state beyond request scope",
          "Don't become a god object"
        ]
      },
      "example_skeleton": "class KnowledgeService:\n    \"\"\"Facade for all knowledge graph operations.\"\"\"\n\n    def __init__(\n        self,\n        db_repo: SymbolRepository,\n        vector_service: QdrantService,\n        vectorizer: KnowledgeVectorizer\n    ):\n        self._db = db_repo\n        self._vectors = vector_service\n        self._vectorizer = vectorizer\n\n    async def add_symbol(self, symbol: Symbol) -> None:\n        \"\"\"Add symbol to both DB and vector store.\"\"\"\n        # 1. Save to DB\n        # 2. Generate embedding\n        # 3. Store in Qdrant\n        # Coordinate all three\n\n    async def search_similar(self, query: str, limit: int) -> List[Symbol]:\n        \"\"\"Search symbols by semantic similarity.\"\"\"\n        # 1. Get embedding for query\n        # 2. Vector search in Qdrant\n        # 3. Hydrate from DB\n        # Return complete Symbol objects\n"
    },
    {
      "pattern_id": "observer_pattern",
      "type": "event_driven",
      "purpose": "Decouple event producers from consumers",
      "applies_to": [
        "File system watchers",
        "Constitutional monitors",
        "Audit loggers"
      ],
      "structure": [
        "Observable: emits events",
        "Observer: receives and handles events",
        "Event: data payload"
      ],
      "implementation_requirements": [
        "Use async event handlers",
        "Observers should not block",
        "Failed observers shouldn't crash observable"
      ],
      "example_skeleton": "class ConstitutionalMonitor:\n    \"\"\"Observable for constitutional violations.\"\"\"\n\n    def __init__(self):\n        self._observers: List[Callable] = []\n\n    def subscribe(self, handler: Callable[[ViolationEvent], None]) -> None:\n        \"\"\"Register violation handler.\"\"\"\n        self._observers.append(handler)\n\n    async def _notify_violation(self, violation: ViolationEvent) -> None:\n        \"\"\"Notify all observers of violation.\"\"\"\n        for observer in self._observers:\n            try:\n                await observer(violation)\n            except Exception as e:\n                logger.error(f\"Observer failed: {e}\")\n"
    }
  ],
  "service_composition": {
    "dependency_injection": {
      "principle": "Services receive dependencies via constructor",
      "benefits": [
        "Testable with mocks",
        "Explicit dependencies",
        "No hidden coupling"
      ],
      "example": "# Good: Dependencies injected\nclass AutonomousDeveloper:\n    def __init__(\n        self,\n        planner: PlannerAgent,\n        coder: CoderAgent,\n        knowledge: KnowledgeService\n    ):\n        self._planner = planner\n        self._coder = coder\n        self._knowledge = knowledge\n\n# Bad: Creating dependencies internally\nclass AutonomousDeveloper:\n    def __init__(self):\n        self._planner = PlannerAgent()  # Hard to test!\n        self._coder = CoderAgent()      # Can't mock!\n"
    },
    "service_registry": {
      "purpose": "Central registry for service instances",
      "pattern": "class ServiceRegistry:\n    \"\"\"Central registry of initialized services.\"\"\"\n\n    def __init__(self):\n        self._services: Dict[Type, Any] = {}\n\n    def register(self, service_type: Type, instance: Any) -> None:\n        \"\"\"Register service instance.\"\"\"\n        self._services[service_type] = instance\n\n    def get(self, service_type: Type[T]) -> T:\n        \"\"\"Get service by type.\"\"\"\n        return self._services[service_type]\n",
      "usage": "Use for application-level service wiring, not within services"
    }
  },
  "error_handling": {
    "exception_hierarchy": {
      "base": "CoreServiceError(Exception)",
      "categories": [
        "ConfigurationError - invalid configuration",
        "ConnectionError - service unavailable",
        "ValidationError - invalid input",
        "NotFoundError - resource doesn't exist",
        "ConflictError - resource already exists",
        "PermissionError - operation not allowed"
      ]
    },
    "retry_strategy": {
      "transient_errors": [
        "Network timeouts",
        "Rate limits",
        "Temporary unavailability"
      ],
      "implementation": "async def execute_with_retry(\n    operation: Callable,\n    max_attempts: int = 3,\n    backoff: float = 1.0\n):\n    for attempt in range(max_attempts):\n        try:\n            return await operation()\n        except TransientError as e:\n            if attempt == max_attempts - 1:\n                raise\n            await asyncio.sleep(backoff * (2 ** attempt))\n"
    }
  },
  "testing_patterns": {
    "unit_tests": [
      "Mock all external dependencies",
      "Test happy path and error cases",
      "Verify error messages are actionable"
    ],
    "integration_tests": [
      "Use test database/vector store",
      "Clean state between tests",
      "Test actual service interactions"
    ],
    "fixtures": [
      "Provide factory functions for test data",
      "Use pytest fixtures for service setup"
    ]
  },
  "rules": [
    {
      "rule_id": "service_must_be_headless",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_0",
      "enforcement": "error",
      "statement": "Service modules in features/*_service.py and services/* MUST NOT import rich.Console or use print-based terminal output.\n",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "rule_id": "atomic_actions_return_actionresult",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_1",
      "enforcement": "error",
      "statement": "Atomic action services that participate in workflows MUST return ActionResult, not ad-hoc dicts or tuples.\n",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Atomic action services that participate in workflows MUST return ActionResult, not ad-hoc dicts or tuples.\n"
        }
      }
    },
    {
      "rule_id": "write_default_false",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_2",
      "enforcement": "error",
      "statement": "Any service with a write or modify parameter MUST default it to False. This rule operationalizes the immutable 'write_defaults_false' principle.\n",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Any service with a write or modify parameter MUST default it to False. This rule operationalizes the immutable 'write_defaults_false' principle.\n"
        }
      }
    },
    {
      "rule_id": "no_ui_imports_in_services",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_3",
      "enforcement": "error",
      "statement": "Service modules MUST NOT import terminal UI components (Rich, click, etc.).\n",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "rule_id": "service_module_naming",
      "category": "validation",
      "rationale": "Strengthens system governance regarding unspecified requirements.",
      "id": "service_rules.auto_rule_4",
      "enforcement": "warning",
      "statement": "Domain services SHOULD live in features/<domain>/*_service.py to make architecture navigable and introspectable by CORE itself.\n",
      "check": {
        "engine": "glob_gate",
        "params": {
          "check_type": "path_restriction"
        }
      }
    }
  ],
  "migration_checklist": {
    "audit_existing_services": [
      "List all service classes and *_service.py modules.",
      "Identify which architectural pattern each should follow.",
      "Identify which ones are atomic_action_services vs helper_services.",
      "Detect any UI usage (Rich/print) in services."
    ],
    "refactor_priorities": {
      "1": "Services with global state (highest risk)",
      "2": "Services that emit terminal UI (Rich/print)",
      "3": "Services without proper error handling",
      "4": "Services with unclear responsibilities",
      "5": "Services with poor or no test coverage"
    },
    "validation": [
      "Each service can be mapped to a pattern in this file.",
      "Pattern checker validates implementation and headless behavior.",
      "Add service-pattern validation to dev-sync / audit checks."
    ]
  },
  "additionalProperties": false
}

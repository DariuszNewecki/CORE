{
  "id": "standard_architecture_atomic_actions",
  "version": "1.1.0",
  "title": "Architecture Standard – Atomic Actions",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Governance Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "meta.policy",
  "pattern_id": "atomic_actions",
  "category": "orchestration",
  "layer": "mind",
  "philosophy": "CORE is not a collection of commands - it is a constitutional system of\ncomposable atomic actions.\n\nAn atomic action is the fundamental unit of autonomous operation:\n- It does ONE thing\n- It returns structured results\n- It respects constitutional constraints\n- It composes with other actions\n\nThis pattern establishes that EVERY operation in CORE - whether reading\n(audit checks), writing (fixes), or transforming (sync) - is an atomic\naction governed by the same constitutional principles.\n\nWorkflows are not scripts - they are constitutional orchestrations of\natomic actions toward a declared goal, with governance at every step.\n",
  "atomic_action": {
    "definition": "An atomic action is an indivisible unit of work that:\n1. Has a clear, singular purpose\n2. Returns a structured ActionResult\n3. Respects constitutional boundaries\n4. Composes with other actions\n5. Logs to the activity stream\n",
    "universal_contract": {
      "input": [
        {
          "name": "Action has a unique identifier",
          "example": [
            "fix.ids",
            "check.imports",
            "sync.vectors"
          ]
        },
        {
          "name": "Action declares its intent",
          "example": "Assign stable IDs to public symbols"
        },
        {
          "name": "Action specifies its impact",
          "values": [
            "read-only",
            "write-metadata",
            "write-code",
            "write-data"
          ]
        },
        {
          "name": "Action declares constitutional policies it validates",
          "example": [
            "naming_conventions",
            "structural_integrity"
          ]
        }
      ],
      "output": [
        {
          "name": "ActionResult with standard structure",
          "required_fields": [
            {
              "action_id": "Unique identifier for this action"
            },
            {
              "ok": "Boolean success indicator"
            },
            {
              "data": "Action-specific structured data"
            },
            {
              "duration_sec": "Execution time"
            },
            {
              "impact": "What changed (if anything)"
            }
          ],
          "optional_fields": [
            {
              "logs": "Debug trace messages"
            },
            {
              "warnings": "Non-fatal issues encountered"
            },
            {
              "suggestions": "Recommended follow-up actions"
            }
          ]
        }
      ],
      "lifecycle": [
        {
          "start": "Action announces intent via activity logging"
        },
        {
          "validate": "Action validates preconditions"
        },
        {
          "execute": "Action performs its singular purpose"
        },
        {
          "verify": "Action validates postconditions"
        },
        {
          "report": "Action returns structured ActionResult"
        },
        {
          "complete": "Action logs completion to activity stream"
        }
      ],
      "ui_contract": {
        "owner": "workflow_orchestrator_or_cli",
        "action_may_print": false,
        "description": "Atomic actions are HEADLESS. They MUST NOT perform any terminal I/O (no print(), logging to stdout/stderr, or Rich Console/Progress rendering). All UI concerns (spinners, progress bars, status lines) are owned exclusively by the calling workflow or CLI layer, which consumes ActionResult objects and decides how to present them.\n\nNOTE: Headless enforcement migrated to body.no_ui_imports_in_body and body.no_print_or_input_in_body (ast_gate).\n"
      }
    },
    "examples": {
      "read_action": {
        "action_id": "check.imports",
        "intent": "Verify import grouping follows constitutional conventions",
        "impact": "read-only",
        "policies": [
          "import_organization"
        ],
        "returns": {
          "findings_count": "Number of violations found",
          "violations": "List of specific violations",
          "severity": "Highest severity level"
        }
      },
      "write_action": {
        "action_id": "fix.ids",
        "intent": "Assign stable UUIDs to untagged public symbols",
        "impact": "write-metadata",
        "policies": [
          "symbol_identification"
        ],
        "returns": {
          "ids_assigned": "Count of IDs added",
          "files_modified": "List of files changed",
          "symbols_tagged": "List of symbols now identified"
        }
      },
      "transform_action": {
        "action_id": "sync.knowledge",
        "intent": "Synchronize filesystem symbols to database",
        "impact": "write-data",
        "policies": [
          "knowledge_integrity"
        ],
        "returns": {
          "symbols_synced": "Count of symbols synchronized",
          "symbols_added": "Count of new symbols",
          "symbols_updated": "Count of updated symbols"
        }
      }
    }
  },
  "workflow_orchestration": {
    "definition": "A workflow is a constitutionally governed composition of atomic actions\norganized into phases to achieve a declared goal.\n\nWorkflows are NOT scripts - they are governance structures that:\n- Declare intent upfront\n- Organize actions into logical phases\n- Enforce constitutional constraints\n- Report comprehensive results\n- Enable autonomous decision-making\n",
    "workflow_contract": {
      "declaration": [
        {
          "workflow_id": "Unique workflow identifier"
        },
        {
          "goal": "High-level objective (what success means)"
        },
        {
          "phases": "Logical groupings of related actions"
        },
        {
          "abort_policy": "When to stop on failures"
        },
        {
          "retry_policy": "How to handle transient failures"
        }
      ],
      "execution": [
        {
          "activity_logging": "All workflows use ActivityRun context"
        },
        {
          "phase_organization": "Actions grouped into coherent phases"
        },
        {
          "result_collection": "All ActionResults captured"
        },
        {
          "governance_hooks": "Constitutional validation at each phase"
        }
      ],
      "reporting": [
        {
          "phase_summary": "Results per phase"
        },
        {
          "action_details": "Individual action outcomes"
        },
        {
          "timing_data": "Performance metrics"
        },
        {
          "overall_status": "Workflow success/failure"
        },
        {
          "recommendations": "Suggested next steps"
        }
      ]
    },
    "examples": {
      "audit_workflow": {
        "workflow_id": "check.audit",
        "goal": "Verify complete constitutional compliance",
        "phases": [
          {
            "name": "Knowledge Graph",
            "actions": [
              "build.knowledge_graph"
            ]
          },
          {
            "name": "Constitutional Checks",
            "actions": [
              "check.imports",
              "check.naming",
              "check.structure"
            ]
          }
        ],
        "abort_policy": "continue_on_check_failure"
      },
      "sync_workflow": {
        "workflow_id": "dev.sync",
        "goal": "Synchronize development environment to compliant state",
        "phases": [
          {
            "name": "Code Fixers",
            "actions": [
              "fix.ids",
              "fix.headers",
              "fix.docstrings"
            ]
          },
          {
            "name": "Database Sync",
            "actions": [
              "sync.vectors",
              "sync.knowledge"
            ]
          }
        ],
        "abort_policy": "stop_on_critical_failure"
      }
    }
  },
  "constitutional_governance": {
    "principles": [
      {
        "name": "Every action is governed",
        "description": "No action executes outside constitutional oversight.\nAll actions validate against declared policies.\n"
      },
      {
        "name": "Composition preserves governance",
        "description": "When actions compose into workflows, constitutional\nconstraints propagate and compound.\n"
      },
      {
        "name": "Failures are constitutional events",
        "description": "Action failures are not exceptions - they are\nconstitutional states that trigger governance decisions.\n"
      },
      {
        "name": "Autonomy requires governance",
        "description": "Higher autonomy levels (A3, A4) require MORE governance,\nnot less. Atomic actions enable scalable oversight.\n"
      }
    ],
    "enforcement": {
      "pre_execution": [
        "Validate action has required constitutional metadata",
        "Check action's declared policies exist",
        "Verify action's impact level is authorized"
      ],
      "during_execution": [
        "Log all state changes to activity stream",
        "Monitor for policy violations",
        "Enforce resource limits and timeouts"
      ],
      "post_execution": [
        "Validate ActionResult structure",
        "Verify postconditions met",
        "Store results for governance review",
        "Trigger follow-up actions if needed"
      ]
    }
  },
  "migration": {
    "current_state": [
      "Some commands return CommandResult (fix.ids, fix.headers)",
      "Some checks return AuditCheckResult (check.imports, etc)",
      "Two separate reporter systems (Audit vs DevSync)",
      "No unified action abstraction"
    ],
    "target_state": [
      "All operations return ActionResult (universal contract)",
      "Unified WorkflowReporter (base + specialized)",
      "Constitutional validation on all actions",
      "Enable A3 autonomous orchestration"
    ],
    "phases": {
      "phase_1_unification": [
        "Create ActionResult (merge CommandResult + AuditCheckResult)",
        "Create base WorkflowReporter",
        "Migrate 2-3 actions to prove pattern"
      ],
      "phase_2_migration": [
        "Migrate all fix.* commands to ActionResult",
        "Migrate all check.* commands to ActionResult",
        "Update reporters to use WorkflowReporter"
      ],
      "phase_3_governance": [
        "Add constitutional validation hooks",
        "Implement policy enforcement",
        "Enable autonomous workflow composition"
      ],
      "phase_4_autonomy": [
        "Self-healing workflows (failures trigger fixes)",
        "Autonomous goal planning (A3)",
        "Self-modification workflows (A4)"
      ]
    }
  },
  "mind_body_will": {
    "mind_layer": {
      "responsibilities": [
        "Define what constitutes a valid action",
        "Declare constitutional policies",
        "Specify composition rules",
        "Establish governance criteria"
      ],
      "artifacts": [
        "This pattern definition",
        "Policy YAML files in .intent/",
        "Architectural decision records"
      ]
    },
    "body_layer": {
      "responsibilities": [
        "Implement atomic actions",
        "Execute workflows",
        "Return structured results",
        "Respect constitutional constraints"
      ],
      "artifacts": [
        "Python functions returning ActionResult",
        "CLI commands (thin wrappers)",
        "Service implementations"
      ]
    },
    "will_layer": {
      "responsibilities": [
        "Decide WHEN to execute actions",
        "Orchestrate action sequences",
        "Handle failures and retries",
        "Make autonomous decisions (A3+)"
      ],
      "artifacts": [
        "Workflow orchestrators",
        "Autonomous planning agents",
        "Decision engines"
      ]
    }
  },
  "rules": [
    {
      "id": "atomic.result_must_be_structured",
      "rationale": "runtime validation",
      "enforcement": "error",
      "statement": "ActionResult.data MUST be a dictionary of typed values",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: ActionResult.data MUST be a dictionary of typed values"
        }
      }
    },
    {
      "id": "atomic.workflow_must_declare_intent",
      "rationale": "workflow registration",
      "enforcement": "error",
      "statement": "Every workflow MUST declare its goal and abort policy",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Every workflow MUST declare its goal and abort policy"
        }
      }
    },
    {
      "id": "atomic.actions_compose_transitively",
      "rationale": "Strengthens system governance regarding atomic.actions_compose_transitively.",
      "enforcement": "warning",
      "statement": "If A→B and B→C are valid, then A→C MUST be valid",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: If A→B and B→C are valid, then A→C MUST be valid"
        }
      }
    },
    {
      "id": "atomic.governance_never_bypassed",
      "rationale": "architectural invariant",
      "enforcement": "error",
      "statement": "No action can skip constitutional validation",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: No action can skip constitutional validation"
        }
      }
    }
  ],
  "removed_rules": {
    "note": "The following rules were removed as duplicates of existing ast_gate enforcement:",
    "atomic.action_must_return_result": "Duplicate of body.atomic_actions_use_actionresult (ast_gate) in body_contracts.json",
    "atomic.action_must_be_headless": "Duplicate of body.no_ui_imports_in_body and body.no_print_or_input_in_body (ast_gate) in body_contracts.json"
  },
  "future_work": {
    "a3_autonomy": [
      "Actions declare capabilities they provide",
      "Workflows auto-compose from capability requirements",
      "Goal planner generates workflow DAGs",
      "Self-healing on action failures"
    ],
    "a4_self_modification": [
      "Actions can modify other actions",
      "Workflows can modify workflows",
      "Constitutional amendments through governance",
      "Full self-improvement cycle"
    ],
    "distributed_execution": [
      "Actions execute across multiple nodes",
      "Workflow coordination via event bus",
      "Distributed constitutional validation",
      "Consensus on governance decisions"
    ]
  },
  "references": {
    "related_patterns": [
      "command_patterns.yaml",
      "workflow_patterns.yaml",
      "agent_patterns.yaml"
    ],
    "related_docs": [
      "docs/architecture/ATOMIC_ACTIONS.md",
      "docs/patterns/WORKFLOW_ORCHESTRATION.md"
    ],
    "foundational_commits": [
      "908477d: Introduce CommandResult pattern",
      "Current: Implement DevSyncReporter workflow orchestration"
    ]
  },
  "additionalProperties": false
}

{
  "id": "standard_code_purity",
  "version": "2.0.0",
  "title": "Code Standard \u2013 Purity & Side Effects",
  "type": "policy",
  "status": "active",
  "owners": {
    "accountable": "Code Quality Owner",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "schema_id": "meta.policy",
  "policy_id": "73394e37-41db-4391-93e8-6ced1a61735f",
  "purpose": "Define the strict boundary between Code (Logic/Safety) and Database (Metadata/State). Ensures the codebase remains clean, readable, and free of 'Split-Brain' metadata configuration.",
  "core_principle": "Source code is for LOGIC and RUNTIME CONTRACTS. Descriptive metadata (Ownership, Relationships, Status) belongs in the Knowledge Graph (DB).",
  "rules": [
    {
      "id": "purity.forbidden_decorators",
      "statement": "Source code MUST NOT contain descriptive metadata decorators: @capability, @meta, or @owner.",
      "enforcement": "error",
      "rationale": "Database Schema 'core.capabilities' already stores owner, domain, and status. Storing this in code creates a sync hazard (Split-Brain).",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "forbidden_decorators",
          "forbidden": [
            "capability",
            "meta",
            "owner"
          ],
          "remediation": "Use 'core-admin manage database' or 'fix docstrings' to update metadata."
        }
      }
    },
    {
      "id": "purity.no_inline_configuration",
      "statement": "Hardcoding configuration (timeouts, retry limits, API keys) in source code is forbidden.",
      "enforcement": "warning",
      "rationale": "Database Schema 'core.runtime_settings' is the SSOT for config. Hardcoding prevents dynamic runtime adjustment and creates security risks.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "forbidden_assignments",
          "targets": [
            "CONFIG",
            "API_KEY",
            "SECRET_KEY"
          ],
          "remediation": "Load via ConfigService (backed by core.runtime_settings)."
        }
      }
    },
    {
      "id": "purity.stable_id_anchor",
      "statement": "Primary public symbols MUST have a stable ID anchor (# ID: <uuid>) immediately above definition.",
      "enforcement": "error",
      "rationale": "The DB uses UUIDs as primary keys. Refactoring (renaming/moving) breaks links unless a stable anchor is present in source.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "required_patterns": [
            "^# ID: [0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}"
          ],
          "location_hint": "preceding_line"
        }
      }
    },
    {
      "id": "purity.safety_contract_presence",
      "statement": "Public state-modifying functions MUST have an @atomic_action decorator.",
      "enforcement": "error",
      "rationale": "Required for the 'Will' layer (IntentGuard) to validate safety *before* execution. Defines blast radius and governing policies.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "required_decorator",
          "target": "atomic_action"
        }
      }
    },
    {
      "id": "purity.atomic_action_contract",
      "statement": "The @atomic_action decorator MUST include 'action_id', 'impact', and 'policies'.",
      "enforcement": "error",
      "rationale": "Enables constitutional enforcement BEFORE execution. Without these params, the function is invisible to the governance engine.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "generic_primitive",
          "selector": {
            "has_decorator": "atomic_action"
          },
          "requirement": {
            "check_type": "decorator_args",
            "decorator": "atomic_action",
            "required_kwargs": [
              "action_id",
              "impact",
              "policies"
            ]
          }
        }
      }
    },
    {
      "id": "purity.framework_binding_limits",
      "statement": "Decorators are restricted to Governance Contracts or explicit Framework Bindings (FastAPI, Typer, Pytest).",
      "enforcement": "error",
      "rationale": "Prevents 'Decorator Inflation' where the source code becomes cluttered with non-functional metadata.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Identify decorators that do not serve a runtime framework purpose or a governance requirement."
        }
      }
    }
  ],
  "metadata_strategy": {
    "source_code": {
      "contains": "Logic, Flow Control, Runtime Safety Contracts (@atomic_action)",
      "role": "The Body (Execution)"
    },
    "database": {
      "contains": "Ownership, Capability Definitions, Relationships, Execution History",
      "schema_ref": "001_consolidated_schema.sql",
      "role": "The Mind (Memory & Context)"
    },
    "docstrings": {
      "contains": "Human-readable intent, usage examples, reasoning",
      "role": "Explanation"
    }
  },
  "philosophy": "If the data describes *what* the code is, it lives in the Database. If the data describes *how* the code behaves safely, it lives in the Code (Decorator).",
  "additionalProperties": false
}

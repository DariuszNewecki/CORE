{
  "id": "code_standards",
  "version": "2.1.0",
  "title": "Code Standards Policy",
  "type": "policy",
  "schema_id": "meta.policy",
  "description": "Defines the canonical code quality, layout, naming, and capability standards for the CORE codebase.",
  "owners": {
    "accountable": "Governance Lead",
    "responsible": [
      "Core Maintainer"
    ]
  },
  "review": {
    "frequency": "12 months"
  },
  "rules": [
    {
      "id": "style.linter_required",
      "rationale": "Maintains code health and prevents common bugs through automated static analysis.",
      "enforcement": "error",
      "statement": "All changes MUST pass ruff (lint) before merge.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "linter_compliance"
        }
      }
    },
    {
      "id": "style.formatter_required",
      "rationale": "Ensures a uniform visual style across the codebase to reduce cognitive load during review.",
      "enforcement": "error",
      "statement": "All changes MUST be formatted by black; CI runs black --check.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "linter_compliance"
        }
      }
    },
    {
      "id": "style.fail_on_style_in_ci",
      "rationale": "Prevents malformed or non-compliant code from entering the main branch history.",
      "enforcement": "error",
      "statement": "CI MUST fail on style or lint violations (no auto-fixing in CI).",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "linter_compliance"
        }
      }
    },
    {
      "id": "style.docstrings_public_apis",
      "rationale": "Enables both humans and autonomous agents to correctly reason about and use capabilities.",
      "enforcement": "warning",
      "statement": "Public APIs MUST have docstrings summarizing intent and parameters.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Public APIs MUST have docstrings summarizing intent and parameters."
        }
      }
    },
    {
      "id": "style.universal_helper_first",
      "rationale": "Reduces technical debt and maintenance overhead by centralizing common logic.",
      "enforcement": "warning",
      "statement": "Before creating new helpers, check shared.universal. Reuse or extend instead of duplicating.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Before creating new helpers, check shared.universal. Reuse or extend instead of duplicating."
        }
      }
    },
    {
      "id": "style.capability_id_placement",
      "rationale": "Creates a stable anchor for linking source code logic to the Single Source of Truth database.",
      "enforcement": "warning",
      "statement": "Primary public symbols representing capabilities MUST have '# ID: <uuid>' tags above their definition.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Primary public symbols representing capabilities MUST have '# ID: <uuid>' tags above their definition."
        }
      }
    },
    {
      "id": "style.import_order",
      "rationale": "Prevents circular dependencies and makes module dependencies immediately obvious.",
      "enforcement": "warning",
      "statement": "Imports MUST follow canonical grouping and ordering as enforced by the linter.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "linter_compliance"
        }
      }
    },
    {
      "id": "layout.src_module_header",
      "rationale": "Standardizes file identification for automated filesystem tools and knowledge graph builders.",
      "enforcement": "error",
      "statement": "Every module under 'src/' MUST begin with a file path comment, module docstring, and future import.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "id": "layout.import_grouping",
      "rationale": "Clear separation of external vs internal dependencies simplifies environment debugging.",
      "enforcement": "warning",
      "statement": "Imports MUST be grouped: future, stdlib, third-party, and finally internal modules.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "id": "di.policy_reference",
      "rationale": "Establishes a single authoritative source for dependency management to prevent architectural drift.",
      "enforcement": "warning",
      "statement": "Dependency Injection rules are defined canonically in 'dependency_injection.json'.",
      "check": {
        "engine": "ast_gate",
        "params": {
          "check_type": "import_boundary"
        }
      }
    },
    {
      "id": "refactor.requires_tests",
      "rationale": "Ensures that autonomous or manual structural changes do not introduce functional regressions.",
      "enforcement": "error",
      "statement": "Any refactor that changes public behavior MUST include tests or proof of equivalence.",
      "check": {
        "engine": "workflow_gate",
        "params": {
          "check_type": "test_verification"
        }
      }
    },
    {
      "id": "refactor.update_capabilities",
      "rationale": "Maintains synchronization between the executable logic and the system's semantic memory.",
      "enforcement": "warning",
      "statement": "When moving symbols, update capability tags and manifests accordingly.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: When moving symbols, update capability tags and manifests accordingly."
        }
      }
    },
    {
      "id": "refactor.audit_after",
      "rationale": "Verifies that new code structures still comply with the system's foundational safety rules.",
      "enforcement": "error",
      "statement": "A constitutional audit MUST run after refactors and before merge.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: A constitutional audit MUST run after refactors and before merge."
        }
      }
    },
    {
      "id": "code_standards.max_file_lines",
      "rationale": "Prevents God Objects while allowing necessary complexity for system-critical orchestration and algorithmic density.",
      "details": {
        "thresholds": [
          {
            "path": "src/will/orchestration/**",
            "limit": 600
          },
          {
            "path": "src/mind/logic/**",
            "limit": 600
          },
          {
            "path": "src/features/self_healing/test_generation/**",
            "limit": 500
          },
          {
            "path": "default",
            "limit": 400
          }
        ]
      },
      "enforcement": "error",
      "statement": "Python modules MUST NOT exceed line limits based on their role: Core/Orchestration (600 lines), Features/Services (400 lines), Utilities (200 lines).",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Python modules MUST NOT exceed line limits based on their role: Core/Orchestration (600 lines), Features/Services (400 lines), Utilities (200 lines)."
        }
      }
    },
    {
      "id": "code_standards.max_function_lines",
      "rationale": "Encourages decomposition of complex logic into smaller, more testable units.",
      "enforcement": "warning",
      "statement": "Functions SHOULD NOT exceed 50 lines.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Functions SHOULD NOT exceed 50 lines."
        }
      }
    },
    {
      "id": "async.no_manual_loop_management",
      "rationale": "Prevents event loop conflicts and ensures async logic is properly integrated into the orchestrator.",
      "enforcement": "error",
      "statement": "Business logic and Feature modules MUST NOT call 'asyncio.run()'.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Business logic and Feature modules MUST NOT call 'asyncio.run()'."
        }
      }
    },
    {
      "id": "caps.id_format",
      "rationale": "Provides a consistent regex pattern for AST-based linkage and tracking tools.",
      "enforcement": "error",
      "statement": "Source code linkers MUST use the form '# ID: <uuid>'.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Source code linkers MUST use the form '# ID: <uuid>'."
        }
      }
    },
    {
      "id": "caps.meaningful_description",
      "rationale": "Enables autonomous planners to accurately select capabilities for complex tasks.",
      "enforcement": "error",
      "statement": "Capability descriptions MUST be specific and non-placeholder.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Capability descriptions MUST be specific and non-placeholder."
        }
      }
    },
    {
      "id": "caps.no_placeholder_text",
      "rationale": "Prevents 'ghost capabilities' that degrade system reasoning and documentation quality.",
      "enforcement": "error",
      "statement": "Descriptions such as 'TBD' or 'N/A' are forbidden in capability metadata.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Descriptions such as 'TBD' or 'N/A' are forbidden in capability metadata."
        }
      }
    },
    {
      "id": "caps.owner_required",
      "rationale": "Establishes clear accountability for the lifecycle and correctness of specific logic blocks.",
      "enforcement": "error",
      "statement": "Active capabilities MUST have an assigned owner (agent or team).",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Active capabilities MUST have an assigned owner (agent or team)."
        }
      }
    },
    {
      "id": "symbols.public_capability_id_and_docstring",
      "rationale": "Mandatory for symbols that are exposed to external callers or autonomous agents.",
      "enforcement": "error",
      "statement": "Public capability symbols MUST have an ID comment and a meaningful docstring.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Public capability symbols MUST have an ID comment and a meaningful docstring."
        }
      }
    },
    {
      "id": "symbols.private_helpers_no_id_required",
      "rationale": "Prevents internal implementation details from being tracked as top-level system capabilities.",
      "enforcement": "warning",
      "statement": "Private helpers (starting with '_') MUST NOT receive capability IDs.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Private helpers (starting with '_') MUST NOT receive capability IDs."
        }
      }
    },
    {
      "id": "symbols.cli_async_helpers_private",
      "rationale": "Protects the public API boundary from leaking internal orchestration mechanics.",
      "enforcement": "error",
      "statement": "Async orchestration helpers bridging CLI and domain MUST be private.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Async orchestration helpers bridging CLI and domain MUST be private."
        }
      }
    },
    {
      "id": "intent.policy_file_naming",
      "rationale": "Aligns naming with the constitutional mandate for JSON as the machine-readable format for intent.",
      "enforcement": "error",
      "statement": "All charter policy files must use snake_case and end with '.json'.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "check_type": "naming_convention"
        }
      }
    },
    {
      "id": "intent.policy_schema_naming",
      "rationale": "Allows the validator to deterministically resolve schemas for policy documents.",
      "enforcement": "error",
      "statement": "Schemas for policy files must end with '_policy_schema.json'.",
      "check": {
        "engine": "glob_gate",
        "params": {
          "check_type": "path_restriction"
        }
      }
    },
    {
      "id": "intent.artifact_schema_naming",
      "rationale": "Differentiates implementation schemas from governance policy schemas.",
      "enforcement": "error",
      "statement": "Schemas for non-policy artifacts must end with '_schema.[json|yaml]'.",
      "check": {
        "engine": "llm_gate",
        "params": {
          "instruction": "Verify adherence to: Schemas for non-policy artifacts must end with '_schema.[json|yaml]'."
        }
      }
    },
    {
      "id": "intent.prompt_file_naming",
      "rationale": "Standardizes the discovery of cognitive templates for AI agents.",
      "enforcement": "error",
      "statement": "All prompt files must use snake_case and end with '.prompt'.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "check_type": "naming_convention"
        }
      }
    },
    {
      "id": "intent.proposal_file_naming",
      "rationale": "Identifies change-request artifacts to prevent accidental application without review.",
      "enforcement": "warning",
      "statement": "All proposal files must follow the 'cr-*.yaml' naming convention.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "check_type": "naming_convention"
        }
      }
    },
    {
      "id": "code.python_module_naming",
      "rationale": "Maintains consistency with Python PEP 8 standards and project conventions.",
      "enforcement": "error",
      "statement": "All Python source files must use snake_case naming.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "check_type": "naming_convention"
        }
      }
    },
    {
      "id": "code.python_test_module_naming",
      "rationale": "Ensures reliable discovery by pytest while preventing the misclassification of test-generation logic or utilities.",
      "scope": [
        "tests/**/*.py",
        "src/**/*_test.py"
      ],
      "exceptions": [
        "src/features/self_healing/test_generation/**"
      ],
      "enforcement": "error",
      "statement": "All Python test suites (executable tests) MUST be prefixed with 'test_'.",
      "check": {
        "engine": "regex_gate",
        "params": {
          "check_type": "naming_convention"
        }
      }
    }
  ],
  "additionalProperties": false
}

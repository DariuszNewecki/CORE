# src/features/self_healing/test_generation/code_extractor.py
"""
Robust Python code extraction for test generation.

Centralizes the logic for turning messy LLM responses into a clean
Python snippet that Black and the validator can handle.

Behaviors:
- Prefer JSON/markdown-aware extraction via shared.utils.parsing
- Fallback to a best-effort "strip fences + find first code line"
- Normalize common glitches like leading literal '\\n' or stray backslashes
- Repair invalid multi-line string syntax often generated by LLMs
- Strip XML artifact tags (<final_code>) if they leak through
"""

from __future__ import annotations

import ast
import re

from shared.logger import getLogger
from shared.utils.parsing import extract_python_code_from_response


logger = getLogger(__name__)


# ID: ae84e8f9-4d59-4827-b46b-2e4b4a54ca8d
class CodeExtractor:
    """Extracts and lightly normalizes Python code from LLM responses."""

    # ID: 6f94fcb3-7b9f-46f2-8f75-0b45c9649c3b
    def extract(self, response: str) -> str | None:
        """
        Main entrypoint: extract a usable Python snippet.

        Strategy:
        1. Check for explicit <final_code> XML tags.
        2. Use shared parsing utils to find fenced blocks.
        3. Fallback to raw text analysis.
        4. Repair syntax errors and strip artifact tags.
        """
        if not response:
            return None

        # 1. XML Encapsulation Strategy
        xml_code = self._extract_xml_tagged_code(response)
        if xml_code:
            return self._post_process(xml_code)

        # 2. First try the shared extractor (fenced blocks)
        primary = extract_python_code_from_response(response)
        if primary:
            return self._post_process(primary)

        # 3. Fallback: strip markdown and find first code line
        fallback = self._fallback_extract_python(response)
        if fallback:
            return self._post_process(fallback)

        logger.warning(
            "CodeExtractor: no Python code could be extracted from response preview: %r",
            response[:200],
        )
        return None

    def _extract_xml_tagged_code(self, text: str) -> str | None:
        """
        Extracts content within <final_code> tags.
        """
        pattern = r"<final_code[^>]*>(.*?)</final_code>"
        match = re.search(pattern, text, re.DOTALL | re.IGNORECASE)
        if match:
            content = match.group(1).strip()
            # If the LLM put fences INSIDE the tags, strip them too
            if "```" in content:
                return extract_python_code_from_response(content)
            return content
        return None

    # ID: 5b28a424-8f8d-4a19-9e9c-9a0cbfeee2b6
    def _fallback_extract_python(self, text: str) -> str | None:
        """
        Best-effort extraction for messy responses that defeat the primary extractor.
        """
        if not text:
            return None

        # Remove obvious fenced code markers
        cleaned = text.replace("```python", "").replace("```py", "").replace("```", "")

        lines = [ln.rstrip("\r\n") for ln in cleaned.splitlines()]

        code_start = 0
        for idx, line in enumerate(lines):
            stripped = line.lstrip()
            if not stripped:
                continue
            if stripped.startswith(
                (
                    "def ",
                    "async def ",
                    "class ",
                    "import ",
                    "from ",
                    "#",
                    "@",
                )
            ):
                code_start = idx
                break

        code_lines = lines[code_start:]
        if not any(ln.strip() for ln in code_lines):
            return None

        return "\n".join(code_lines).strip()

    # ID: 9d3c6638-4530-4f87-901d-b066a63f9bed
    def _post_process(self, code: str) -> str:
        """
        Light normalization of the extracted snippet.
        """
        if not code:
            return code

        # 1) Strip XML tags if they leaked through
        code = re.sub(r"</?final_code[^>]*>", "", code, flags=re.IGNORECASE)

        # 2) Turn escaped newlines into real newlines
        if "\\n" in code:
            code = code.replace("\\n", "\n")

        lines = code.splitlines()
        if not lines:
            return code

        # 3) Drop leading completely empty / whitespace-only lines
        while lines and not lines[0].strip():
            lines.pop(0)

        if not lines:
            return ""

        # 4) Fix first line glitches
        first = lines[0]
        if first.startswith("\\n"):
            first = first[2:]
        if first.startswith("\\") and not first.startswith("\\\\"):
            first = first.lstrip("\\")
        lines[0] = first

        # 5) Strip stray leading backslashes
        fixed_lines: list[str] = []
        for line in lines:
            if line.startswith("\\") and not line.startswith("\\\\"):
                fixed_lines.append(line.lstrip("\\"))
            else:
                fixed_lines.append(line)

        # 6) Re-join
        normalized = "\n".join(fixed_lines).rstrip() + "\n"

        # 7) Fix syntax errors where single quotes span multiple lines
        normalized = self._repair_multiline_strings(normalized)

        return normalized

    def _repair_multiline_strings(self, code: str) -> str:
        """
        Detects and fixes invalid multi-line strings created with single/double quotes.
        Matches assignments, assertions, returns, and function calls.
        """
        try:
            ast.parse(code)
            return code
        except SyntaxError:
            pass

        lines = code.splitlines()
        new_lines = []

        in_broken_string = False
        quote_char = None

        # Regex: (prefix_context)(string_prefix)(quote)(content)
        # Prefix context matches:
        # - Assignments: var =
        # - Keywords: assert, return, yield, raise
        # - Function calls: func(
        # - Operators: ==, !=, in
        start_pattern = re.compile(
            r'^(\s*(?:[\w_.]+\s*=|assert\s+|return\s+|yield\s+|raise\s+|.*?\(\s*|.*?\s+(?:==|!=|in)\s+))([frbuFRBU]*)(["\'])(.*)$'
        )

        for line in lines:
            if in_broken_string:
                stripped = line.rstrip()
                if stripped.endswith(quote_char) and not stripped.endswith(
                    f"\\{quote_char}"
                ):
                    if stripped == quote_char:
                        fixed_line = line.replace(quote_char, quote_char * 3, 1)
                    else:
                        fixed_line = line.rstrip()[:-1] + (quote_char * 3)
                    new_lines.append(fixed_line)
                    in_broken_string = False
                    quote_char = None
                else:
                    new_lines.append(line)
                continue

            match = start_pattern.match(line)
            if match:
                prefix_part = match.group(1)
                string_prefix = match.group(2)
                q = match.group(3)
                content = match.group(4)

                # Check if it's actually a valid single line string
                if content.strip().endswith(q) and not content.strip().endswith(
                    f"\\{q}"
                ):
                    new_lines.append(line)
                    continue

                # Check if it's already triple quoted
                if content.startswith(q * 2):
                    new_lines.append(line)
                    continue

                # It looks like a broken multi-line start; convert to triple quotes
                new_line = f"{prefix_part}{string_prefix}{q*3}{content}"
                new_lines.append(new_line)
                in_broken_string = True
                quote_char = q
            else:
                new_lines.append(line)

        return "\n".join(new_lines) + "\n"

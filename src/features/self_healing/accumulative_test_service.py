# src/features/self_healing/accumulative_test_service.py

"""
Accumulates successful tests over time, one symbol at a time.
Strategy: Align the file (Police Agent), then generate tests for healthy code.

Constitutional Principles: evolvable_structure, safe_by_default, knowledge.database_ssot
"""

from __future__ import annotations

import ast
import asyncio
from pathlib import Path
from typing import Any

from features.self_healing.alignment_orchestrator import AlignmentOrchestrator
from features.self_healing.simple_test_generator import SimpleTestGenerator
from shared.config import settings
from shared.logger import getLogger
from shared.utils.subprocess_utils import run_poetry_command
from will.orchestration.cognitive_service import CognitiveService


logger = getLogger(__name__)


# ID: 4333b9d3-e1ae-432c-8395-ecf954342559
class AccumulativeTestService:
    """
    Tries to test every public symbol, keeps what works, skips what doesn't.
    """

    # Canonical signature to distinguish AI-generated tests from manual ones
    CORE_SIGNATURE = "# Generated by CORE AccumulativeTestService"

    def __init__(self, cognitive_service: CognitiveService):
        """Initialize with generator and the new Alignment Orchestrator."""
        self.generator = SimpleTestGenerator(cognitive_service)
        # The Police Agent initialization
        self.orchestrator = AlignmentOrchestrator(cognitive_service)

    # ID: 89efba4f-4231-4a6a-bde4-f8d026628c89
    async def accumulate_tests_for_file(
        self, file_path: str, write: bool = False
    ) -> dict[str, Any]:
        """
        Sequence:
        1. Align file (Police Agent) -> Syntax, Imports, Modularization, IDs, Headers.
        2. Sync & Vectorize (If modified) -> Handled by Orchestrator internally.
        3. Accumulate Tests -> Only for the healthy version of the code.
        """
        # 1. THE POLICE GATE: Ensure file is healthy before testing
        # This handles the 'broken import' in log_audit.py and other structural issues.
        alignment = await self.orchestrator.align_file(file_path, write=write)

        if alignment.get("status") == "failed":
            logger.error(
                "âŒ Police Agent failed to align %s. Aborting test generation.",
                file_path,
            )
            return {
                "file": file_path,
                "status": "skipped",
                "reason": "alignment_failed",
                "total_symbols": 0,
                "tests_generated": 0,
                "success_rate": 0.0,
            }

        # 2. SYMBOL DISCOVERY: Re-read symbols (post-healing)
        # We use to_thread to keep the event loop unblocked (ASYNC230).
        symbols = await asyncio.to_thread(self._find_public_symbols, file_path)

        if not symbols:
            logger.warning("No public symbols to test in %s", file_path)
            return {
                "file": file_path,
                "total_symbols": 0,
                "tests_generated": 0,
                "success_rate": 0.0,
                "test_file": None,
                "successful_symbols": [],
                "failed_symbols": [],
            }

        # 3. TEST GENERATION LOOP
        successful_tests = []
        failed_symbols = []

        for i, symbol in enumerate(symbols, 1):
            logger.info(
                "Generating test for symbol %s (%d/%d)", symbol, i, len(symbols)
            )
            result = await self.generator.generate_test_for_symbol(
                file_path=file_path, symbol_name=symbol
            )

            if result["status"] == "success" and result["passed"]:
                successful_tests.append({"symbol": symbol, "code": result["test_code"]})
                logger.debug("âœ“ Test generated and passed for %s", symbol)
            else:
                failed_symbols.append(symbol)
                logger.warning(
                    "âœ— Failed to generate test for %s: %s", symbol, result.get("reason")
                )

        # 4. PERSISTENCE & CLEANUP
        test_file_path = None
        if successful_tests:
            if write:
                # Safe writer in a thread
                test_file_path = await asyncio.to_thread(
                    self._write_test_file, file_path, successful_tests
                )

                # POST-WRITE CLEANUP: Standardize imports using Ruff
                try:
                    await asyncio.to_thread(
                        run_poetry_command,
                        f"ðŸ§¹ Cleaning test imports for {test_file_path.name}",
                        [
                            "ruff",
                            "check",
                            "--fix",
                            "--select",
                            "I",
                            str(test_file_path),
                        ],
                    )
                except Exception as e:
                    logger.debug("Minor: Ruff cleanup skipped: %s", e)

                logger.info("âœ… Tests accumulated and cleaned: %s", test_file_path)
            else:
                logger.info(
                    "ðŸ’§ [DRY RUN] Would write %d tests for %s",
                    len(successful_tests),
                    file_path,
                )

        success_ratio = len(successful_tests) / len(symbols) if symbols else 0.0

        return {
            "file": file_path,
            "total_symbols": len(symbols),
            "tests_generated": len(successful_tests),
            "success_rate": success_ratio,
            "test_file": str(test_file_path) if test_file_path else None,
            "successful_symbols": [t["symbol"] for t in successful_tests],
            "failed_symbols": failed_symbols,
            "alignment_performed": alignment.get("status") == "healed",
        }

    def _find_public_symbols(self, file_path: str) -> list[str]:
        """Find all public (non-private) functions and classes via AST."""
        try:
            full_path = settings.REPO_PATH / file_path
            if not full_path.exists():
                return []
            source = full_path.read_text(encoding="utf-8")
            tree = ast.parse(source)
            symbols = []
            for node in ast.walk(tree):
                if isinstance(
                    node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)
                ):
                    if not node.name.startswith("_"):
                        symbols.append(node.name)
            return symbols
        except Exception as e:
            logger.error("Failed to parse symbols in %s: %s", file_path, e)
            return []

    def _write_test_file(self, source_file: str, successful_tests: list[dict]) -> Path:
        """
        Combine successful tests into a single test file.
        SAFE BY DEFAULT: Uses a sidecar if the target file is human-authored.
        """
        source_path = Path(source_file)
        # Handle src/ relative paths
        if "src/" in str(source_path):
            rel_path = str(source_path).split("src/", 1)[1]
        else:
            rel_path = source_path.name

        module_parts = Path(rel_path).parts
        if len(module_parts) > 1:
            test_dir = Path("tests") / Path(*module_parts[:-1])
        else:
            test_dir = Path("tests")

        test_file_name = f"test_{source_path.stem}.py"
        test_file_path = (settings.REPO_PATH / test_dir / test_file_name).resolve()

        # CONSTITUTIONAL SAFETY: Protect manual tests
        if test_file_path.exists():
            content = test_file_path.read_text(encoding="utf-8")
            if self.CORE_SIGNATURE not in content:
                # RELIABILITY FIX: Use underscore instead of dot to prevent
                # import errors while still marking it as CORE output.
                logger.warning(
                    "Manual tests detected in %s. Using sidecar.", test_file_name
                )
                test_file_path = (
                    test_file_path.parent / f"test_{source_path.stem}_core.py"
                )

        test_file_path.parent.mkdir(parents=True, exist_ok=True)

        # Prepare header
        header = (
            f"{self.CORE_SIGNATURE}\n"
            f"# Source: {source_file}\n"
            f"# Symbols: {len(successful_tests)}\n\n"
        )

        test_body = "\n\n".join([test["code"] for test in successful_tests])

        test_file_path.write_text(header + test_body + "\n", encoding="utf-8")
        return test_file_path

# src/agents/planner_agent.py
"""
Handles the decomposition of high-level goals into structured, code-free execution plans using LLM orchestration.
"""

from __future__ import annotations

import contextvars
import textwrap
from datetime import datetime, timezone
from typing import Any, Dict, List

from pydantic import ValidationError

from agents.models import ExecutionTask, PlannerConfig
from agents.plan_executor import PlanExecutionError
from core.clients import BaseLLMClient
from core.prompt_pipeline import PromptPipeline
from shared.logger import getLogger
from shared.utils.parsing import extract_json_from_response

log = getLogger(__name__)
execution_context = contextvars.ContextVar("execution_context")


class PlannerAgent:
    """Decomposes goals into plans but does not execute them."""

    def __init__(
        self,
        orchestrator_client: BaseLLMClient,
        prompt_pipeline: PromptPipeline,
        context: Dict[str, Any],
    ):
        """Initializes the PlannerAgent with its dependencies."""
        self.orchestrator = orchestrator_client
        self.prompt_pipeline = prompt_pipeline

        raw_config = (
            context.get("policies", {})
            .get("agent_behavior_policy", {})
            .get("planner_agent", {})
        )
        self.config = PlannerConfig(**raw_config)

    def _setup_logging_context(self, goal: str, plan_id: str):
        """Sets up a structured logging context for a planning cycle."""
        execution_context.set(
            {
                "goal": goal,
                "plan_id": plan_id,
                "timestamp": datetime.now(timezone.utc).isoformat(),
            }
        )

    def _log_plan_summary(self, plan: List[ExecutionTask]) -> None:
        """Logs a human-readable summary of the generated execution plan."""
        log.info(f"ðŸ“‹ Execution Plan Summary ({len(plan)} tasks):")
        for i, task in enumerate(plan, 1):
            log.info(f"  {i}. [{task.action}] {task.step}")

    def _validate_task_params(self, task: ExecutionTask):
        """Validates that a task has all required parameters for its specified action."""
        params = task.params
        required = []
        if task.action == "add_capability_tag":
            required = ["file_path", "symbol_name", "tag"]
        elif task.action == "create_file":
            required = ["file_path"]
        elif task.action == "edit_function":
            required = ["file_path", "symbol_name"]
        elif task.action == "create_proposal":
            # The `code` parameter is added later by the ExecutionAgent, so it's not required here.
            required = ["file_path", "justification"]

        if not all(getattr(params, p, None) for p in required):
            raise PlanExecutionError(
                f"Task '{task.step}' is missing required parameters for action '{task.action}'."
            )

    # CAPABILITY: llm_orchestration
    def create_execution_plan(self, high_level_goal: str) -> List[ExecutionTask]:
        """Decomposes a high-level goal into a structured, code-free execution plan using an LLM."""
        plan_id = f"plan_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')}"
        self._setup_logging_context(high_level_goal, plan_id)
        log.info("ðŸ§  Decomposing goal into a high-level plan...")

        prompt_template = textwrap.dedent(
            """
            You are a hyper-competent, meticulous system architect AI. Your task is to decompose a high-level goal into a JSON execution plan.
            Your entire output MUST be a single, valid JSON array of objects.

            **High-Level Goal:** "{goal}"

            **Available Actions & Required Parameters:**
            - Action: `create_file` (For NEW files only) -> Params: `{{ "file_path": "<path>" }}`
            - Action: `create_proposal` (For changing EXISTING files) -> Params: `{{ "file_path": "<path_to_change>", "justification": "<reason_for_change>" }}`

            **CRITICAL RULES:**
            1. The `step` field for each object MUST be a descriptive string explaining the action.
            2. For `create_proposal`, the `code` parameter will be generated by a different agent. You MUST NOT include it in your output.
            3. Do not use `edit_function` or `add_capability_tag`. Modify files using `create_proposal`.

            **EXAMPLE OUTPUT:**
            ```json
            [
              {{
                "step": "Create a new file to contain the main application logic.",
                "action": "create_file",
                "params": {{
                  "file_path": "src/app/main.py"
                }}
              }},
              {{
                "step": "Propose an update to the project manifest to include the new capability.",
                "action": "create_proposal",
                "params": {{
                  "file_path": ".intent/project_manifest.yaml",
                  "justification": "Add the new core application capability to the manifest."
                }}
              }}
            ]
            ```

            Generate the plan now based on the goal.
            """
        ).strip()

        final_prompt = prompt_template.format(goal=high_level_goal)
        enriched_prompt = self.prompt_pipeline.process(final_prompt)

        max_retries = self.config.max_retries
        for attempt in range(max_retries):
            try:
                response_text = self.orchestrator.make_request(
                    enriched_prompt, user_id="planner_agent_architect"
                )
                parsed_json = extract_json_from_response(response_text)
                if not parsed_json:
                    raise ValueError("No valid JSON found in response")
                if isinstance(parsed_json, dict):
                    parsed_json = [parsed_json]

                validated_plan = [ExecutionTask(**task) for task in parsed_json]
                for task in validated_plan:
                    self._validate_task_params(task)

                self._log_plan_summary(validated_plan)
                return validated_plan
            except (ValueError, ValidationError) as e:
                log.warning(f"Plan creation attempt {attempt + 1} failed: {e}")
                if attempt == max_retries - 1:
                    raise PlanExecutionError(
                        "Failed to create a valid high-level plan after max retries."
                    )
        return []
